<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://abelcorn.cn</id>
    <title>小石石石</title>
    <updated>2019-10-19T01:44:11.089Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://abelcorn.cn"/>
    <link rel="self" href="https://abelcorn.cn/atom.xml"/>
    <subtitle>Always do your best.</subtitle>
    <logo>https://abelcorn.cn/images/avatar.png</logo>
    <icon>https://abelcorn.cn/favicon.ico</icon>
    <rights>All rights reserved 2019, 小石石石</rights>
    <entry>
        <title type="html"><![CDATA[数据结构实验--约瑟夫环]]></title>
        <id>https://abelcorn.cn/post/datastructures_ex_josephus</id>
        <link href="https://abelcorn.cn/post/datastructures_ex_josephus">
        </link>
        <updated>2019-10-19T01:32:21.000Z</updated>
        <summary type="html"><![CDATA[<p>Josephus排列问题定义如下：假设n个竞赛者排成一个环形。给定一个正整数m≤n，从第1人开始，沿环计数，第m人出列。这个过程一直进行到所有人都出列为止。最后出列者为优胜者。全部出列次序定义了1，2，…n的一个排列。称为（n，m）Josephus排列。例如，（7，3）Josephus排列为3,6,2,7,5,1,4。且若m为偶数则逆时针开始，为奇数为顺时针。</p>
]]></summary>
        <content type="html"><![CDATA[<p>Josephus排列问题定义如下：假设n个竞赛者排成一个环形。给定一个正整数m≤n，从第1人开始，沿环计数，第m人出列。这个过程一直进行到所有人都出列为止。最后出列者为优胜者。全部出列次序定义了1，2，…n的一个排列。称为（n，m）Josephus排列。例如，（7，3）Josephus排列为3,6,2,7,5,1,4。且若m为偶数则逆时针开始，为奇数为顺时针。</p>
<!--more-->
<p><strong>C语言</strong>：</p>
<pre><code class="language-c">//@约瑟夫环 C语言版本
// Created by abel on 2019/10/18.
//

#ifndef CLIONCODE_JOSEPHUS_H
#define CLIONCODE_JOSEPHUS_H

#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;stdbool.h&gt;

//约瑟夫环结点
typedef struct Josephus
{
    int data;//每个结点的数据
    struct Josephus *front;//指向前驱
    struct Josephus *next;//指向后继
}list;


//顺序打印一次
void display(list *list1,int m)
{
    if(m%2==0)
    {
        list *p = list1;
        printf(&quot;约瑟夫环当前数据为：\n&quot;);
        while (p-&gt;front!=list1)
        {
            printf(&quot;%d &quot;,p-&gt;data);
            p=p-&gt;front;
        }
        printf(&quot;%d\n&quot;,p-&gt;data);
    } else
    {
        list *p = list1;
        printf(&quot;约瑟夫环当前数据为：\n&quot;);
        while (p-&gt;next!=list1)
        {
            printf(&quot;%d &quot;,p-&gt;data);
            p=p-&gt;next;
        }
        printf(&quot;%d\n&quot;,p-&gt;data);
    }
}

//具体的操作函数
void startTheGame(list *list1,int n,int m)
{
    if(m==0)//如果m为0，则无法进行游戏
    {
        printf(&quot;Invalid Index of m!\n&quot;);
    }
    else if(m%2==0)//如果操作序列为偶数，则逆时针游戏
    {
        list *p = list1;
        //当结点数不为0
        printf(&quot;按%d为步长的序列为:\n&quot;,m);
        for(int i=1;n!=0;i++)
        {
            if(i%m==0)
            {
                printf(&quot;%d &quot;,p-&gt;data);//打印结点数据
                list *temp = p;//中间保存被删除结点的临时结点
                p = p-&gt;front;//将操作指针移到上一位
                //将已经打印过的结点与链表断开
                p-&gt;next-&gt;next-&gt;front = p;
                p-&gt;next = p-&gt;next-&gt;next;
                //将临时结点值修改
                temp-&gt;data=0;
                temp-&gt;front=temp-&gt;next=NULL;
                free(temp);//释放被打印过的结点
                n--;
            }
            else//如果没有移到固定的步长m，则继续移动
            {
                p=p-&gt;front;
            }
        }
    }
    else//如果m为奇数，则顺时针开始
    {
        list *p = list1;//操作指针
        printf(&quot;按%d为步长的序列为:\n&quot;,m);
        for(int i=1;n!=0;i++)//循环
        {
            if(i%m==0)//如果移动次数为m
            {
                printf(&quot;%d &quot;,p-&gt;data);//打印此时的结点数据
                list *temp = p;//中间结点保存被打印的结点
                p=p-&gt;next;//操作指针移向下一个
                //将被打印的结点从链表中移除
                p-&gt;front-&gt;front-&gt;next=p;
                p-&gt;front=p-&gt;front-&gt;front;
                //修改被打印结点的数据
                temp-&gt;data=0;
                temp-&gt;front=temp-&gt;next=NULL;
                free(temp);//释放此结点
                n--;//减少结点总数
            }
            else//如果移动步数非m
            {
                p=p-&gt;next;//移动操作指针
            }
        }
    }
}

//创建链表并操作
list *createLink(int n,int m)//序列
{
    list *list1 = (list*)malloc(sizeof(list));//开辟空间
    if(!list1)//判断空间开辟是否成功
    {
        printf(&quot;Memory Error!\n&quot;);
        return NULL;
    }
    //初始化第一个结点
    list1-&gt;next=list1-&gt;front=NULL;
    list1-&gt;data = 1;

    list *p = list1;//操作指针
    for(int i=2;i&lt;=n;i++)//遍历赋值
    {
        list * temp = (list*)malloc(sizeof(list));//中间结点
        if(!temp)//判断结点空间开辟是否成功
        {
            printf(&quot;Memory Error!\n&quot;);
            return NULL;
        }
        temp-&gt;data = i;//序号赋值
        temp-&gt;next=NULL;//默认next为空
        temp-&gt;front = p;//前向指针指向当前p
        p-&gt;next=temp;//p的下一个接上中间结点
        p=p-&gt;next;//p移到中间结点上
    }
    list1-&gt;front=p;
    p-&gt;next=list1;//将尾结点next接到list1(头结点)上
    return list1;
}

//程序启动的函数
void Josephus()
{
    int n=0,m=0;
    printf(&quot;请输入约瑟夫序列:\n&quot;);
    printf(&quot;总人数n: &quot;);
    scanf(&quot;%d&quot;,&amp;n);
    printf(&quot;操作步长m: &quot;);
    scanf(&quot;%d&quot;,&amp;m);
    if(n&lt;1)
    {
        printf(&quot;Invalid People Number!\n&quot;);
    }
    else
    {
        if(m&lt;1)
        {
            printf(&quot;Invalid Index!\n&quot;);
        }
        else
        {
            list *list1 = createLink(n,m);
            display(list1,m);
            startTheGame(list1,n,m);
        }
    }
}
#endif //CLIONCODE_JOSEPHUS_H
</code></pre>
<ul>
<li>在调用时，main中</li>
</ul>
<pre><code class="language-c">#include &quot;Josephus.h&quot;
int main()
{
    Josephus();
    return 0;
}
</code></pre>
<ul>
<li>运行示例如下：<br>
<code>请输入约瑟夫序列:</code><br>
<code>总人数n: 7</code><br>
<code>操作步长m: 3</code><br>
<code>约瑟夫环当前数据为：</code><br>
<code>1 2 3 4 5 6 7</code><br>
<code>按3为步长的序列为:</code><br>
<code>3 6 2 7 5 1 4</code></li>
</ul>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[数据结构--顺序栈]]></title>
        <id>https://abelcorn.cn/post/stack</id>
        <link href="https://abelcorn.cn/post/stack">
        </link>
        <updated>2019-10-15T01:03:49.000Z</updated>
        <summary type="html"><![CDATA[<p>顺序栈将以四种语言呈现，但不会有太多注释，<s>毕竟比较简单</s></p>
]]></summary>
        <content type="html"><![CDATA[<p>顺序栈将以四种语言呈现，但不会有太多注释，<s>毕竟比较简单</s></p>
<!--more-->
<ul>
<li>C语言版本</li>
</ul>
<pre><code class="language-c">//@顺序栈 C语言版
// Created by abel on 2019/10/15.
//

#ifndef C_STACK_H
#define C_STACK_H

#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;stdbool.h&gt;
//默认的最大长度
#define SIZE 10
//结点
typedef struct Stack
{
    int *data;
    int top;
    int capacity;
}stack;

//创建链表
stack *createStack()
{
    stack *stack1 = (stack*)malloc(sizeof(stack));
    if(!stack1)//检查空间开辟情况
    {
        printf(&quot;Memory Error!\n&quot;);
        return NULL;
    }
    stack1-&gt;capacity = SIZE;//最大长度
    stack1-&gt;data = (int*)malloc(sizeof(int)*stack1-&gt;capacity);//开辟数组
    stack1-&gt;top=-1;//栈位置标志
    if(!stack1-&gt;data)
    {
        printf(&quot;Memory Error!\n&quot;);
        return NULL;
    }
    for(int i=0;i&lt;3;i++)//初始化赋值进去
    {
        stack1-&gt;data[i]=i+1;
    }
    stack1-&gt;top=2;//加两个
    return stack1;
}

//判断为空
bool isEmpty(stack *stack1)
{
    return (stack1-&gt;top==-1);
}

//判断为满
bool isFull(stack *stack1)
{
    return stack1-&gt;top==stack1-&gt;capacity-1;
}

//入栈
void push(stack * stack1,int elem)
{
    if(!isFull(stack1))
    {
        stack1-&gt;data[stack1-&gt;top+1]=elem;
        stack1-&gt;top++;
    } else
    {
        printf(&quot;Full\n&quot;);
    }
}
//出栈
int pop(stack* stack1)
{
    if(!isEmpty(stack1))
    {
        return stack1-&gt;data[stack1-&gt;top--];
    }
    printf(&quot;Error\n&quot;);
    return -1;
}

//得到栈顶元素
int getElem(stack *stack1)
{
    if(!isEmpty(stack1))
    {
        return stack1-&gt;data[stack1-&gt;top];
    }
    printf(&quot;Error\n&quot;);
    return -1;
}

//显示所有数据
void display(stack *stack1)
{
    if(!isEmpty(stack1))
    {
        for(int i=0;i&lt;=stack1-&gt;top;i++)
        {
            printf(&quot;%d &quot;,stack1-&gt;data[i]);
        }
        printf(&quot;\n&quot;);
    }
    else
    {
        printf(&quot;Empty\n&quot;);
        return;
    }
}
#endif //C_STACK_H
</code></pre>
<ul>
<li>C++版本</li>
</ul>
<pre><code class="language-c++">//@顺序栈 CPP版
// Created by abel on 2019/10/15.
//

#ifndef C___STACK_H
#define C___STACK_H

#include &lt;iostream&gt;
using namespace std;

const int SIZE = 10;
class Stack
{
private:
    int *data;
    int capacity;
    int top;
public:
    Stack()//创建栈
    {
        capacity = SIZE;
        data = new int[capacity];
        top=-1;
    }

    bool isEmpty();//栈空

    bool isFull();//栈满

    void push(int elem);//入栈

    int getElem();//得到最上面元素

    int pop();//出栈

    void display();//显示所以元素，做检查
};

bool Stack::isEmpty() {
    return top==-1;
}

bool Stack::isFull() {
    return top+1==capacity;
}

void Stack::push(int elem) {
    if(!isFull())
    {
        data[top+1]=elem;
        top++;
    }
    else
    {
        cout&lt;&lt;&quot;Full!&quot;&lt;&lt;endl;
    }
}

int Stack::getElem() {
    if(!isEmpty())
    {
        return data[top];
    } else
    {
        cout&lt;&lt;&quot;empty&quot;&lt;&lt;endl;
        return -1;
    }
}

int Stack::pop() {
    if(!isEmpty())
    {
        return data[top--];
    }
    else
    {
        cout&lt;&lt;&quot;empty&quot;&lt;&lt;endl;
        return -1;
    }
}

void Stack::display() {
    if(!isEmpty())
    {
        for(int i=0;i&lt;=top;i++)
        {
            cout&lt;&lt;data[i]&lt;&lt;&quot; &quot;;
        }
        cout&lt;&lt;endl;
    }
    else
    {
        cout&lt;&lt;&quot;Empty!\n&quot;;
        return;
    }
}
#endif //C___STACK_H
</code></pre>
<ul>
<li>Java版本</li>
</ul>
<pre><code class="language-java">//@顺序栈 Java版
//Created by abel on 2019/10/15.
//
public class Stack
{
	final int SIZE = 10;
	private int top;
	private int capacity;
	private int[] data;
	
	Stack()
	{
		this.capacity = SIZE;
		this.data = new int[capacity];
		this.top = -1;
	}
	
	public boolean isEmpty()
	{
		return (top==-1);
	}
	public boolean isFull()
	{
		return (top==capacity-1);
	}
	public void enlarge()
	{
		this.capacity *= 2;
		int []temp = new int[top+1];
		for(int i=0;i&lt;top;i++)
		{
			temp[i]=this.data[i];
		}
		this.data = new int[this.capacity];
		for(int i=0;i&lt;top;i++)
		{
			this.data[i] = temp[i];
		}
	}
	public void push(int elem)
	{
		if(!isFull())
		{
			data[top+1]=elem;
			top++;
		}
		else
		{
			System.out.println(&quot;Enlarge...&quot;);
			enlarge();
			data[top+1]=elem;
			top++;
		}
	}
	public int getElem()
	{
		if(!isEmpty())
		{
			return data[top];
		}
		else
		{
			System.out.println(&quot;Empty!&quot;);
			return -1;
		}
	}
	public int pop()
	{
		if(!isEmpty())
		{
			return data[top--];
		}
		else
		{
			System.out.println(&quot;Empty!&quot;);
			return -1;
		}
	}
}
</code></pre>
<ul>
<li>以下为C#版本</li>
</ul>
<pre><code class="language-c#">//@顺序栈 C#版
//Created by abel on 2019/10/15.
//

using System;

public class Stack
{
    const int SIZE = 10;
    private int capacity;
    private int top;
    private int[] data;

    public Stack()
    {
        this.capacity = SIZE;
        this.data = new int[capacity];
        this.top = -1;
    }

    public bool isEmpty()
    {
        return (top == -1);
    }
    public bool isFull()
    {
        return (top == capacity - 1);
    }
    public void push(int elem)
    {
        if(!isFull())
        {
            top++;
            data[top] = elem;
        }
        else
        {
            Console.WriteLine(&quot;Full!&quot;);
        }
    }
    public int getELem()
    {
        if(!isEmpty())
        {
            return data[top];
        }
        return -1;
    }
    public int pop()
    {
        if(isEmpty())
        {
            return data[top--];
        }
        return -1;
    }

    
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[数据结构--单链表]]></title>
        <id>https://abelcorn.cn/post/singlelink</id>
        <link href="https://abelcorn.cn/post/singlelink">
        </link>
        <updated>2019-10-14T13:45:44.000Z</updated>
        <summary type="html"><![CDATA[<p>没人看没人看，伤心😣<br>
本版为链表结构中的单链表。双向链表和循环链表将以实验--约瑟夫环的实际应用的方式呈现。</p>
]]></summary>
        <content type="html"><![CDATA[<p>没人看没人看，伤心😣<br>
本版为链表结构中的单链表。双向链表和循环链表将以实验--约瑟夫环的实际应用的方式呈现。</p>
<!--more-->
<ul>
<li>以下为C语言的单链表</li>
</ul>
<pre><code class="language-c">//@单链表 C语言版
// Created by abel on 2019/10/14.
//

#ifndef C_SINGLELINK_H
#define C_SINGLELINK_H

#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;stdbool.h&gt;

//单链表的基本结构
typedef struct Link
{
    int data;//数据域
    struct Link *next;//结点
}link;//新名字

//初始化创建链表
link *createLink()
{
    link *link1 = (link*)malloc(sizeof(link));//分配内存
    if(!link1)//检查内存分配成功情况
    {
        printf(&quot;Memory Error!\n&quot;);
        return NULL;
    }
    link1-&gt;data=0;//初始化
    link1-&gt;next=NULL;

    link *p = link1;
    for(int i=0;i&lt;3;i++)//为测试，给链表赋初始值
    {
        link *a = (link*)malloc(sizeof(link));
        a-&gt;data = i+1;
        a-&gt;next = NULL;

        p-&gt;next = a;
        p=p-&gt;next;
    }
    return link1;
}

//判断是否为空
bool isEmpty(link *link1)
{
    return (link1==NULL);
}

//插入元素
void insertElem(link *link1,int position,int elem)
{
    if(position&lt;1)//判断位置
    {
        printf(&quot;Error Position\n&quot;);
    }
    else
    {
        link *p = link1;
        for(int i=0;i&lt;position-1;i++)//遍历到要插入的位置处
        {
            if(p==NULL)
            {
                printf(&quot;Wrong Position\n&quot;);
                exit(-1);
            }
            p=p-&gt;next;
        }
        link *link2 = (link*)malloc(sizeof(link));
        if(!link2)
        {
            printf(&quot;Temp Link Memory Error!\n&quot;);
        }
        //插入结点
        else{
            link2-&gt;data = elem;
            link2-&gt;next = p-&gt;next;
            p-&gt;next = link2;
        }
    }
}

//删除元素
int deleteElem(link *link1,int position)
{
    if(!isEmpty(link1))//判断是否为空
    {
        if(position&lt;1)//判断位置
        {
            printf(&quot;Error Position\n&quot;);
            return -1;
        }
        else
        {
            link *p = link1;
            for(int i=0;i&lt;position-1;i++)//遍历到要删除的地方
            {
                if(p==NULL)
                {
                    printf(&quot;Error Position\n&quot;);
                    return -1;
                }
                p=p-&gt;next;
            }
            int data = p-&gt;next-&gt;data;//保存被删除的值
            link *temp = (link*)malloc(sizeof(link));
            temp-&gt;next = p-&gt;next;
            p-&gt;next=p-&gt;next-&gt;next;//重新链接链表
            free(temp);//释放被删除的结点
            return data;//返回数据
        }
    } else
    {
        printf(&quot;Empty Link\n&quot;);
        return -1;
    }
}

//查找元素第一次出现的位置
int find_position(link *link1,int elem)
{
    if(!isEmpty(link1))//判断非空
    {
        link *p = link1;
        for(int i=0;p!=NULL;i++)
        {
            p=p-&gt;next;
            if(elem == p-&gt;data)
            {
                return i+1;
            }

        }
    }
    else
    {
        return -2;
    }
    return 0;
}

//遍历显示全部信息
void display(link *link1)
{
    if(!isEmpty(link1))//判断空链
    {
        link *p = link1;
        while (p-&gt;next)
        {
            p=p-&gt;next;
            printf(&quot;%d &quot;,p-&gt;data);
        }
        printf(&quot;\n&quot;);
    } else
    {
        printf(&quot;Empty!\n&quot;);
    }
}


#endif //C_SINGLELINK_H
</code></pre>
<ul>
<li>以下为C++版本的单链表</li>
</ul>
<pre><code class="language-c++">//@单链表CPP版
// Created by abel on 2019/10/14.
//

#ifndef C___SINGLELINK_H
#define C___SINGLELINK_H

#include &lt;iostream&gt;
using namespace std;

typedef struct Node
{
    int data;
    Node *next;
}link;

class Link
{
private:
    link *link1;
public:
    //构造函数
    Link();
    //插入元素
    void insertElem(int position,int elem);
    //查看是否为空
    bool isEmpty();
    //得到固定位置的元素
    int getElem(int position);
    //删除元素
    int deleteElem(int position);
    //遍历显示全部元素
    void display();
};

Link::Link() {
    link1 = new link;
    link1-&gt;data = 0;
    link1-&gt;next = nullptr;
}

void Link::insertElem(int position, int elem) {
    if(position&lt;1)
    {
        cout&lt;&lt;&quot;Error Position&quot;&lt;&lt;endl;
    }
    else
    {
        link *p = link1;
        for(int i=0;i&lt;position-1;i++)
        {
            if(p-&gt;next== nullptr)
            {
                cout&lt;&lt;&quot;Error Position!&quot;&lt;&lt;endl;
            }
            p = p-&gt;next;
        }
        link *temp = new link;
        temp-&gt;data=elem;
        temp-&gt;next = p-&gt;next;
        p-&gt;next=temp;
    }
}

bool Link::isEmpty() {
    return (link1-&gt;next== nullptr);
}

int Link::getElem(int position) {
    if(!isEmpty())
    {
        if(position&lt;1)
        {
            cout&lt;&lt;&quot;Error Position!&quot;&lt;&lt;endl;
            return -1;
        }
        else
        {
            link *p = link1;
            for(int i=0;i&lt;position-1;i++)
            {
                if(p-&gt;next== nullptr)
                {
                    cout&lt;&lt;&quot;Error Position&quot;&lt;&lt;endl;
                    break;
                }
                else
                {
                    p=p-&gt;next;
                }
            }
            p=p-&gt;next;
            return p-&gt;data;
        }
    }
    else
    {
        cout&lt;&lt;&quot;Empty!&quot;&lt;&lt;endl;
        return -1;
    }
}

int Link::deleteElem(int position){
    if(!isEmpty())
    {
        if(position&lt;1)
        {
            cout&lt;&lt;&quot;Error Position&quot;&lt;&lt;endl;
            exit(-1);
        }
        else
        {
            link *p = link1;
            for(int i=0;i&lt;position-1;i++)
            {
                if(p-&gt;next == nullptr)
                {
                    cout&lt;&lt;&quot;Error Position&quot;;
                    break;
                }
                else
                {
                    p=p-&gt;next;
                }
            }
            link *temp = new link;
            temp-&gt;next = p-&gt;next;
            temp-&gt;data = p-&gt;next-&gt;data;
            p-&gt;next = p-&gt;next-&gt;next;
            int t = temp-&gt;data;
            delete temp;
            return t;
        }
    }
    else
    {
        cout&lt;&lt;&quot;Empty!&quot;&lt;&lt;endl;
        exit(-1);
    }
}

void Link::display() {
    if(!isEmpty())//判断是否为空
    {
        link * p = link1;
        while (p-&gt;next)
        {
            p=p-&gt;next;
            cout&lt;&lt;p-&gt;data&lt;&lt;&quot; &quot;;
        }
        cout&lt;&lt;endl;
    }
    else
    {
        cout&lt;&lt;&quot;Error! Empty!&quot;&lt;&lt;endl;
    }
}
#endif //C___SINGLELINK_H
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[数据结构--顺序表]]></title>
        <id>https://abelcorn.cn/post/table</id>
        <link href="https://abelcorn.cn/post/table">
        </link>
        <updated>2019-10-11T13:59:34.000Z</updated>
        <summary type="html"><![CDATA[<ul>
<li>由于我太穷了，买不起matlab，所以它试用期到了，我暂时不写matlab的专题了。</li>
<li>毕竟这学期在学数据结构，虽然只学C语言版的，但我想总是大同小异嘛，所以从现在开始我会同步自己的代码上来。PS：<s>实际上是担心写的代码没了，所以这样保险一点。</s></li>
<li>我会以<s>C、C++和Java三种语言写</s>新增C#，当然了，因为Java(和C#)是自学的，且截止今天我才学了两天，有问题的地方还望各位大佬指正。</li>
</ul>
]]></summary>
        <content type="html"><![CDATA[<ul>
<li>由于我太穷了，买不起matlab，所以它试用期到了，我暂时不写matlab的专题了。</li>
<li>毕竟这学期在学数据结构，虽然只学C语言版的，但我想总是大同小异嘛，所以从现在开始我会同步自己的代码上来。PS：<s>实际上是担心写的代码没了，所以这样保险一点。</s></li>
<li>我会以<s>C、C++和Java三种语言写</s>新增C#，当然了，因为Java(和C#)是自学的，且截止今天我才学了两天，有问题的地方还望各位大佬指正。</li>
</ul>
<!--more-->
<p>###顺序表-C语言版：</p>
<pre><code class="language-C">//@顺序表 C版本
// Created by abel on 2019/10/11.
//

#ifndef C_TABLE_H
#define C_TABLE_H

#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;stdbool.h&gt;

#define CAPACITY 10
//为表的容量做准备

//顺序表的结构体
typedef struct Table
{
    int *data;//表的存储数组，为简便表示设置为int
    int capacity;//表的最大容量
    int length;//表的当前长度
}table;

//创建表
table *createTable()
{
    table *table1 = (table*)malloc(sizeof(table));//生成表
    //判断开辟的表空间分配是否正常
    if(!table1)
    {
        printf(&quot;Table Memory Error!\n&quot;);
        return NULL;
    }
    table1-&gt;capacity = CAPACITY;//初始化表的容量
    table1-&gt;data = (int*)malloc(sizeof(int)*table1-&gt;capacity);//为数组开辟空间
    //判断空间开辟是否成功
    if(!table1-&gt;data)
    {
        printf(&quot;Data Memory Error!\n&quot;);
        return NULL;
    }
    table1-&gt;length=0;//初始化当前长度为0

    for(int i=0;i&lt;3;i++)//给初始化数据便于测试
    {
        table1-&gt;data[i]=i+1;
    }
    table1-&gt;length=3;
    return table1;//返回该表
}

//检查表是否为空
bool isEmpty(table *table1)
{
    if(table1-&gt;length==0)
    {
        return true;
    }
    return false;
}

//检查表是否为满
bool isFull(table *table1)
{
    if(table1-&gt;length == table1-&gt;capacity)
    {
        return true;
    }
    return false;
}

//扩容
bool enlargeTable(table *table1)
{
    table1-&gt;capacity *= 2;//先将最大容量乘2
    table1-&gt;data = realloc(table1-&gt;data, sizeof(int)*table1-&gt;capacity*2);//将data数组里面的内容重新扩展
    //检查扩容是否成功
    if(!table1-&gt;data)
    {
        return false;
    }
    return true;
}

//新增数据
void pushTable(table *table1,int position,int elem)//分别是表、位置和新增的元素
{
    if(!isFull(table1))//先判断表是否满了
    {
        if(position&lt;1||position&gt;table1-&gt;length)//判断插入位置是否有问题
        {
            printf(&quot;插入位置有误!\n&quot;);
            exit(-1);//退出
        }
        for(int i=table1-&gt;length;i&gt;=position-1;i--)//遍历将插入位置及之后的元素后移
        {
            table1-&gt;data[i]=table1-&gt;data[i-1];
        }
        table1-&gt;data[position-1]=elem;//插入元素
        table1-&gt;length++;//增加长度
        printf(&quot;元素 %d 新增成功!\n&quot;,elem);//打印成功消息
    }
    else
    {
        printf(&quot;空间不足，正在扩容......!\n&quot;);
        enlargeTable(table1);//扩大容量
        //以下功能同上
        if(position&lt;1||position&gt;table1-&gt;length)
        {
            printf(&quot;插入位置有误!\n&quot;);
            exit(-1);
        }
        for(int i=table1-&gt;length;i&gt;=position-1;i--)
        {
            table1-&gt;data[i]=table1-&gt;data[i-1];
        }
        table1-&gt;data[position-1]=elem;
        table1-&gt;length++;
        printf(&quot;元素 %d 新增成功!\n&quot;,elem);
    }
}

//删除数据
int popTable(table *table1,int position)//表、所要删除的位置
{
    if(!isEmpty(table1))//判断是否是空表
    {
        if(position&lt;1||position&gt;table1-&gt;length)//检查删除位置是否正确
        {
            printf(&quot;删除的位置有误!\n&quot;);
            exit(-2);
        }
        int delete_data = table1-&gt;data[position-1];//记录被删除的元素
        for(int i=position-1;i&lt;table1-&gt;length;i++)//循环前移元素
        {
            table1-&gt;data[i]=table1-&gt;data[i+1];
        }
        table1-&gt;length--;//减少一个长度记录
        printf(&quot;表中第 %d 号元素 %d 删除成功!\n&quot;,position,delete_data);//将所删除的元素显示出来
        return delete_data;//返回它
    }
    else
    {
        printf(&quot;表已经空了，你还删啥？\n&quot;);
        return -2;
    }
}

//修改数据
void changeTable(table *table1,int position,int new_elem)//表、修改元素的位置、新元素
{
    if(!isEmpty(table1))//先判断是否为空
    {
        if(position&lt;1||position&gt;table1-&gt;length)//判断位置是否有误
        {
            printf(&quot;位置有误！\n&quot;);
        }
        else
        {
            table1-&gt;data[position-1] = new_elem;//修改元素
        }
    }
    else//如果是空表
    {
        printf(&quot;空表，你改什么？\n&quot;);
    }
}

//查找元素第一次出现的位置
int find_position(table* table1,int elem)
{
    if(!isEmpty(table1))//检查是否为空
    {
        int  position= -1;//位置信息，默认为-1
        bool flag = false; //是否查到的标志
        for(int i=0;i&lt;table1-&gt;length;i++)
        {
            if(elem==table1-&gt;data[i])
            {
                position = i+1;//记录位置
                flag = true;//开关打开
            }
        }
        if(flag)//如果找到了
        {
            return position;//返回位置
        }
        else
        {
            return -1;//否则返回-1；
        }
    }
    else
    {
        return -1;//空表也返回-1
    }
}

//查找某个位置的元素
int find_value(table* table1,int position)
{
    if(!isEmpty(table1))//检查是否为空
    {
        if(position&lt;1||position&gt;table1-&gt;length)//检查位置,若有问题
        {
            printf(&quot;位置有误\n&quot;);
            abort();//终止程序
        }
        else//若位置正确
        {
            return table1-&gt;data[position-1];//返回该位置的元素
        }
    }
    else
    {
        printf(&quot;空表\n&quot;);
        abort();//终止程序
    }
}

//遍历打印出表中的所有数据
void displayTable(table *table1)
{
    if(!isEmpty(table1))//首先判断表是否为空
    {
        printf(&quot;该表的全部数据为：\n&quot;);
        for(int i=0;i&lt;table1-&gt;length;i++)//不为空则循环遍历
        {
            printf(&quot;%d &quot;,table1-&gt;data[i]);//打印数值
        }
        printf(&quot;\n&quot;);
    }
    else//若表为空
    {
        printf(&quot;表中无数据！\n&quot;);
    }
}

//删除表
void deleteTable(table *table1)
{
    table1-&gt;length=0;
    table1-&gt;capacity=0;
    free(table1-&gt;data);
    free(table1);
    //释放空间
}
#endif //C_TABLE_H
</code></pre>
<p>###顺序表-C++版本</p>
<pre><code class="language-C++">//@顺序表 CPP版本
// Created by abel on 2019/10/11.
//

#ifndef C___TABLE_H
#define C___TABLE_H

#include &lt;iostream&gt;
using namespace std;

const int CAPACITY = 10;//定义初始化最大容量

class Table//定义顺序表类
{
private:
    int *data;//简单int数据类型数组
    int capacity;//最大容量
    int length;//当前长度
public:
    Table()//构造函数
    {
        capacity = CAPACITY;//最大容量
        data = new int[capacity];//动态开辟空间
        length=0;//默认长度
        for (int i = 0; i &lt;3 ; i++)//初始化3个数据做测试
        {
            data[i]=i+1;
        }
        length=3;//当前长度为3
    }
    bool isEmpty();//判断是否为空
    bool isFull();//判断是否为满
    void enlarge();//扩容
    void push_back(int position,int elem);//插入数据
    int pop_back(int position);//弹出数据
    void change(int position,int new_elem);//修改元素
    int find_position(int elem);//查找元素第一次出现的位置
    int find_value(int position);//得到某个位置的元素
    void display();//打印所有数据
    void deleteTable();//删除表
};

//判断是否为空
bool Table::isEmpty() {
    return length==0;
}

//判断是否为满
bool Table::isFull() {
    return length==capacity;
}

//扩容
void Table::enlarge() {
    capacity *= 2;//将最大容量翻倍
    int *new_data = new int[length];//开辟一个临时中转的数组
    for(int i=0;i&lt;length;i++)//将原来的数组拷贝到中转数组中
    {
        new_data[i]=data[i];
    }
    data = new int[capacity*2];//给data扩容
    for(int i=0;i&lt;length;i++)//再将中转数组的数据还给data
    {
        data[i]=new_data[i];
    }
    delete [] new_data;//删除中转数组
    //以上实际实现了的无非是C语言的realloc()功能
}

//插入数据
void Table::push_back(int position, int elem) {
    if(!isFull())//检查是否满表
    {
        if(position&lt;1||position&gt;length)//检查位置是否有误
        {
            cout&lt;&lt;&quot;插入位置有误&quot;&lt;&lt;endl;
        }
        else
        {
            for(int i=length;i&gt;=position-1;i--)//遍历将插入位置的元素后移
            {
                data[i] = data[i-1];
            }
            data[position-1]=elem;//新增元素
            length++;//加大空间
            cout&lt;&lt;&quot;元素&quot;&lt;&lt;elem&lt;&lt;&quot;插入成功&quot;&lt;&lt;endl;
        }
    }
    else//表满了
    {
        cout&lt;&lt;&quot;扩容中...&quot;&lt;&lt;endl;
        enlarge();//扩容

        if(position&lt;1||position&gt;length)//检查位置是否有误
        {
            cout&lt;&lt;&quot;插入位置有误&quot;&lt;&lt;endl;
        }
        else
        {
            for(int i=length;i&gt;=position-1;i--)//遍历将插入位置的元素后移
            {
                data[i] = data[i-1];
            }
            data[position-1]=elem;//新增元素
            length++;//加大空间
            cout&lt;&lt;&quot;元素&quot;&lt;&lt;elem&lt;&lt;&quot;插入成功&quot;&lt;&lt;endl;
        }
    }
}

//弹出数据
int Table::pop_back(int position) {
    if(!isEmpty())//检查是否为空
    {
        if(position&lt;1||position&gt;length)//检查位置
        {
            cout&lt;&lt;&quot;删除位置有误\n&quot;;
        }
        else
        {
            int temp = data[position-1];//记录将要删除的元素
            for(int i=position-1;i&lt;length;i++)//将该元素后面的全部前移
            {
                data[i]=data[i+1];
            }
            length--;//减少一个当前长度
            return temp;//将删除的元素返回
        }
    }
    else{
        cout&lt;&lt;&quot;空表，无值&quot;;
        return -1;
    }
}

//修改元素
void Table::change(int position, int new_elem) {
    if(!isEmpty())//判断非空
    {
        if(position&lt;1||position&gt;length)//检查位置
        {
            cout&lt;&lt;&quot;输入的位置有误&quot;&lt;&lt;endl;
        }
        else
        {
            data[position-1]=new_elem;
            cout&lt;&lt;&quot;修改成功\n&quot;;
        }
    }
    else
    {
        cout&lt;&lt;&quot;空表，你改什么？\n&quot;;
    }
}

//查找元素第一次出现的位置
int Table::find_position(int elem) {
    if(!isEmpty())//判断非空
    {
        int position = -1;//默认位置为-1
        bool flag = false;//标志
        for(int i=0;i&lt;length;i++)//遍历查找
        {
            if(data[i]==elem)//如果找到了
            {
                flag = true;//标志设为真
                position = i+1;//记录当前位置
                break;//跳出循环
            }
        }
        if(flag)//如果标志为真，即找到了
        {
            return position;//则返回第一次出现的位置
        }
        else
        {
            return -1;//否则返回-1（因为位置没有-1，故表示没找到）
        }
    }
    else
    {
        cout&lt;&lt;&quot;空表，你找什么？&quot;&lt;&lt;endl;
        return -1;
    }
}

//得到某个位置的元素
int Table::find_value(int position) {
    if(!isEmpty())//判断非空
    {
        if(position&lt;1||position&gt;length)//检查位置
        {
            cout&lt;&lt;&quot;位置错误&quot;;
            abort();//终止程序
        }
        else//如果位置正确
        {
            return data[position-1];//返回该数值
        }
    }
    else
    {
        cout&lt;&lt;&quot;空表！&quot;&lt;&lt;endl;
        abort();//终止程序
    }
}

//删除表
void Table::deleteTable() {
    capacity=0;
    length=0;
    delete[] data;
}

//打印所有数据
void Table::display() {
    if(!isEmpty())//检查是否为空
    {
        for(int i=0;i&lt;length;i++)//循环遍历打印数据
        {
            cout&lt;&lt;data[i]&lt;&lt;&quot; &quot;;
        }
        cout&lt;&lt;endl;
    }
    else
    {
        cout&lt;&lt;&quot;啥都没得，不要display了&quot;&lt;&lt;endl;
    }
}

#endif //C___TABLE_H
</code></pre>
<p>###顺序表-Java版本</p>
<ul>
<li>我刚学两天不要怼我，且注释没有上面的详细。由于很多方法都一样，所以java的版本没有写那么详细</li>
</ul>
<pre><code class="language-Java">//@顺序表 Java版本
// Created by abel on 2019/10/11.
//
public class Table {
	final int CAPACITY = 10;//最大容量
	
	private int []data;//定义数组
	private int capacity;//最大容量
	private int length;//当前长度
	
	public Table()//构造函数
	{
		this.capacity = CAPACITY;
		this.data = new int[capacity];
		this.length = 0;
		for(int i=0;i&lt;3;i++)
		{
			data[i] = (int)(Math.random()*100);//初始进入3个随机数
		}
		length =3;
	}
	//判断是否为空
	boolean isEmpty()
	{
		return (length==0);
	}
	//判断是否为满
	boolean isFull()
	{
		return (length == capacity);
	}
	//插入元素
	void push_back(int position,int elem)
	{
		if(!isFull())
		{
			if(position&lt;1||position&gt;length)
			{
				System.out.println(&quot;位置错误&quot;);
			}
			else {
				for(int i=length;i&gt;position-1;i--)
				{
					data[i]=data[i-1];
				}
				data[position-1]=elem;
				length++;
				System.out.println(&quot;插入成功&quot;);
			}
		}
		else {
			System.out.println(&quot;表满了！&quot;);
		}
	}
	//弹出元素
	int pop_back(int position)
	{
		if(!isEmpty())
		{
			if(position&lt;1||position&gt;length)
			{
				System.out.println(&quot;位置有误&quot;);
				return -1;
			}
			else {
				int temp = data[position-1];
				for(int i=position-1;i&lt;length;i++)
				{
					data[i]=data[i+1];
				}
				length--;
				return temp;
			}
		}
		else {
			System.out.println(&quot;空表&quot;);
			return -1;
		}
	}
    //查找元素第一次出现的位置
	int find_position(int elem)
	{
		if(!isEmpty())
		{
			for(int i=0;i&lt;length;i++)
			{
				if(elem==data[i])
				{
					return (i+1);
				}
			}
			System.out.println(&quot;无该️元素&quot;);
			return -1;
		}
		else {
			System.out.println(&quot;空表&quot;);
			return -1;
		}
	}
	//显示所有元素
	void display()
	{
		if(!isEmpty())//检查是否为空
		{
			for(int i=0;i&lt;length;i++)
			{
				System.out.print(data[i]+&quot; &quot;);
			}
			System.out.println();
		}
		else {
			System.out.println(&quot;空表&quot;);
		}
	}
	//置空表
	void replace()
	{
		for(int i=0;i&lt;length;i++)
		{
			data[i]=0;
		}
		length=0;
	}
}
</code></pre>
<p>**以下是C#的语言写的，其实它和Java感觉都大同小异，当然，毕竟我是小白所以还没有比较大的差异化感觉</p>
<pre><code class="language-c#">//@顺序表 C#版本
// Created by abel on 2019/10/11.
//
    class Table//顺序表
{
    const int SIZE = 10;//初始最大容量
    private int capacity;//最大容量
    private int size;//当前大小
    private int[] data;//表空间

    public Table()//构造函数，创建表
    {
        capacity = SIZE;
        size = 3;
        data = new int[capacity];
        for(int i=0;i&lt;3;i++)
        {
            data[i] = i + 1;
        }
    }

    public bool isEmpty()//判断空
    {
        return (size == 0);
    }

    public bool isFull()//判断满
    {
        return (size == capacity);
    }


    public void enlarge()
    {
        int[] temp = new int[10];
        for(int i=0;i&lt;size;i++)
        {
            temp[i] = data[i];
        }

        capacity = capacity * 2;
        data = new int[capacity];
        for (int i = 0; i &lt; size; i++)
        {
            data[i] = temp[i];
        }

    }

    public void push_back(int position,int elem)//插入元素
    {
        if(!isFull())//判断满
        {
            if(position&lt;1||position&gt;size)//判断位置
            {
                Console.WriteLine(&quot;Wrong Position!&quot;);
            }
            else
            {
                for(int i=size;i&gt;=position-1;i--)//依次后移
                {
                    data[i] = data[i - 1];
                }
                data[position-1]=elem;
                size++;
            }
        }
        else
        {
            Console.WriteLine(&quot;Enlarge the Data...&quot;);
            enlarge();//扩容
            if (position &lt; 1 || position &gt; size)//判断位置
            {
                Console.WriteLine(&quot;Wrong Position!&quot;);
            }
            else
            {
                for (int i = size; i &gt;= position - 1; i--)//依次后移
                {
                    data[i] = data[i - 1];
                }
                data[position - 1] = elem;
                size++;
            }
        }
    }

    public int find_elem(int elem)//查找元素
    {
        if(!isEmpty())
        {
            for(int i=0;i&lt;size;i++)
            {
                if (elem == data[i])
                    return i + 1;
                return -1;
            }
        }
        Console.WriteLine(&quot;Empty Table&quot;);
        return -1;
    }

    public int pop_back(int position)
    {
        if (!isEmpty())
        {
            if (position &lt; 1 || position &gt; size)
            {
                return -1;
            }
            else
            {
                int temp = data[position - 1];
                for (int i = position - 1; i &lt; size-1; i++)
                {
                    data[i] = data[i + 1];
                }
                size--;
                return temp;
            }
        }
        else
        {
            Console.WriteLine(&quot;Empty!&quot;);
            return -1;
        }
    }

    public void display()//显示所有元素
    {
        for(int i =0;i&lt;size;i++)
        {
            Console.Write(&quot;{0} &quot;, data[i]);
        }
        Console.WriteLine();
    }
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Decir algo]]></title>
        <id>https://abelcorn.cn/post/unexpectedtrip</id>
        <link href="https://abelcorn.cn/post/unexpectedtrip">
        </link>
        <updated>2019-10-06T13:00:00.000Z</updated>
        <summary type="html"><![CDATA[<ul>
<li>任由海风吹拂，心里却未曾感激过这无聊的咸涩。想来孤独的历程已逾8月，却丝毫没有忘却昔日的愉悦和懊恼。</li>
</ul>
]]></summary>
        <content type="html"><![CDATA[<ul>
<li>任由海风吹拂，心里却未曾感激过这无聊的咸涩。想来孤独的历程已逾8月，却丝毫没有忘却昔日的愉悦和懊恼。</li>
</ul>
<!-- more -->
<ul>
<li>对啊，当初为何莫名其妙，就同本不可能在一起的人许下长久的愿景。理智同自己讲说变数太多，何苦故增烦恼，但仍推着自己往坎坷的路上前进。或许不是谁前谁后吧，但是一开始就在岔路上，走的越久，人影亦愈发的朦胧。</li>
<li>她点播人的技巧多曼妙，就是那一点点火苗引燃自己对未来一切的畅想。彷徨于现实中的慨叹，总会在夜深时想着如何勾勒出那生活的美好。可是燃起来的不只是自己，谁又想到连着这画本身也开始燃烧，把自己殷切的期盼讲给画听，止不住那烛光，反却救焚益薪。</li>
<li>于是她丝毫未有回首的想法，迈着步子走开，你看迷雾本来就遮掩着世间，这下该是什么也看不着了。</li>
<li>所以想呀，要是人类没有感情多好，事物皆逻辑，人们是不是不会再被伤心的事阻碍？于是闭着眼睛向前走，要是眼里皆尽是黑暗，何惧你终会来的黑暗。可是我总是怀念那被暖意包围，被阳光普照的世界，常常在安静的时候，在四下无人的时候，偷偷的睁开眼睛。只恨这一时半会儿没有适应，竟然会略觉刺眼。</li>
<li>你说当大家明晃晃的盯着我，要是我也睁眼回看着她，会被众人耻笑吗？</li>
<li></li>
<li>也别轻易的回答，毕竟海风还没停歇，那些海鸥们也在吵闹。</li>
<li>奇怪啊，为何阴沉的天空与迷离的大海如此的沉重，却在那轮红日的映衬下显得如此完美。为何我总想着那天的和风与暖日，却不愿品味每一个季节。他们都是亲切的，只是不知道用哪种方式接近我，不至于只贪恋往日，每个让我感到心安的日子，都是那么美好。</li>
<li>我想，心里也应该感激，纵使这海风并不温柔。</li>
</ul>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Matlab学习笔记（三）]]></title>
        <id>https://abelcorn.cn/post/matlab-3</id>
        <link href="https://abelcorn.cn/post/matlab-3">
        </link>
        <updated>2019-09-22T11:27:48.000Z</updated>
        <summary type="html"><![CDATA[<p><em><strong>矩阵</strong></em></p>
]]></summary>
        <content type="html"><![CDATA[<p><em><strong>矩阵</strong></em></p>
<!--more-->
<h3 id="矩阵">矩阵</h3>
<p><strong>矩阵定义</strong>：</p>
<ul>
<li>如3x3的矩阵<code>A=[1 2 3;4 5 6; 7 8 9]</code></li>
<li>3维矩阵：<code>[[1 2 3];[2 4 6];[7 8 9]]</code></li>
<li>复数矩阵：<code>[[1 1+i 2];[2 3+2i 1]]</code></li>
<li>矩阵生成：</li>
<li>
<ul>
<li>利用M文件写入</li>
<li>利用文本创建：</li>
<li>建立<code>goods.txt</code>，里面写入相关矩阵信息，接着<code>load goods.txt</code></li>
</ul>
</li>
<li>创建特殊矩阵：</li>
<li>
<ul>
<li><code>eye(n)</code>：创建nxn的单位矩阵</li>
<li><code>eye(m,n)</code>：创建mxn的单位矩阵</li>
<li><code>eye(size(A))</code>：创建与A同维的单位矩阵</li>
<li><code>ones(n)</code>：创建nxn的全1矩阵</li>
<li><code>ones(m,n)</code>、 <code>ones(size(A))</code></li>
<li><code>zeros(n)</code>、 <code>zeros(m,n)</code>、 <code>zeros(size(A))</code></li>
<li><code>rand(n)</code>：在<code>[0,1]</code>区间内创建一个nxn的均匀随机矩阵</li>
<li><code>rand(m,n)</code>、<code>rand(size(A))</code></li>
<li><code>compan(P)</code>：创建系数向量是P的多项式伴随矩阵</li>
<li><code>diag(v)</code>：创建一向量v中的元素为对角的对角矩阵</li>
<li><code>hilb(n)</code>：创建nxn的Hilbert矩阵</li>
<li><code>magic(n)</code>：生成n阶魔方矩阵</li>
<li><code>sparse(A)</code>：将A转化为稀疏矩阵，即由A的非0元素和下标构成的稀疏矩阵S。若A本身为稀疏矩阵，则返回A本身(即仍然为稀疏矩阵A)</li>
</ul>
</li>
</ul>
<p><strong>矩阵元素的运算</strong>：</p>
<ol>
<li>元素修改：
<ul>
<li><code>D=[A;B C]</code>：A为原矩阵，B、C中包含要扩充的元素，D为扩充后的矩阵</li>
<li><code>A(m,:)=[]</code>：删除A的第m行</li>
<li><code>A(:,n)=[]</code>：删除A的第n列</li>
<li><code>A(m,n) =a</code>：对A的第m行n列元素赋值</li>
<li><code>A(m,:)=[a,b,c....]</code>：对A的第m行赋值</li>
<li><code>A(:,n)=[a,b,c,...]</code></li>
</ul>
</li>
<li>维度修改:</li>
</ol>
<ul>
<li>矩阵的变维可以用符号“：”和reshape函数变换
<ul>
<li><code>A=1:12</code> <code>B=reshape(A,2,6)</code></li>
<li>用冒号法时，要注意需先设定修改后的矩阵形状</li>
<li><code>C=zeros(3,4);</code> <code>C(:)=A(:)</code></li>
</ul>
</li>
</ul>
<ol start="3">
<li>矩阵的变向：
<ul>
<li><code>Rot(90)</code>：将A逆时针旋转90度</li>
<li><code>Rot(90,k)</code>：将A旋转<code>k*90</code>度，其中k为正负整数</li>
<li><code>Fliplr(X)</code>:将X左右翻转</li>
<li><code>flipud(X)</code>：将X上下翻转</li>
<li><code>flipdim(X,dim)</code>：dim=1时对行翻转，dim=2时对列翻转</li>
</ul>
</li>
<li>矩阵的抽取:</li>
</ol>
<ul>
<li>主要指对角线元素和上下三角矩阵的抽取
<ul>
<li><code>diag(X,k)</code>：抽取矩阵的第k条对角线上的元素向量。k=0表示主对角线，k为正整数时抽取上方第k条。。。。。。。</li>
<li><code>diag(X)</code>：抽取主对角线</li>
<li><code>diag(v,k)</code>：使得v为所得矩阵第k条对角线上的元素向量</li>
<li><code>diag(v)</code>：使得v为所得矩阵主对角线上的元素向量</li>
<li><code>tril(X)</code>：提取矩阵X的主下三角部分</li>
<li><code>tril(X,k)</code>：提取第k条对角线下面的部分（包括第k条）</li>
<li><code>triu(X)</code>：提取上三角</li>
<li><code>triu(X,k)</code>：........上三角（包括第k条）</li>
</ul>
</li>
</ul>
<h3 id="矩阵的数学运算">矩阵的数学运算</h3>
<ul>
<li>待续</li>
</ul>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Matlab学习笔记（二）]]></title>
        <id>https://abelcorn.cn/post/matlab-2</id>
        <link href="https://abelcorn.cn/post/matlab-2">
        </link>
        <updated>2019-09-20T13:22:05.000Z</updated>
        <summary type="html"><![CDATA[<p>本节内容将说明一般的向量运算，为后面的矩阵运算做好基础。向量大部分为中学知识，不再说明计算方法与用处。</p>
]]></summary>
        <content type="html"><![CDATA[<p>本节内容将说明一般的向量运算，为后面的矩阵运算做好基础。向量大部分为中学知识，不再说明计算方法与用处。</p>
<!--more-->
<p><em><strong>向量与多项式</strong></em></p>
<h3 id="向量">向量</h3>
<p><strong>向量的生成</strong>：</p>
<ol>
<li>直接输入：行向量：<code>x=[1,2,3]</code>，列向量：<code>x=[1;2;3]</code></li>
<li>冒号输入：<code>x=0:2:10</code>，表示从0一直到10，步长为2，隔一个输出，即结果是<code>x=[0,2,4,6,8,10]</code> 如果<code>x=0:10</code>，则默认步长为1</li>
<li>linspace函数法：<code>linspace(first_value,last_value,number)</code>，从第一到最后的数据范围，其中包括number个数</li>
<li>logspace函数法：<code>logspace(first_value,last_value,number)</code>,输出number个，从10<sup>first_value到10</sup>last_value，如：<code>logspace(1,3,3)</code>可得10 100 1000</li>
</ol>
<p><strong>向量元素的引用</strong>：</p>
<ul>
<li>如<code>x=[1,2,3,4,5]</code>，则<code>x(1:3)</code>表示抽出第一到第三个元素，即1 2 3</li>
</ul>
<p><strong>向量运算</strong>：</p>
<ul>
<li>
<p>定义向量</p>
</li>
<li>
<p>加法+</p>
</li>
<li>
<p>减法-</p>
</li>
<li>
<p>乘法*</p>
</li>
<li>
<p>除法/</p>
</li>
<li>
<p>混合运算 （以上均中学知识不再赘述）</p>
</li>
<li>
<p>点积：点积可用<code>.*</code>或者<code>dot(a,b)</code>,<code>dot(a,b,dim)</code>，其中，a和b必须同维，dim是a和b在dim维度的点积</p>
</li>
<li>
<p>叉积：<code>cross(a,b)</code>,<code>cross(a,b,dim)</code></p>
</li>
<li>
<p>卷积：我们称</p>
<p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>(</mo><mi>f</mi><mo>∗</mo><mi>g</mi><mo>)</mo><mo>(</mo><mi>n</mi><mo>)</mo><mi mathvariant="normal">为</mi><mi>f</mi><mo separator="true">,</mo><mi>g</mi><mi mathvariant="normal">的</mi><mi mathvariant="normal">卷</mi><mi mathvariant="normal">积</mi><mi mathvariant="normal">。</mi><mi mathvariant="normal">其</mi><mi mathvariant="normal">计</mi><mi mathvariant="normal">算</mi><mi mathvariant="normal">方</mi><mi mathvariant="normal">式</mi><mi mathvariant="normal">为</mi><mi mathvariant="normal">：</mi><msubsup><mo>∫</mo><mrow><mo>−</mo><mi mathvariant="normal">∞</mi></mrow><mrow><mo>+</mo><mi mathvariant="normal">∞</mi></mrow></msubsup><mi>f</mi><mo>(</mo><mi>τ</mi><mo>)</mo><mi>g</mi><mo>(</mo><mi>n</mi><mo>)</mo><mi>d</mi><mi>τ</mi></mrow><annotation encoding="application/x-tex">(f*g)(n)为f,g的卷积。 其计算方式为： \int_{-\infty}^{+\infty}f(\tau)g(n)d\tau
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:2.491512em;vertical-align:-0.970281em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="mclose">)</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mclose">)</span><span class="mord cjk_fallback">为</span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="mord cjk_fallback">的</span><span class="mord cjk_fallback">卷</span><span class="mord cjk_fallback">积</span><span class="mord cjk_fallback">。</span><span class="mord cjk_fallback">其</span><span class="mord cjk_fallback">计</span><span class="mord cjk_fallback">算</span><span class="mord cjk_fallback">方</span><span class="mord cjk_fallback">式</span><span class="mord cjk_fallback">为</span><span class="mord cjk_fallback">：</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mop"><span class="mop op-symbol large-op" style="margin-right:0.44445em;position:relative;top:-0.0011249999999999316em;">∫</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.5212310000000002em;"><span style="top:-1.7880500000000001em;margin-left:-0.44445em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">−</span><span class="mord mtight">∞</span></span></span></span><span style="top:-3.8129000000000004em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">+</span><span class="mord mtight">∞</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.970281em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.1132em;">τ</span><span class="mclose">)</span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mclose">)</span><span class="mord mathdefault">d</span><span class="mord mathdefault" style="margin-right:0.1132em;">τ</span></span></span></span></span></p>
</li>
<li>
<p>去卷积</p>
</li>
</ul>
<h3 id="多项式">多项式</h3>
<p><strong>多项式的创建</strong>：</p>
<ul>
<li>多项式创建时只需要写出系数，没有的项必须用0代替</li>
<li>如：<code>p=[3,2,1]</code>，之后输入<code>poly2sym(p)</code>，就得到了：<code>3*x^3+2*x^2+x</code></li>
</ul>
<p><strong>多项式的四则运算</strong>：</p>
<ul>
<li>
<p>卷积：我们称$$(f*g)(n)为f,g的卷积。 其计算方式为： \int_{-\infty}^{+\infty}f(\tau)g(n)d\tau$$</p>
</li>
<li>
<p>计算方式为<code>conv(p1,p2)</code></p>
</li>
<li>
<p>去卷积：<code>[k,r]=deconv(p,q)</code>等价于<code>p=conv(q,k)+r</code></p>
</li>
<li>
<p>k返回的是多项式p除以q的商，r是余式</p>
</li>
<li>
<p>根构造：通过写出多项式的解，让系统自己构造一个符合根的多项式</p>
</li>
<li>
<p>如：<code>root=[-5,3+2i,3-2i]</code> 则，<code>p=poly(root)</code>就构造了对应的系数表，接着<code>poly2sym(p)</code>可以生成多项式</p>
</li>
</ul>
<p><strong>多项式的导数运算</strong>：</p>
<ul>
<li>通过<code>polyder(p)</code>就可以得到求导后的系数表，接着<code>poly2sym()</code>可生成求导后的多项式</li>
<li>更高阶的导数类似反复调用就行</li>
</ul>
<h3 id="特殊变量">特殊变量</h3>
<p><strong>单元型变量</strong>：</p>
<ul>
<li>
<p>创建：</p>
</li>
<li>
<ul>
<li>如：<code>A[1,2,3,4];B=3+2i;C='hhh'</code>，则生成方式为<code>E={A,B,C}</code></li>
<li><code>cell(n)</code>：生成n*n阶的空单元数组</li>
<li><code>cell(m,n)</code></li>
<li><code>cell(m,n,p,....)</code></li>
<li><code>cell(size(A))</code>：生成与A同形式的单元型空矩阵</li>
<li><code>E=cell(1,3)</code></li>
<li><code>E{1,1}=[1:4]</code></li>
<li><code>E{1,2}=B</code></li>
</ul>
</li>
<li>
<p>引用：</p>
</li>
<li>
<ul>
<li><code>E{1}</code></li>
<li><code>E(1)</code></li>
</ul>
</li>
<li>
<p>其他函数：</p>
</li>
<li>
<ul>
<li><code>cellfun</code>：对单元型变量中的元素作用的函数</li>
<li><code>celldisp</code>：显示变量内容</li>
<li><code>cellplot</code>：图形显示</li>
<li><code>num2cell</code>：将数值转换成单元型变量</li>
<li><code>deal</code>：输入输出</li>
<li><code>cell2struct</code>：单元型变成结构型</li>
<li><code>struct2cell</code>：将结构型变成单元型</li>
<li><code>iscell</code>：判断是否为单元型</li>
<li><code>reshape</code>：改变单元数组的结构</li>
</ul>
</li>
</ul>
<p><strong>结构型变量</strong>：</p>
<ul>
<li>
<p>创建：</p>
</li>
<li>
<ul>
<li><code>struct('field',value1,'filed2',value2,.....)</code>：表示建立一个具有属性名及对应数据的结构型数组</li>
<li>如：<code>p=struct('color',{'red','green'},'num',{1,2,3})</code></li>
</ul>
</li>
<li>
<p>引用：</p>
</li>
<li>
<ul>
<li><code>p</code>、<code>p(1)</code> 、<code>p(1).color</code></li>
</ul>
</li>
<li>
<p>函数：</p>
</li>
<li>
<ul>
<li><code>struct</code>：创建结构型变量</li>
<li><code>fieldnames</code>：得到结构型变量的属性名</li>
<li><code>getfield</code>：得到属性值</li>
<li><code>setfield</code>：设定属性值</li>
<li><code>rmfield</code>：删除属性</li>
<li><code>isfield</code>：判断是否为结构型的属性</li>
<li><code>isstruct</code>：判断是否为结构型变量</li>
</ul>
</li>
</ul>
<p><em><strong>接着会更新矩阵运算的相关内容</strong></em></p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Matlab学习笔记（一）]]></title>
        <id>https://abelcorn.cn/post/matlab-1</id>
        <link href="https://abelcorn.cn/post/matlab-1">
        </link>
        <updated>2019-09-18T15:18:08.000Z</updated>
        <summary type="html"><![CDATA[<p><em><strong>基础知识</strong></em><br>
C++考试终于结束了，可以开始matlab的学习了，本部分内容仅为自己做笔记用，不属于对外教程。</p>
]]></summary>
        <content type="html"><![CDATA[<p><em><strong>基础知识</strong></em><br>
C++考试终于结束了，可以开始matlab的学习了，本部分内容仅为自己做笔记用，不属于对外教程。</p>
<!--more-->
<h3 id="常用指令">常用指令</h3>
<ul>
<li><code>cd</code>：显示或改变工作目录</li>
<li><code>clc</code>：清除命令行窗口</li>
<li><code>clf</code>：清除图形窗口</li>
<li><code>hold</code>：保持图形窗口</li>
<li><code>diary</code>：生成日志文件</li>
<li><code>load</code>：加载指定文件的变量</li>
<li><code>dir</code>：显示当前目录下的文件</li>
<li><code>pack</code>：整理内存碎片</li>
<li><code>disp</code>：显示变量或文字内容</li>
<li><code>path</code>：显示搜索目录</li>
<li><code>echo</code>：命令行窗口信息显示开关</li>
<li><code>quit</code>：退出 Matlab</li>
<li><code>save</code>：保存内存变量指定文件</li>
<li><code>type</code>：显示文件内容</li>
</ul>
<h3 id="变量与常量">变量与常量</h3>
<p><strong>变量：</strong></p>
<ul>
<li>变量名必须以字母开头，之后可以是任意的字母、数字或下划线</li>
<li>大小写敏感</li>
<li>不超过31个字符，第31个及之后的会被忽略</li>
<li>未加说明的前提下，一切变量视为局部变量，可用global声明为全局</li>
</ul>
<p><strong>常量</strong>：</p>
<ul>
<li><code>ans</code>：默认变量，一般用在显示答案</li>
<li><code>pi</code>：圆周率</li>
<li><code>eps</code>：浮点运算相对精度</li>
<li><code>inf</code>：无穷大 如1/0</li>
<li><code>NaN</code>：不定值，如0/0</li>
<li><code>i j</code>：虚数单位</li>
<li><code>realmin</code>：最小正浮点数</li>
<li><code>realmax</code>：最大正浮点数</li>
</ul>
<h3 id="数值">数值</h3>
<p><strong>整型</strong>：</p>
<ul>
<li><code>char</code>:字符型，占用1字节</li>
<li><code>short</code>:短整型，占用2字节</li>
<li><code>int</code>:整型，4字节</li>
<li><code>long</code>:长整型，8字节</li>
<li>以上均有对应的无符号类型:<code>unsigned xxx</code></li>
</ul>
<p><strong>浮点型</strong>：</p>
<ul>
<li>十进制类型，如：1.2 4.44</li>
<li>指数形式，如: 2.1E5  3.7e-2</li>
<li>指数标志e前必须有数字，后面必须有阶码</li>
<li><code>float</code>：单精度，4字节</li>
<li><code>double</code>：双精度，8字节</li>
</ul>
<p><strong>复数类型</strong>：</p>
<ul>
<li>实部：Rez=a</li>
<li>虚部：Imz=b</li>
<li>当虚部为0，可视为实数；当实部为0而虚部不为0，叫做纯虚数</li>
<li>加法法则：<code>(a+bi)+(c+di) = (a+c)+(b+d)i</code></li>
<li>减法法则：<code>(a+bi)-(c+di) = (a-c)+(b-c)i</code></li>
<li>乘法法则：<code>(a+bi)*(c+di) = (ac-bd)+(bc+ad)i</code></li>
<li>除法法则：<code>(a+bi)/(c+di) = [(ac+bd)/(c^2+d^2)]+[(bc-ad)/(c^2+d^2)]i</code></li>
</ul>
<p><strong>数字显示格式</strong>：</p>
<ul>
<li>
<p><code>format short</code>：5位定点表示（默认）</p>
</li>
<li>
<p><code>format long</code>：15位定点表示</p>
</li>
<li>
<p><code>format short e</code>：5位浮点表示</p>
</li>
<li>
<p><code>format short g</code>：自动选择定点还是浮点表示</p>
</li>
<li>
<p><code>format hex</code>：十六进制显示</p>
</li>
<li>
<p><code>format +</code>：在矩阵中，用+、-和空格表示正、负和零</p>
</li>
<li>
<p><code>format bank</code>：用美元和美分定点表示</p>
</li>
<li>
<p><code>format rat</code>：以有理数形式输出结果</p>
</li>
<li>
<p><code>format compact</code>：变量间无空格</p>
</li>
<li>
<p><code>format loose</code>：变量间有空行</p>
</li>
<li>
<p>以上输出方式:</p>
<pre><code class="language-matlab">format long,pi
</code></pre>
</li>
</ul>
<h3 id="运算符">运算符</h3>
<p>除简单的四则运算外，还有点乘<code>.*</code>，等，后期运算会遇到</p>
<p><strong>关系运算符</strong>：</p>
<ul>
<li><code>==</code>：等于</li>
<li><code>~=</code>：不等于</li>
<li><code>&gt;``&gt;=``&lt;``&lt;=</code>：比较</li>
<li>以上返回值为0或1</li>
</ul>
<p><strong>逻辑运算法</strong>：</p>
<ul>
<li><code>-</code>：逻辑与</li>
<li><code>|</code>：逻辑或</li>
<li><code>~</code>：逻辑非</li>
<li><code>xor</code>：逻辑异或</li>
<li><code>any</code>：有非零元素则为真</li>
<li><code>all</code>：所有元素均非零才为真</li>
</ul>
<h3 id="函数运算">函数运算</h3>
<p><strong>复数运算</strong>：</p>
<ul>
<li><code>abs</code>:模</li>
<li><code>angle</code>：复数相角</li>
<li><code>complex</code>：用实部和虚部构造一个复数</li>
<li><code>conj</code>：复数的共轭</li>
<li><code>imag</code>：虚部</li>
<li><code>real</code>：实部</li>
<li><code>unwrap</code>：调整矩阵元素的相位</li>
<li><code>isreal</code>：判断是否为实数矩阵</li>
<li><code>cplxpair</code>：把复数矩阵排列成复共轭对</li>
</ul>
<p><strong>三角函数运算</strong>：</p>
<ul>
<li><code>sin()</code>：</li>
<li><code>cos()</code></li>
<li><code>tan()</code></li>
<li><code>cot()</code></li>
<li><code>sec()</code>：正割</li>
<li><code>csc()</code>：余割<br>
<em><strong>后期将更新向量与多项式的内容</strong></em></li>
</ul>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[本学期安排]]></title>
        <id>https://abelcorn.cn/post/plan_zero</id>
        <link href="https://abelcorn.cn/post/plan_zero">
        </link>
        <updated>2019-09-04T04:50:05.000Z</updated>
        <summary type="html"><![CDATA[<p>本学期将学习内容将严格按照以下事项进行安排，日后的日程等安排也必须以下列课程优先。</p>
]]></summary>
        <content type="html"><![CDATA[<p>本学期将学习内容将严格按照以下事项进行安排，日后的日程等安排也必须以下列课程优先。</p>
<!--more-->
<h3 id="培养计划内必学课程">培养计划内必学课程</h3>
<ul>
<li>离散数学2</li>
<li>计算理论</li>
<li>剑桥学术英语</li>
<li>数据结构</li>
<li>概率论与数理统计</li>
<li>马克思主义基本原理概论</li>
<li>工程经济学</li>
<li>轮滑</li>
</ul>
<h3 id="mooc自学选修课程">Mooc自学选修课程</h3>
<ul>
<li>软件工程</li>
<li>数据结构与算法</li>
<li>概率论与数理统计</li>
<li>Java</li>
<li>C#</li>
</ul>
<h3 id="复习内容">复习内容</h3>
<ul>
<li>线性代数</li>
<li>微积分</li>
<li>C/C++</li>
</ul>
<h3 id="额外安排">额外安排</h3>
<ul>
<li>练字</li>
<li>英语听力与词汇</li>
<li>STL</li>
<li>QT进阶开发</li>
</ul>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[LaTex表示方法]]></title>
        <id>https://abelcorn.cn/post/latex</id>
        <link href="https://abelcorn.cn/post/latex">
        </link>
        <updated>2019-09-02T10:20:28.000Z</updated>
        <summary type="html"><![CDATA[<h3 id="注意">注意</h3>
<ul>
<li>由于语法较多，这里将官方图搬移至此，感兴趣请配合前面MarkDown语法入门教程使用。</li>
</ul>
]]></summary>
        <content type="html"><![CDATA[<h3 id="注意">注意</h3>
<ul>
<li>由于语法较多，这里将官方图搬移至此，感兴趣请配合前面MarkDown语法入门教程使用。</li>
</ul>
<!--more-->
<h3 id="基本语法">基本语法</h3>
<p><img src="https://abelcorn.cn/post-images/1567938210213.gif" alt=""><br>
<img src="https://abelcorn.cn/post-images/1567938221943.gif" alt=""><br>
<img src="https://abelcorn.cn/post-images/1567938230247.gif" alt=""><br>
<img src="https://abelcorn.cn/post-images/1567938235219.gif" alt=""><br>
<img src="https://abelcorn.cn/post-images/1567938313920.gif" alt=""><br>
<img src="https://abelcorn.cn/post-images/1567938319571.gif" alt=""><br>
<img src="https://abelcorn.cn/post-images/1567938324053.gif" alt=""></p>
<h3 id="常用数学符合">常用数学符合</h3>
<p><img src="https://abelcorn.cn/post-images/1567938431251.gif" alt=""><br>
<img src="https://abelcorn.cn/post-images/1567938438640.gif" alt=""><br>
<img src="https://abelcorn.cn/post-images/1567938443215.gif" alt=""><br>
<img src="https://abelcorn.cn/post-images/1567938447006.gif" alt=""><br>
<img src="https://abelcorn.cn/post-images/1567938450994.gif" alt=""><br>
<img src="https://abelcorn.cn/post-images/1567938458954.gif" alt=""><br>
<img src="https://abelcorn.cn/post-images/1567938465008.gif" alt=""></p>
]]></content>
    </entry>
</feed>