<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://abelcorn.cn</id>
    <title>小石石石</title>
    <updated>2020-01-23T06:14:39.263Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://abelcorn.cn"/>
    <link rel="self" href="https://abelcorn.cn/atom.xml"/>
    <subtitle>Always do your best.</subtitle>
    <logo>https://abelcorn.cn/images/avatar.png</logo>
    <icon>https://abelcorn.cn/favicon.ico</icon>
    <rights>All rights reserved 2020, 小石石石</rights>
    <entry>
        <title type="html"><![CDATA[武汉新冠状病毒要点分析(订正)]]></title>
        <id>https://abelcorn.cn/post/2019-nCov</id>
        <link href="https://abelcorn.cn/post/2019-nCov">
        </link>
        <updated>2020-01-23T03:07:39.000Z</updated>
        <summary type="html"><![CDATA[<p>本版进行内容调整，将预防内容调到前面，将论文分析内容放在后面。目前病毒传染已经出现多起无武汉旅行感染病例，请各位一定注意预防。<br>
且随着生物医学研究的跟进，相关信息会改变，请各位以此为参考，并时刻关注最新的官方消息，勿信谣传谣！</p>
<h2 id="主要内容">主要内容：</h2>
<p>本文分析信息来源于1月21日由南开大学发表的《武汉2019冠状病毒基因组的生物信息学分析》，通过对该论文的阅读分析，结合近期相关专家、新闻发布会和相关报道，将要点总结如下：</p>
]]></summary>
        <content type="html"><![CDATA[<p>本版进行内容调整，将预防内容调到前面，将论文分析内容放在后面。目前病毒传染已经出现多起无武汉旅行感染病例，请各位一定注意预防。<br>
且随着生物医学研究的跟进，相关信息会改变，请各位以此为参考，并时刻关注最新的官方消息，勿信谣传谣！</p>
<h2 id="主要内容">主要内容：</h2>
<p>本文分析信息来源于1月21日由南开大学发表的《武汉2019冠状病毒基因组的生物信息学分析》，通过对该论文的阅读分析，结合近期相关专家、新闻发布会和相关报道，将要点总结如下：</p>
<!-- more -->
<p><a href="https://3g.dxy.cn/newh5/view/pneumonia?enterid=1579583902&amp;scene=2&amp;clicktime=1579583902&amp;isappinstalled=0&amp;from=singlemessage">点击进入<strong>实时疫情播报:</strong></a></p>
<h1 id="预防部分">预防部分：</h1>
<h3 id="病症">病症：</h3>
<ul>
<li>以发热、乏力和干咳为主；</li>
<li>约半数患者在一周左右出现呼吸困难；</li>
<li>高热较少，38度左右，部分可不发热，约7～10天病情可进展；</li>
<li>严重者快速进展为急性呼吸窘迫综合征、脓毒性休克、难以纠正的代谢性酸中毒和凝血功能障碍；</li>
<li>重症、危重症患者病程中可为中低热，甚至无明显发热；</li>
<li>鼻塞、流涕等上呼吸道症状少见；</li>
<li>多数患者预后良好，少数患者病情危重，可导致死亡。</li>
</ul>
<h3 id="治疗">治疗：</h3>
<p>该病目前尚无有效治疗方法，缺乏针对病原体的有效抗病毒药物，以隔离治疗、对症支持治疗为主。</p>
<ul>
<li>隔离</li>
<li>卧床休息、监测生命体征，充分补充热量，注意水、电解质平衡，维持内环境稳定。</li>
<li>根据病情监测血常规、生化指标、凝血功能、血气分析及肺部影像学检查。</li>
<li>根据氧饱和度变化，给予氧疗措施，包括鼻导管、面罩吸氧，必要时无创或有创机械通气等。</li>
<li>只能对症治疗，没有有效抗病毒的通用药物</li>
</ul>
<h3 id="家庭护理">家庭护理：</h3>
<p>新型冠状病毒感染的肺炎存在家庭聚集现象，有疑似症状则及时至传染科就诊，需要在具备有效隔离条件和防护条件的医院隔离治疗。目前按照甲类传染病管理，轻症患者也需要隔离，不可以在家隔离治疗。</p>
<h3 id="预防">预防：</h3>
<ul>
<li>公共场所注意戴口罩，努力做好个人防护是切实可行的办法，不要去人群聚集处，避免近距离接触任何有感冒或流感样症状的人。</li>
<li>注意手卫生，勤洗手，使用肥皂或清水洗手，或含有酒精成分的手消毒剂；</li>
<li>注意正确的咳嗽礼仪，打喷嚏不要用手去捂，要用肘部或纸巾遮挡；</li>
<li>注意多喝水，多休息，避免熬夜，提高个体免疫能力；</li>
<li>合理饮食，烹饪时彻底煮熟肉类和蛋类，避免在未加防护的情况下接触野生动物和家禽家畜；</li>
<li>注意监测体温，如有发热、乏力、咳嗽等症状及时就诊</li>
</ul>
<h1 id="论文分析部分">论文分析部分：</h1>
<h3 id="研究思想与方法">研究思想与方法：</h3>
<ul>
<li>分子功能与进化分析相结合</li>
<li>通过beta冠状病毒基因组中的一个互补回文序列（Nankai complemented palindrome）与其所在的编码区（Nankai CDS）对新发布的武汉新冠状病毒基因组（GenBank: MN908947）进行分析</li>
</ul>
<h3 id="溯源分析及初步结果">溯源分析及初步结果：</h3>
<ul>
<li>武汉新冠状病毒很大可能源自中华菊头蝠或蛇，但与 SARS 冠状病毒差异巨大</li>
<li>存在大量的可变翻译</li>
</ul>
<h3 id="病毒特点">病毒特点：</h3>
<ul>
<li>变异快</li>
<li>多样性高</li>
<li>跨物种传播</li>
<li>多宿主</li>
<li>宿主适应性强</li>
</ul>
<h3 id="基本简介">基本简介：</h3>
<ul>
<li>冠状病毒属（Coronavirus）的病毒是具有包膜的正链RNA病毒</li>
<li>冠状病毒目前共发现7种，其中4种为一般流行性感冒病毒，具有变异性强但自愈、治愈率很高，因此没有高威胁性。其余三种分别为：非典(SARS-CoV)、中东呼吸综合征(MERS-CoV)和近期发现的尚不能完全明确的武汉新冠状病毒(2019-nCoV)。</li>
<li>由于冠状病毒的基因组很长，且很多序列的作用未知，又是RNA病毒，故其变异能力非常强。</li>
<li>冠状病毒基因组注释中基因命名不统一、且大部分注释的蛋白质序列都来自预测，无实验验证，难以保证正确性<br>
<img src="https://abelcorn.cn/post-images/1579752198230.png" alt="" loading="lazy"></li>
</ul>
<h2 id="论文的研究结论">论文的研究结论：</h2>
<ol>
<li>使用 Nankai CDS 溯源分析的结果支持武汉 2019 冠状病毒源自中华菊头蝠，但与 SARS 冠状病毒差异巨大；</li>
<li>从 beta 冠状病毒可变翻译中获取的信息可应用于其快速检测、基因分型、疫苗开发以及药物设计；</li>
<li>beta 冠状病毒可能通过可变翻译以适应不同宿主；</li>
<li>对 beta 冠状病毒可变翻译的研究将有助于研究该病毒的变异、宿主适应性、感染以及致病机制等问题。</li>
</ol>
<h3 id="其他">其他：</h3>
<ul>
<li>病毒或细菌等原核生物的可变翻译现象很早就已经发现，但是其生物学意义尚未清楚，特别是缺乏基于较大数据的实证研究。我们在前期研究植物病毒 、昆虫病毒、人病毒 、哺乳动物病毒（特别是非洲猪瘟病毒）和布鲁氏菌的过程中，都没有明显观察到可变翻译现象，特别是beta 冠状病毒 Nankai CDS 中这样大量而集中存在的可变翻译（仅仅 13 个病毒即可得到多达 9 种基因分型）极其罕见。此次实证研究结果达到了基于可变翻译的基因分型与进化分析的一致性，是一次较大突破，主要得益于以下几点： 1）分子功能与进化分析相结合的研究思想得以应用； 2）有蝙蝠-果子狸-人这一跨物种传播途径作为方向性指导； 3）无意中发现 Nankai complemented palindrome 和 Nankai CDS； 4）来自多种宿主（蝙蝠、果子狸和人）的病毒数据，特别是阳性样本（如来自 SARS 和武汉肺炎患者）数据的积累。经典理论认为病毒与宿主共用一套翻译系统，然而病毒的蛋白质翻译也有其特殊性，导致本研究从 Nankai CDS 中预测的 17 种蛋白质不能提供准确的序列。蛋白质序列的准确度不影响本研究的所有结论和推论，而且为下一步蛋白质、细胞和动物水平的实验指出方向。</li>
<li>基于可变翻译的基因分型相同的病毒都在进化树上的同一个分支（同种宿主）内预示了 beta 冠<br>
状病毒可能通过可变翻译以适应不同宿主。但是，由于目前能获得的病毒数据仅仅来自少量宿主（蝙蝠、果子狸和人），这一推断的验证还需要积累来自更多种类宿主的病毒的数据。我们推测，病毒通过可变翻译以适应不同宿主作为一种普遍机制，并不限于冠状病毒或原核生物；真核生物中某些基因的可变剪接可能也有相似或相近的生物学功能。</li>
<li>Beta 冠状病毒通过可变翻译产生的多种蛋白质的致病性研究是一个更为重要的课题。当前公开的基因组数据虽然总量很大，但是，实际有效的阳性样本（有实验或临床记录证明其致病性）种类不足和缺乏阴性（临床实验确认的非 SARS 病毒）样本。致病性最明确的武汉 2019 和 SARS 冠状病毒在 Nankai CDS 上各产五个小蛋白和一个大蛋白（见图 1C），并没有显示出蛋白质某个属性（如大小）与致病性的关系。在预测的 17 个蛋白质中，只有 P16（长度为 155 个氨基酸）和 P9（长度为115 个氨基酸）是大蛋白质（见表 1）；P16（来自 SARS 冠状病毒）的致病性已知，而 P9（来自蝙蝠的冠状病毒）未知。因此，来自蝙蝠的其它冠状病毒产生的蛋白（如 P9）未必没有致病性，或许也具有导致武汉 2019 肺炎或 SARS 的能力。本研究预测的 17 种蛋白质大小适中而且差异明显，可以很容易通过蛋白质组或外源表达等技术进一步验证其致病性。</li>
</ul>
<p>最后：<br>
<em><strong>武汉加油！中国加油！</strong></em></p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[La réflexion]]></title>
        <id>https://abelcorn.cn/post/La réflexion</id>
        <link href="https://abelcorn.cn/post/La réflexion">
        </link>
        <updated>2020-01-18T08:54:03.000Z</updated>
        <summary type="html"><![CDATA[<p>虽然已经料到考的会不理想，但是没有想到竟然会如此的惨烈。😭😭😭</p>
]]></summary>
        <content type="html"><![CDATA[<p>虽然已经料到考的会不理想，但是没有想到竟然会如此的惨烈。😭😭😭</p>
<!--more-->
<ul>
<li>承认这学期确实很水，无论是计算理论还是概率论，都没有好好的学习，都是水过去的。可是这数据结构我可是每节课都认真的听啊，还那么积极的回答问题。</li>
<li>作为一个计算机的学生竟然死在数据结构手上，太TM讽刺了。</li>
<li>不过无论什么所谓的理由，都无法改变在这学期的堕落。毕竟如果真的什么都学的到位的话，怎么会在考试周因为收到情绪波动而改变考试成绩？</li>
<li><strong>反思！！！</strong></li>
<li>不过还好，还有最后一学期可以进行冲刺，希望可以实现目标。</li>
<li>加油啊！！！！！！</li>
</ul>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[线性表--顺序表]]></title>
        <id>https://abelcorn.cn/post/DS_1</id>
        <link href="https://abelcorn.cn/post/DS_1">
        </link>
        <updated>2020-01-15T12:04:48.000Z</updated>
        <summary type="html"><![CDATA[<p>期末数据结构考的真🐔不咋的，所以这个寒假准备安心的重新学习一次，并对每一次的代码做全面的测试，然后发布于此。<br>
以前的与数据结构相关的将被删除。</p>
]]></summary>
        <content type="html"><![CDATA[<p>期末数据结构考的真🐔不咋的，所以这个寒假准备安心的重新学习一次，并对每一次的代码做全面的测试，然后发布于此。<br>
以前的与数据结构相关的将被删除。</p>
<!--more-->
<p>线性表是最简单的数据结构，其在内存中的存储模式又分为顺序存储和链式存储，本节将展示顺序存储的代码。</p>
<pre><code class="language-c">//
// Created by abel on 2020/1/15.
//
#ifndef LINERLIST_H
#define LINERLIST_H

#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;stdbool.h&gt;
#define MAXSIZE 10
typedef int ElemType;
//线性表结点结构
typedef struct Liner_List{
    ElemType *data;//数据存储数组
    int capacity;//容纳能力
    int size;//当前所存数量
}List;

//初始化线性表
void InitList(List *list)
{
    list-&gt;capacity = MAXSIZE;//初始化最大容纳能力
    list-&gt;size=0;//初始为0个元素被存入
    list-&gt;data = (ElemType*)malloc(sizeof(ElemType)*list-&gt;capacity);
    if(!list-&gt;data)//开辟空间
    {
        printf(&quot;Memory Error!\n&quot;);
    }
}
//清空线性表里存储的信息
void ClearList(List *list)
{
    for(int i=0;i&lt;list-&gt;size;i++)
    {
        list-&gt;data[i]=0;
    }
    list-&gt;size=0;
}
//删除所有线性表
void DestroyList(List *list)
{
    free(list-&gt;data);
    free(list);
}

//判断线性表是否为空
bool ListEmpty(List *list)
{
    return (list-&gt;size==0);
}
//判断线性表是否为满
bool ListFull(List *list)
{
    return (list-&gt;size==list-&gt;capacity);
}

/*
 * 插入时需要将待插位置的元素及其后面的所有元素依次后移
 * 因此在插入时先将最后一个元素后移，接着往前，依次进行
 * 直到到了待插入位置，再将待插入位置的元素后移
 * 最后将新元素赋值给position，在计算机中就是[position-1]处
 */

//在position处插入元素
void InsertElem(List *list,int position,ElemType elem)
{
    if(position&lt;1||position&gt;list-&gt;size+1)//检查插入的位置
    {
        printf(&quot;Position Error!\n&quot;);
        return;
    }//检查是否已经满了
    if(ListFull(list))
    {
        printf(&quot;List is Full!\n&quot;);
        return;
    }
    //从最后一个元素开始到插入位置(通过减1转换为计算机存储的索引)
    for(int i=list-&gt;size;i&gt;=position-1;i--)
    {
        list-&gt;data[i+1]=list-&gt;data[i];//以此后移
    }
    list-&gt;data[position-1] = elem;//插入数据
    list-&gt;size++;//存储的个数加一
}

/*
 * 删除和插入类似
 * 只不过需要前移
 */
//删除元素
ElemType DeleteElem(List *list,int position)
{
    if(position&lt;1||position&gt;list-&gt;size+1)
    {
        printf(&quot;Position Error!\n&quot;);
        return -1;
    }
    if(ListEmpty(list))
    {
        printf(&quot;Empty List!\n&quot;);
        return -1;
    }
    ElemType temp = list-&gt;data[position-1];
    for(int i=position-1;i&lt;=list-&gt;size;i++)
    {
        list-&gt;data[i]=list-&gt;data[i+1];
    }
    list-&gt;size--;
    return temp;
}

//计算某元素出现了多少次
int CountElem(List *list,ElemType elem)
{
    int j=0;
    for(int i=0;i&lt;list-&gt;size;i++)
    {
        if(elem==list-&gt;data[i])
        {
            j++;
        }
    }
    return (j==0?-1:j);
}

//找到某个元素并定位
int FindPosition(List *list, ElemType elem)
{
    for(int i=0;i&lt;list-&gt;size;i++)
    {
        if(elem==list-&gt;data[i])return i+1;
    }
    return -1;
}

//显示所有元素
void DisplayList(List *list)
{
    if(ListEmpty(list))
    {
        printf(&quot;Empty Liner List!\n&quot;);
        return;
    }
    printf(&quot;Element:\n&quot;);
    for(int i=0;i&lt;list-&gt;size;i++)
    {
        printf(&quot;%d &quot;,list-&gt;data[i]);
    }
    printf(&quot;\n&quot;);
}

#endif LINERLIST_H

/*
对于以上的代码，可以复制下面的在main.c里面测试
#include &quot;LinerList.h&quot;

int main()
{
    List *list = (List*)malloc(sizeof(List));
    InitList(list);
    InsertElem(list,1,5);
    InsertElem(list,1,4);
    InsertElem(list,1,3);
    InsertElem(list,1,2);
    InsertElem(list,1,1);
    InsertElem(list,1,0);
    DisplayList(list);
    DeleteElem(list,1);
    DisplayList(list);

    InsertElem(list,3,1);
    DisplayList(list);
    printf(&quot;%d&quot;,CountElem(list,1));
    printf(&quot;%d&quot;,FindPosition(list,1));
    ClearList(list);
    DisplayList(list);
    DestroyList(list);
    return 0;
}
*/
</code></pre>
<p>相应的增加C++版本，觉得要简单一点</p>
<pre><code class="language-c++">//
//  LinerList.h
//  LinerStructure
//
//  Created by abel on 2020/1/16.
//  Copyright © 2020 abel. All rights reserved.
//

#ifndef LinerList_h
#define LinerList_h

#include &lt;iostream&gt;
using namespace std;

const int MAXSIZE = 10;

template &lt;typename T&gt;
class LinerList
{
private:
    T *data;
    int capacity;
    int size;
public:
    LinerList()
    {
        this-&gt;data = new T[MAXSIZE];
        this-&gt;capacity = MAXSIZE;
        this-&gt;size = 0;
    }
    LinerList(int newSize)
    {
        this-&gt;capacity = newSize;
        this-&gt;data = new T[this-&gt;capacity];
        this-&gt;size = 0;
    }
    ~LinerList()
    {
        delete []data;
    }
    
    bool isEmpty();
    bool isFull();
    void InsertElem(int position, T elem);
    T DeleteElem(int position);
    int FindElemPosition(T elem);
    int CountElem(T elem);
    void DisplayList();
};


template &lt;typename T&gt;
bool LinerList&lt;T&gt;::isEmpty()
{
    return this-&gt;size==0;
}
template &lt;typename T&gt;
bool LinerList&lt;T&gt;::isFull()
{
    return this-&gt;size==this-&gt;capacity;
}

template &lt;typename T&gt;
void LinerList&lt;T&gt;::InsertElem(int position, T elem)
{
    if(position&lt;1||position&gt;size+1)
    {
        cout&lt;&lt;&quot;Postion Error!\n&quot;;
        return;
    }
    if(isFull())
    {
        cout&lt;&lt;&quot;List is Full!\n&quot;;
        return;
    }
    for(int i=size;i&gt;=position-1;i--)
    {
        data[i+1] = data[i];
    }
    data[position-1] = elem;
    size++;
}

template &lt;typename T&gt;
T LinerList&lt;T&gt;::DeleteElem(int position)
{
    if(position&lt;1||position&gt;size+1)
    {
        cout&lt;&lt;&quot;Position Error!\n&quot;;
        return -1;
    }
    if(isEmpty())
    {
        cout&lt;&lt;&quot;List is Empty!\n&quot;;
        return -1;
    }
    for(int i=position-1;i&lt;size;i++)
    {
        data[i]=data[i+1];
    }
    size--;
}
template &lt;typename T&gt;
int LinerList&lt;T&gt;::FindElemPosition(T elem)
{
    if(isEmpty())
    {
        cout&lt;&lt;&quot;Empty List!\n&quot;;
        return -1;
    }
    for(int i=0;i&lt;size;i++)
    {
        if(data[i]==elem)return (i+1);
    }
    cout&lt;&lt;&quot;No The elem\n&quot;;
    return -1;
}

template &lt;typename T&gt;
int LinerList&lt;T&gt;::CountElem(T elem)
{
    if(isEmpty())
    {
        cout&lt;&lt;&quot;Empty List!\n&quot;;
        return -1;
    }
    int j = 0;
    for(int i=0;i&lt;size;i++)
    {
        if(data[i] == elem)j++;
    }
    if(j==0)
    {
        cout&lt;&lt;&quot;No element!\n&quot;;
        return -1;
    }
    return j;
}

template &lt;typename T&gt;
void LinerList&lt;T&gt;::DisplayList()
{
    if(!isEmpty())
    {
        for(int i=0;i&lt;size;i++)
        {
            cout&lt;&lt;data[i]&lt;&lt;&quot; &quot;;
        }
        cout&lt;&lt;endl;
        return;
    }
    cout&lt;&lt;&quot;Empty List!\n&quot;;
}
#endif /* LinerList_h */
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Decir algo]]></title>
        <id>https://abelcorn.cn/post/unexpectedtrip</id>
        <link href="https://abelcorn.cn/post/unexpectedtrip">
        </link>
        <updated>2019-10-06T13:00:00.000Z</updated>
        <summary type="html"><![CDATA[<ul>
<li>任由海风吹拂，心里却未曾感激过这无聊的咸涩。想来孤独的历程已逾8月，却丝毫没有忘却昔日的愉悦和懊恼。</li>
</ul>
]]></summary>
        <content type="html"><![CDATA[<ul>
<li>任由海风吹拂，心里却未曾感激过这无聊的咸涩。想来孤独的历程已逾8月，却丝毫没有忘却昔日的愉悦和懊恼。</li>
</ul>
<!-- more -->
<ul>
<li>对啊，当初为何莫名其妙，就同本不可能在一起的人许下长久的愿景。理智同自己讲说变数太多，何苦故增烦恼，但仍推着自己往坎坷的路上前进。或许不是谁前谁后吧，但是一开始就在岔路上，走的越久，人影亦愈发的朦胧。</li>
<li>她点播人的技巧多曼妙，就是那一点点火苗引燃自己对未来一切的畅想。彷徨于现实中的慨叹，总会在夜深时想着如何勾勒出那生活的美好。可是燃起来的不只是自己，谁又想到连着这画本身也开始燃烧，把自己殷切的期盼讲给画听，止不住那烛光，反却救焚益薪。</li>
<li>于是她丝毫未有回首的想法，迈着步子走开，你看迷雾本来就遮掩着世间，这下该是什么也看不着了。</li>
<li>所以想呀，要是人类没有感情多好，事物皆逻辑，人们是不是不会再被伤心的事阻碍？于是闭着眼睛向前走，要是眼里皆尽是黑暗，何惧你终会来的黑暗。可是我总是怀念那被暖意包围，被阳光普照的世界，常常在安静的时候，在四下无人的时候，偷偷的睁开眼睛。只恨这一时半会儿没有适应，竟然会略觉刺眼。</li>
<li>你说当大家明晃晃的盯着我，要是我也睁眼回看着她，会被众人耻笑吗？</li>
<li></li>
<li>也别轻易的回答，毕竟海风还没停歇，那些海鸥们也在吵闹。</li>
<li>奇怪啊，为何阴沉的天空与迷离的大海如此的沉重，却在那轮红日的映衬下显得如此完美。为何我总想着那天的和风与暖日，却不愿品味每一个季节。他们都是亲切的，只是不知道用哪种方式接近我，不至于只贪恋往日，每个让我感到心安的日子，都是那么美好。</li>
<li>我想，心里也应该感激，纵使这海风并不温柔。</li>
</ul>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Matlab学习笔记（三）]]></title>
        <id>https://abelcorn.cn/post/matlab-3</id>
        <link href="https://abelcorn.cn/post/matlab-3">
        </link>
        <updated>2019-09-22T11:27:48.000Z</updated>
        <summary type="html"><![CDATA[<p><em><strong>矩阵</strong></em></p>
]]></summary>
        <content type="html"><![CDATA[<p><em><strong>矩阵</strong></em></p>
<!--more-->
<h3 id="矩阵">矩阵</h3>
<p><strong>矩阵定义</strong>：</p>
<ul>
<li>如3x3的矩阵<code>A=[1 2 3;4 5 6; 7 8 9]</code></li>
<li>3维矩阵：<code>[[1 2 3];[2 4 6];[7 8 9]]</code></li>
<li>复数矩阵：<code>[[1 1+i 2];[2 3+2i 1]]</code></li>
<li>矩阵生成：</li>
<li>
<ul>
<li>利用M文件写入</li>
<li>利用文本创建：</li>
<li>建立<code>goods.txt</code>，里面写入相关矩阵信息，接着<code>load goods.txt</code></li>
</ul>
</li>
<li>创建特殊矩阵：</li>
<li>
<ul>
<li><code>eye(n)</code>：创建nxn的单位矩阵</li>
<li><code>eye(m,n)</code>：创建mxn的单位矩阵</li>
<li><code>eye(size(A))</code>：创建与A同维的单位矩阵</li>
<li><code>ones(n)</code>：创建nxn的全1矩阵</li>
<li><code>ones(m,n)</code>、 <code>ones(size(A))</code></li>
<li><code>zeros(n)</code>、 <code>zeros(m,n)</code>、 <code>zeros(size(A))</code></li>
<li><code>rand(n)</code>：在<code>[0,1]</code>区间内创建一个nxn的均匀随机矩阵</li>
<li><code>rand(m,n)</code>、<code>rand(size(A))</code></li>
<li><code>compan(P)</code>：创建系数向量是P的多项式伴随矩阵</li>
<li><code>diag(v)</code>：创建一向量v中的元素为对角的对角矩阵</li>
<li><code>hilb(n)</code>：创建nxn的Hilbert矩阵</li>
<li><code>magic(n)</code>：生成n阶魔方矩阵</li>
<li><code>sparse(A)</code>：将A转化为稀疏矩阵，即由A的非0元素和下标构成的稀疏矩阵S。若A本身为稀疏矩阵，则返回A本身(即仍然为稀疏矩阵A)</li>
</ul>
</li>
</ul>
<p><strong>矩阵元素的运算</strong>：</p>
<ol>
<li>元素修改：
<ul>
<li><code>D=[A;B C]</code>：A为原矩阵，B、C中包含要扩充的元素，D为扩充后的矩阵</li>
<li><code>A(m,:)=[]</code>：删除A的第m行</li>
<li><code>A(:,n)=[]</code>：删除A的第n列</li>
<li><code>A(m,n) =a</code>：对A的第m行n列元素赋值</li>
<li><code>A(m,:)=[a,b,c....]</code>：对A的第m行赋值</li>
<li><code>A(:,n)=[a,b,c,...]</code></li>
</ul>
</li>
<li>维度修改:</li>
</ol>
<ul>
<li>矩阵的变维可以用符号“：”和reshape函数变换
<ul>
<li><code>A=1:12</code> <code>B=reshape(A,2,6)</code></li>
<li>用冒号法时，要注意需先设定修改后的矩阵形状</li>
<li><code>C=zeros(3,4);</code> <code>C(:)=A(:)</code></li>
</ul>
</li>
</ul>
<ol start="3">
<li>矩阵的变向：
<ul>
<li><code>Rot(90)</code>：将A逆时针旋转90度</li>
<li><code>Rot(90,k)</code>：将A旋转<code>k*90</code>度，其中k为正负整数</li>
<li><code>Fliplr(X)</code>:将X左右翻转</li>
<li><code>flipud(X)</code>：将X上下翻转</li>
<li><code>flipdim(X,dim)</code>：dim=1时对行翻转，dim=2时对列翻转</li>
</ul>
</li>
<li>矩阵的抽取:</li>
</ol>
<ul>
<li>主要指对角线元素和上下三角矩阵的抽取
<ul>
<li><code>diag(X,k)</code>：抽取矩阵的第k条对角线上的元素向量。k=0表示主对角线，k为正整数时抽取上方第k条。。。。。。。</li>
<li><code>diag(X)</code>：抽取主对角线</li>
<li><code>diag(v,k)</code>：使得v为所得矩阵第k条对角线上的元素向量</li>
<li><code>diag(v)</code>：使得v为所得矩阵主对角线上的元素向量</li>
<li><code>tril(X)</code>：提取矩阵X的主下三角部分</li>
<li><code>tril(X,k)</code>：提取第k条对角线下面的部分（包括第k条）</li>
<li><code>triu(X)</code>：提取上三角</li>
<li><code>triu(X,k)</code>：........上三角（包括第k条）</li>
</ul>
</li>
</ul>
<h3 id="矩阵的数学运算">矩阵的数学运算</h3>
<ul>
<li>待续</li>
</ul>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Matlab学习笔记（二）]]></title>
        <id>https://abelcorn.cn/post/matlab-2</id>
        <link href="https://abelcorn.cn/post/matlab-2">
        </link>
        <updated>2019-09-20T13:22:05.000Z</updated>
        <summary type="html"><![CDATA[<p>本节内容将说明一般的向量运算，为后面的矩阵运算做好基础。向量大部分为中学知识，不再说明计算方法与用处。</p>
]]></summary>
        <content type="html"><![CDATA[<p>本节内容将说明一般的向量运算，为后面的矩阵运算做好基础。向量大部分为中学知识，不再说明计算方法与用处。</p>
<!--more-->
<p><em><strong>向量与多项式</strong></em></p>
<h3 id="向量">向量</h3>
<p><strong>向量的生成</strong>：</p>
<ol>
<li>直接输入：行向量：<code>x=[1,2,3]</code>，列向量：<code>x=[1;2;3]</code></li>
<li>冒号输入：<code>x=0:2:10</code>，表示从0一直到10，步长为2，隔一个输出，即结果是<code>x=[0,2,4,6,8,10]</code> 如果<code>x=0:10</code>，则默认步长为1</li>
<li>linspace函数法：<code>linspace(first_value,last_value,number)</code>，从第一到最后的数据范围，其中包括number个数</li>
<li>logspace函数法：<code>logspace(first_value,last_value,number)</code>,输出number个，从10<sup>first_value到10</sup>last_value，如：<code>logspace(1,3,3)</code>可得10 100 1000</li>
</ol>
<p><strong>向量元素的引用</strong>：</p>
<ul>
<li>如<code>x=[1,2,3,4,5]</code>，则<code>x(1:3)</code>表示抽出第一到第三个元素，即1 2 3</li>
</ul>
<p><strong>向量运算</strong>：</p>
<ul>
<li>
<p>定义向量</p>
</li>
<li>
<p>加法+</p>
</li>
<li>
<p>减法-</p>
</li>
<li>
<p>乘法*</p>
</li>
<li>
<p>除法/</p>
</li>
<li>
<p>混合运算 （以上均中学知识不再赘述）</p>
</li>
<li>
<p>点积：点积可用<code>.*</code>或者<code>dot(a,b)</code>,<code>dot(a,b,dim)</code>，其中，a和b必须同维，dim是a和b在dim维度的点积</p>
</li>
<li>
<p>叉积：<code>cross(a,b)</code>,<code>cross(a,b,dim)</code></p>
</li>
<li>
<p>卷积：我们称</p>
<p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>(</mo><mi>f</mi><mo>∗</mo><mi>g</mi><mo>)</mo><mo>(</mo><mi>n</mi><mo>)</mo><mi mathvariant="normal">为</mi><mi>f</mi><mo separator="true">,</mo><mi>g</mi><mi mathvariant="normal">的</mi><mi mathvariant="normal">卷</mi><mi mathvariant="normal">积</mi><mi mathvariant="normal">。</mi><mi mathvariant="normal">其</mi><mi mathvariant="normal">计</mi><mi mathvariant="normal">算</mi><mi mathvariant="normal">方</mi><mi mathvariant="normal">式</mi><mi mathvariant="normal">为</mi><mi mathvariant="normal">：</mi><msubsup><mo>∫</mo><mrow><mo>−</mo><mi mathvariant="normal">∞</mi></mrow><mrow><mo>+</mo><mi mathvariant="normal">∞</mi></mrow></msubsup><mi>f</mi><mo>(</mo><mi>τ</mi><mo>)</mo><mi>g</mi><mo>(</mo><mi>n</mi><mo>)</mo><mi>d</mi><mi>τ</mi></mrow><annotation encoding="application/x-tex">(f*g)(n)为f,g的卷积。 其计算方式为： \int_{-\infty}^{+\infty}f(\tau)g(n)d\tau
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:2.491512em;vertical-align:-0.970281em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="mclose">)</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mclose">)</span><span class="mord cjk_fallback">为</span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="mord cjk_fallback">的</span><span class="mord cjk_fallback">卷</span><span class="mord cjk_fallback">积</span><span class="mord cjk_fallback">。</span><span class="mord cjk_fallback">其</span><span class="mord cjk_fallback">计</span><span class="mord cjk_fallback">算</span><span class="mord cjk_fallback">方</span><span class="mord cjk_fallback">式</span><span class="mord cjk_fallback">为</span><span class="mord cjk_fallback">：</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mop"><span class="mop op-symbol large-op" style="margin-right:0.44445em;position:relative;top:-0.0011249999999999316em;">∫</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.5212310000000002em;"><span style="top:-1.7880500000000001em;margin-left:-0.44445em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">−</span><span class="mord mtight">∞</span></span></span></span><span style="top:-3.8129000000000004em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">+</span><span class="mord mtight">∞</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.970281em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.1132em;">τ</span><span class="mclose">)</span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mclose">)</span><span class="mord mathdefault">d</span><span class="mord mathdefault" style="margin-right:0.1132em;">τ</span></span></span></span></span></p>
</li>
<li>
<p>去卷积</p>
</li>
</ul>
<h3 id="多项式">多项式</h3>
<p><strong>多项式的创建</strong>：</p>
<ul>
<li>多项式创建时只需要写出系数，没有的项必须用0代替</li>
<li>如：<code>p=[3,2,1]</code>，之后输入<code>poly2sym(p)</code>，就得到了：<code>3*x^3+2*x^2+x</code></li>
</ul>
<p><strong>多项式的四则运算</strong>：</p>
<ul>
<li>
<p>卷积：我们称$$(f*g)(n)为f,g的卷积。 其计算方式为： \int_{-\infty}^{+\infty}f(\tau)g(n)d\tau$$</p>
</li>
<li>
<p>计算方式为<code>conv(p1,p2)</code></p>
</li>
<li>
<p>去卷积：<code>[k,r]=deconv(p,q)</code>等价于<code>p=conv(q,k)+r</code></p>
</li>
<li>
<p>k返回的是多项式p除以q的商，r是余式</p>
</li>
<li>
<p>根构造：通过写出多项式的解，让系统自己构造一个符合根的多项式</p>
</li>
<li>
<p>如：<code>root=[-5,3+2i,3-2i]</code> 则，<code>p=poly(root)</code>就构造了对应的系数表，接着<code>poly2sym(p)</code>可以生成多项式</p>
</li>
</ul>
<p><strong>多项式的导数运算</strong>：</p>
<ul>
<li>通过<code>polyder(p)</code>就可以得到求导后的系数表，接着<code>poly2sym()</code>可生成求导后的多项式</li>
<li>更高阶的导数类似反复调用就行</li>
</ul>
<h3 id="特殊变量">特殊变量</h3>
<p><strong>单元型变量</strong>：</p>
<ul>
<li>
<p>创建：</p>
</li>
<li>
<ul>
<li>如：<code>A[1,2,3,4];B=3+2i;C='hhh'</code>，则生成方式为<code>E={A,B,C}</code></li>
<li><code>cell(n)</code>：生成n*n阶的空单元数组</li>
<li><code>cell(m,n)</code></li>
<li><code>cell(m,n,p,....)</code></li>
<li><code>cell(size(A))</code>：生成与A同形式的单元型空矩阵</li>
<li><code>E=cell(1,3)</code></li>
<li><code>E{1,1}=[1:4]</code></li>
<li><code>E{1,2}=B</code></li>
</ul>
</li>
<li>
<p>引用：</p>
</li>
<li>
<ul>
<li><code>E{1}</code></li>
<li><code>E(1)</code></li>
</ul>
</li>
<li>
<p>其他函数：</p>
</li>
<li>
<ul>
<li><code>cellfun</code>：对单元型变量中的元素作用的函数</li>
<li><code>celldisp</code>：显示变量内容</li>
<li><code>cellplot</code>：图形显示</li>
<li><code>num2cell</code>：将数值转换成单元型变量</li>
<li><code>deal</code>：输入输出</li>
<li><code>cell2struct</code>：单元型变成结构型</li>
<li><code>struct2cell</code>：将结构型变成单元型</li>
<li><code>iscell</code>：判断是否为单元型</li>
<li><code>reshape</code>：改变单元数组的结构</li>
</ul>
</li>
</ul>
<p><strong>结构型变量</strong>：</p>
<ul>
<li>
<p>创建：</p>
</li>
<li>
<ul>
<li><code>struct('field',value1,'filed2',value2,.....)</code>：表示建立一个具有属性名及对应数据的结构型数组</li>
<li>如：<code>p=struct('color',{'red','green'},'num',{1,2,3})</code></li>
</ul>
</li>
<li>
<p>引用：</p>
</li>
<li>
<ul>
<li><code>p</code>、<code>p(1)</code> 、<code>p(1).color</code></li>
</ul>
</li>
<li>
<p>函数：</p>
</li>
<li>
<ul>
<li><code>struct</code>：创建结构型变量</li>
<li><code>fieldnames</code>：得到结构型变量的属性名</li>
<li><code>getfield</code>：得到属性值</li>
<li><code>setfield</code>：设定属性值</li>
<li><code>rmfield</code>：删除属性</li>
<li><code>isfield</code>：判断是否为结构型的属性</li>
<li><code>isstruct</code>：判断是否为结构型变量</li>
</ul>
</li>
</ul>
<p><em><strong>接着会更新矩阵运算的相关内容</strong></em></p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Matlab学习笔记（一）]]></title>
        <id>https://abelcorn.cn/post/matlab-1</id>
        <link href="https://abelcorn.cn/post/matlab-1">
        </link>
        <updated>2019-09-18T15:18:08.000Z</updated>
        <summary type="html"><![CDATA[<p><em><strong>基础知识</strong></em><br>
C++考试终于结束了，可以开始matlab的学习了，本部分内容仅为自己做笔记用，不属于对外教程。</p>
]]></summary>
        <content type="html"><![CDATA[<p><em><strong>基础知识</strong></em><br>
C++考试终于结束了，可以开始matlab的学习了，本部分内容仅为自己做笔记用，不属于对外教程。</p>
<!--more-->
<h3 id="常用指令">常用指令</h3>
<ul>
<li><code>cd</code>：显示或改变工作目录</li>
<li><code>clc</code>：清除命令行窗口</li>
<li><code>clf</code>：清除图形窗口</li>
<li><code>hold</code>：保持图形窗口</li>
<li><code>diary</code>：生成日志文件</li>
<li><code>load</code>：加载指定文件的变量</li>
<li><code>dir</code>：显示当前目录下的文件</li>
<li><code>pack</code>：整理内存碎片</li>
<li><code>disp</code>：显示变量或文字内容</li>
<li><code>path</code>：显示搜索目录</li>
<li><code>echo</code>：命令行窗口信息显示开关</li>
<li><code>quit</code>：退出 Matlab</li>
<li><code>save</code>：保存内存变量指定文件</li>
<li><code>type</code>：显示文件内容</li>
</ul>
<h3 id="变量与常量">变量与常量</h3>
<p><strong>变量：</strong></p>
<ul>
<li>变量名必须以字母开头，之后可以是任意的字母、数字或下划线</li>
<li>大小写敏感</li>
<li>不超过31个字符，第31个及之后的会被忽略</li>
<li>未加说明的前提下，一切变量视为局部变量，可用global声明为全局</li>
</ul>
<p><strong>常量</strong>：</p>
<ul>
<li><code>ans</code>：默认变量，一般用在显示答案</li>
<li><code>pi</code>：圆周率</li>
<li><code>eps</code>：浮点运算相对精度</li>
<li><code>inf</code>：无穷大 如1/0</li>
<li><code>NaN</code>：不定值，如0/0</li>
<li><code>i j</code>：虚数单位</li>
<li><code>realmin</code>：最小正浮点数</li>
<li><code>realmax</code>：最大正浮点数</li>
</ul>
<h3 id="数值">数值</h3>
<p><strong>整型</strong>：</p>
<ul>
<li><code>char</code>:字符型，占用1字节</li>
<li><code>short</code>:短整型，占用2字节</li>
<li><code>int</code>:整型，4字节</li>
<li><code>long</code>:长整型，8字节</li>
<li>以上均有对应的无符号类型:<code>unsigned xxx</code></li>
</ul>
<p><strong>浮点型</strong>：</p>
<ul>
<li>十进制类型，如：1.2 4.44</li>
<li>指数形式，如: 2.1E5  3.7e-2</li>
<li>指数标志e前必须有数字，后面必须有阶码</li>
<li><code>float</code>：单精度，4字节</li>
<li><code>double</code>：双精度，8字节</li>
</ul>
<p><strong>复数类型</strong>：</p>
<ul>
<li>实部：Rez=a</li>
<li>虚部：Imz=b</li>
<li>当虚部为0，可视为实数；当实部为0而虚部不为0，叫做纯虚数</li>
<li>加法法则：<code>(a+bi)+(c+di) = (a+c)+(b+d)i</code></li>
<li>减法法则：<code>(a+bi)-(c+di) = (a-c)+(b-c)i</code></li>
<li>乘法法则：<code>(a+bi)*(c+di) = (ac-bd)+(bc+ad)i</code></li>
<li>除法法则：<code>(a+bi)/(c+di) = [(ac+bd)/(c^2+d^2)]+[(bc-ad)/(c^2+d^2)]i</code></li>
</ul>
<p><strong>数字显示格式</strong>：</p>
<ul>
<li>
<p><code>format short</code>：5位定点表示（默认）</p>
</li>
<li>
<p><code>format long</code>：15位定点表示</p>
</li>
<li>
<p><code>format short e</code>：5位浮点表示</p>
</li>
<li>
<p><code>format short g</code>：自动选择定点还是浮点表示</p>
</li>
<li>
<p><code>format hex</code>：十六进制显示</p>
</li>
<li>
<p><code>format +</code>：在矩阵中，用+、-和空格表示正、负和零</p>
</li>
<li>
<p><code>format bank</code>：用美元和美分定点表示</p>
</li>
<li>
<p><code>format rat</code>：以有理数形式输出结果</p>
</li>
<li>
<p><code>format compact</code>：变量间无空格</p>
</li>
<li>
<p><code>format loose</code>：变量间有空行</p>
</li>
<li>
<p>以上输出方式:</p>
<pre><code class="language-matlab">format long,pi
</code></pre>
</li>
</ul>
<h3 id="运算符">运算符</h3>
<p>除简单的四则运算外，还有点乘<code>.*</code>，等，后期运算会遇到</p>
<p><strong>关系运算符</strong>：</p>
<ul>
<li><code>==</code>：等于</li>
<li><code>~=</code>：不等于</li>
<li><code>&gt;``&gt;=``&lt;``&lt;=</code>：比较</li>
<li>以上返回值为0或1</li>
</ul>
<p><strong>逻辑运算法</strong>：</p>
<ul>
<li><code>-</code>：逻辑与</li>
<li><code>|</code>：逻辑或</li>
<li><code>~</code>：逻辑非</li>
<li><code>xor</code>：逻辑异或</li>
<li><code>any</code>：有非零元素则为真</li>
<li><code>all</code>：所有元素均非零才为真</li>
</ul>
<h3 id="函数运算">函数运算</h3>
<p><strong>复数运算</strong>：</p>
<ul>
<li><code>abs</code>:模</li>
<li><code>angle</code>：复数相角</li>
<li><code>complex</code>：用实部和虚部构造一个复数</li>
<li><code>conj</code>：复数的共轭</li>
<li><code>imag</code>：虚部</li>
<li><code>real</code>：实部</li>
<li><code>unwrap</code>：调整矩阵元素的相位</li>
<li><code>isreal</code>：判断是否为实数矩阵</li>
<li><code>cplxpair</code>：把复数矩阵排列成复共轭对</li>
</ul>
<p><strong>三角函数运算</strong>：</p>
<ul>
<li><code>sin()</code>：</li>
<li><code>cos()</code></li>
<li><code>tan()</code></li>
<li><code>cot()</code></li>
<li><code>sec()</code>：正割</li>
<li><code>csc()</code>：余割<br>
<em><strong>后期将更新向量与多项式的内容</strong></em></li>
</ul>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[LaTex表示方法]]></title>
        <id>https://abelcorn.cn/post/latex</id>
        <link href="https://abelcorn.cn/post/latex">
        </link>
        <updated>2019-09-02T10:20:28.000Z</updated>
        <summary type="html"><![CDATA[<h3 id="注意">注意</h3>
<ul>
<li>由于语法较多，这里将官方图搬移至此，感兴趣请配合前面MarkDown语法入门教程使用。</li>
</ul>
]]></summary>
        <content type="html"><![CDATA[<h3 id="注意">注意</h3>
<ul>
<li>由于语法较多，这里将官方图搬移至此，感兴趣请配合前面MarkDown语法入门教程使用。</li>
</ul>
<!--more-->
<h3 id="基本语法">基本语法</h3>
<p><img src="https://abelcorn.cn/post-images/1567938210213.gif" alt="" loading="lazy"><br>
<img src="https://abelcorn.cn/post-images/1567938221943.gif" alt="" loading="lazy"><br>
<img src="https://abelcorn.cn/post-images/1567938230247.gif" alt="" loading="lazy"><br>
<img src="https://abelcorn.cn/post-images/1567938235219.gif" alt="" loading="lazy"><br>
<img src="https://abelcorn.cn/post-images/1567938313920.gif" alt="" loading="lazy"><br>
<img src="https://abelcorn.cn/post-images/1567938319571.gif" alt="" loading="lazy"><br>
<img src="https://abelcorn.cn/post-images/1567938324053.gif" alt="" loading="lazy"></p>
<h3 id="常用数学符合">常用数学符合</h3>
<p><img src="https://abelcorn.cn/post-images/1567938431251.gif" alt="" loading="lazy"><br>
<img src="https://abelcorn.cn/post-images/1567938438640.gif" alt="" loading="lazy"><br>
<img src="https://abelcorn.cn/post-images/1567938443215.gif" alt="" loading="lazy"><br>
<img src="https://abelcorn.cn/post-images/1567938447006.gif" alt="" loading="lazy"><br>
<img src="https://abelcorn.cn/post-images/1567938450994.gif" alt="" loading="lazy"><br>
<img src="https://abelcorn.cn/post-images/1567938458954.gif" alt="" loading="lazy"><br>
<img src="https://abelcorn.cn/post-images/1567938465008.gif" alt="" loading="lazy"></p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Markdown语法学习]]></title>
        <id>https://abelcorn.cn/post/markdown-1</id>
        <link href="https://abelcorn.cn/post/markdown-1">
        </link>
        <updated>2019-09-01T04:01:38.000Z</updated>
        <summary type="html"><![CDATA[<p>markdown语法作为一种高效的标记写作语法，已经在各种网站博客中体现出来，正如我的这些博客，也都是使用markdown语法写成。这种语法通过在你的文字前后添加规定的符号，使得文字显示出你所想要的形式，就如Word中的文字处理一般，但是更为简洁和高效。为了使大家都能轻松使用，现将其基本使用方式写下。</p>
]]></summary>
        <content type="html"><![CDATA[<p>markdown语法作为一种高效的标记写作语法，已经在各种网站博客中体现出来，正如我的这些博客，也都是使用markdown语法写成。这种语法通过在你的文字前后添加规定的符号，使得文字显示出你所想要的形式，就如Word中的文字处理一般，但是更为简洁和高效。为了使大家都能轻松使用，现将其基本使用方式写下。</p>
<!-- more-->
<h2 id="分级标题">分级标题 :</h2>
<ul>
<li><code>#一级标题</code></li>
<li><code>##二级标题</code></li>
<li>依次类推，总共支持六级标题</li>
</ul>
<h2 id="斜体-粗体">斜体、粗体：</h2>
<ul>
<li><code>*斜体*，或者 _斜体_</code>,如<em>这是斜体</em></li>
<li><code>**粗体**</code>，如：<strong>这是粗体</strong></li>
<li><code>***加粗斜体***</code> ,如：<em><strong>这是加粗斜体</strong></em></li>
<li><code>~~ 删除线~~</code>,如：<s>这是删除线</s></li>
</ul>
<h2 id="超链接">超链接：</h2>
<ul>
<li>通过<code>[]()</code>的使用，可以达到仅显示文字，但文字下面包含超链接的功能</li>
<li><code>[东北大学](http://neu.edu.cn)</code>:<a href="http://neu.edu.cn">东北大学</a></li>
<li>接着你点击东北大学文字，就可以转到所隐藏的网页中了</li>
<li>以上所诉皆为行内方式，下面介绍其他方式：</li>
<li>参考式：如果某一个链接在文章中多处使用，那么建议使用参考式：</li>
<li><code>[链接标题][链接标记]</code>，一般链接标记用顺序的数字来代替，接着在文本的任意位置再写：<code>[链接标记]:链接地址&quot;链接标题&quot;</code>.</li>
<li>自动链接，即让网址既当标题也当超链接：<code>&lt;http://neu.edu.cn&gt;</code>: <a href="http://neu.edu.cn">http://neu.edu.cn</a></li>
</ul>
<h2 id="列表">列表：</h2>
<ul>
<li>使用<code>* + -</code>表示的是无序的列表，正如我目前写的所有标题下的文字都是无序标题</li>
<li>有序标题和我们平时写一样，<code>1.xxx</code>在数字后写英文的句号，如：</li>
</ul>
<ol>
<li>一号列表</li>
<li>二号</li>
<li>三号</li>
</ol>
<ul>
<li>定义型列表：由名词和解释组成，一行写上定义，接着一行冒号加上Tab缩进和解释，如：<br>
定义型列表<br>
：由名词定义和解释组成的列表</li>
<li>如果要在列表中放入引用，则用<code>&gt;</code>缩进。如：</li>
<li>包含引用的列表</li>
<li>
<blockquote>
<p>引用1</p>
</blockquote>
</li>
<li>
<blockquote>
<p>引用2</p>
</blockquote>
</li>
<li>多层引用则根据你的<code>&gt;</code>的数量了，一般来说不超过3个</li>
<li>插入代码，则用Tab键上面的类似与单引号的符号前后包围就行</li>
<li>插入图像：<code>![图片](url &quot;图片题目&quot;)</code></li>
<li>注脚：<code>[^注脚名]:注脚内容</code></li>
</ul>
<h2 id="其他">其他：</h2>
<ul>
<li>以上都是最基本的markdown语法，要想自己练习，推荐下载Typora编辑器，可以实时体验语法的魅力</li>
<li>希望各位自行练习和查找相关基本语法知识，活学活用</li>
<li>以后我将介绍<strong>表格</strong>、<strong>流程图</strong>和<strong>LaTex公式</strong>，这样的markdown才是真正优秀的语法。</li>
</ul>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Giving Life Meaning]]></title>
        <id>https://abelcorn.cn/post/text-1</id>
        <link href="https://abelcorn.cn/post/text-1">
        </link>
        <updated>2019-08-09T11:05:44.000Z</updated>
        <summary type="html"><![CDATA[<p><em>Have you thought about what you want people to say about you after you’re gone?</em></p>
]]></summary>
        <content type="html"><![CDATA[<p><em>Have you thought about what you want people to say about you after you’re gone?</em></p>
<!--more-->
<p><em>Can you hear the voice saying, “He was a great man.” Or “She really will be missed.” What else do they say?</em></p>
<p><em>One of the strangest phenomena of life is to engage in a work that will last long after death. Isn’t that a lot like investing all your money so that future generations can bare interest on it? Perhaps, yet if you look deep in your own heart, you’ll find something drives you to make this kind of contribution---something drives every human being to find a purpose that lives on after death.</em></p>
<p><em>Do you hope to memorialize your name? Have a name that is whispered with reverent awe? Do you hope to have your face carved upon 50 ft of granite rock? Is the answer really that simple? Is the purpose of lifetime contribution an ego-driven desire for a mortal being to have an immortal name or is it something more?</em></p>
<p><em>A child alive today will die tomorrow. A baby that had the potential to be the next Einstein will die from complication is at birth. The circumstances of life are not set in stone. We are not all meant to live life through to old age. We’ve grown to perceive life3 as a full cycle with a certain number of years in between. If all of those years aren’t lived out, it’s a tragedy. A tragedy because a human’s potential was never realized. A tragedy because a spark was snuffed out before it ever became a flame.</em></p>
<p><em>By virtue of inhabiting a body we accept these risks. We expose our mortal flesh to the laws of the physical environment around us. The trade off isn’t so bad when you think about it. The problem comes when we construct mortal fantasies of what life should be like. When life doesn’t conform to our fantasy we grow upset, frustrated, or depressed.</em></p>
<p><em>We are alive; let us live. We have the ability to experience; let us experience. We have the ability to learn; let us learn. The meaning of life can be grasped in a moment. A moment so brief it often evades our perception.</em></p>
<p><em>What meaning stands behind the dramatic unfolding of life? What single truth can we grasp and hang onto for dear life when all other truths around us seem to fade with time?</em></p>
<p><em>These moments are strung together in a series we call events. These events are strung together in a series we call life. When we seize the moment and bend it according to our will, a will driven by the spirit deep inside us, then we have discovered the meaning of life, a meaning for us that shall go on long after we depart this Earth.</em></p>
]]></content>
    </entry>
</feed>