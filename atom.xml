<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://abelcorn.cn</id>
    <title>小石石石</title>
    <updated>2019-11-24T10:58:47.776Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://abelcorn.cn"/>
    <link rel="self" href="https://abelcorn.cn/atom.xml"/>
    <subtitle>Always do your best.</subtitle>
    <logo>https://abelcorn.cn/images/avatar.png</logo>
    <icon>https://abelcorn.cn/favicon.ico</icon>
    <rights>All rights reserved 2019, 小石石石</rights>
    <entry>
        <title type="html"><![CDATA[数据结构--双端队列]]></title>
        <id>https://abelcorn.cn/post/datastruct-deque</id>
        <link href="https://abelcorn.cn/post/datastruct-deque">
        </link>
        <updated>2019-11-22T23:20:00.000Z</updated>
        <summary type="html"><![CDATA[<p>实验五要求实现简单的STL中的deque功能，故在此通过循环数组的方式实现之。</p>
]]></summary>
        <content type="html"><![CDATA[<p>实验五要求实现简单的STL中的deque功能，故在此通过循环数组的方式实现之。</p>
<!--more-->
<pre><code class="language-c">//@实验五 实现类STL的双端队列deque（循环数组版）
// Created by abel on 2019/11/23.
//

#ifndef DEQUE_H
#define DEQUE_H

#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;stdbool.h&gt;
#define maxSize 10//默认最大长度

typedef int ElemType;//抽象基本数据
typedef struct {//双端队列基本结构
    ElemType *data;//数据存储的数组
    int capacity;//最大容量
    int front,rear;//头、尾指针
    int size;//保存当前存的数据
}deque;

deque *createDeque();//创建一个队列
deque *createADeque(int size);//创建一个以size为容量的双端队列
bool isEmpty(deque *q);//判断队列是否为空队列
bool isFull(deque *q);//判断一个队列是否为满队列
bool Push_front(deque *q, ElemType x);//将元素压入队头
bool Push_back(deque *q,ElemType x);//将元素压入队尾
ElemType Pop_front(deque *q);//弹出队头元素
ElemType getFront(deque *q);//得到队头元素
ElemType Pop_back(deque *q);//弹出队尾元素
ElemType getBack(deque *q);//得到队尾元素
void Display(deque *q);//从头到尾显示数据
int getSize(deque *q);//得到队列当前得到的元素个数
int getCapacity(deque *q);//得到当前队列的最大容量

//初始创建双端队列
deque *createDeque()
{
    //创建一个初始的存储地址，开辟空间
    deque *q = (deque *) malloc(sizeof(deque));
    if(!q)//判断空间开辟是否成功
    {
        printf(&quot;Memory Error--&gt;deque!\n&quot;);
        return NULL;
    }
    q-&gt;capacity = maxSize;//初始化最大容量
    q-&gt;size=0;
    q-&gt;front = q-&gt;rear=0;//初始化头、尾指针位置
    q-&gt;data = (ElemType*)malloc(sizeof(ElemType)*q-&gt;capacity);//开辟基本存储数组的存储空间
    if(!q-&gt;data)//判断空间开辟情况
    {
        printf(&quot;Memory Error--&gt;deque.data[size]!\n&quot;);
        return NULL;
    }
    return q;//将该队列返回
}
//创建一个以size为容量的双端队列
deque *createADeque(int size)
{
    deque *q = (deque*)malloc(sizeof(deque));
    if(!q)//判断空间开辟是否成功
    {
        printf(&quot;Memory Error--&gt;deque!\n&quot;);
        return NULL;
    }
    //初始化各项参数
    q-&gt;capacity = size;
    q-&gt;size = 0;
    q-&gt;rear = q-&gt;front = 0;
    q-&gt;data = (ElemType *)malloc(sizeof(ElemType)*q-&gt;capacity);
    if(!q-&gt;data)//为数据存储数组开辟空间
    {
        printf(&quot;Memory Error--&gt;deque.data[size]!\n&quot;);
        return NULL;
    }
    return q;
}

//判断队列是否为空
bool isEmpty(deque *q)
{
    return (q-&gt;front==q-&gt;rear);
}
//判断队列是否为满
bool isFull(deque *q)
{
    return ((q-&gt;rear+1)%maxSize==q-&gt;front);
}
//以上可用size代替
//从头入队
bool Push_front(deque *q, ElemType x)
{
    //如果队满则不插入并返回
    if(isFull(q))
    {
        return false;
    }
    else//否则
    {
        q-&gt;front = (q-&gt;front-1+maxSize)%maxSize;//先将队头指针逆时针移一位
        q-&gt;data[q-&gt;front]=x;//赋值
        q-&gt;size++;
        return true;
    }
}

//从尾部入队
bool Push_back(deque *q,ElemType x)
{
    if(isFull(q)) //如果队满则不插入并返回
    {
        return false;
    }
    else//否则
    {
        q-&gt;data[q-&gt;rear]=x;//将数据写入该尾部位置
        q-&gt;rear=(q-&gt;rear+1)%maxSize;//将尾指针后移
        q-&gt;size++;
        return true;
    }
}

//头部出队
ElemType Pop_front(deque *q)
{
    //判断是否为空
   if(isEmpty(q))
   {
       return -999;
   }
   else//如果不为空
   {
       ElemType  x= q-&gt;data[q-&gt;front];//将头指针指向的位置的值赋给x
       q-&gt;front = (q-&gt;front+1)%maxSize;//头指针顺时针后移
       return x;
   }
}
//得到头部元素
ElemType getFront(deque *q)
{
    if(isEmpty(q))return -999;//如果为空则返回-999
    else return q-&gt;data[q-&gt;front];//否则返回当前头指针的值
}

//尾部出队
ElemType Pop_back(deque *q)
{
    if(isEmpty(q))//判断队列是否为空
    {
        return -999;
    }
    else//否则
    {
        q-&gt;rear = (q-&gt;rear+maxSize-1)%maxSize;//将尾部逆时针移动一位
        ElemType  x = q-&gt;data[q-&gt;rear];//将尾部的值给x
        return x;
    }
}
//得到尾数据
ElemType getBack(deque *q)
{
    if(isEmpty(q))return -999;//判断是否为空
    else return q-&gt;data[q-&gt;rear];//返回尾部数据
}

//打印全部元素
void Display(deque *q)
{
    for(int i=0;i&lt;q-&gt;size;i++)
    {
        printf(&quot;%d &quot;,q-&gt;data[(q-&gt;front+i)%maxSize]);
    }
    printf(&quot;\n&quot;);
}
//得到当前元素数量
int getSize(deque *q)
{
    return q-&gt;size;
}
//得到当前队列的最大容量
int getCapacity(deque *q)
{
    return q-&gt;capacity;
}


#endif //DEQUE_H
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[数据结构--二分查找]]></title>
        <id>https://abelcorn.cn/post/datastruct_search1</id>
        <link href="https://abelcorn.cn/post/datastruct_search1">
        </link>
        <updated>2019-11-12T13:32:52.000Z</updated>
        <summary type="html"><![CDATA[<p>单身使人快乐。<br>
<br><br>
我真🌶️🐔</p>
]]></summary>
        <content type="html"><![CDATA[<p>单身使人快乐。<br>
<br><br>
我真🌶️🐔</p>
<!--more-->
<pre><code class="language-c">#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;

//创建一个顺序表结构
typedef struct Table
{
    int *data;//存数据
    int length;//表长度
}table;

//冒泡排序
void Bubble_Sort(int a[],int n)
{
    int temp;
    int i,j;
    printf(&quot;Original: &quot;);
    for(i=0;i&lt;n;i++)
    {
        printf(&quot;%d &quot;,a[i]);
    }
    printf(&quot;\n&quot;);
    //先将原始数据打印出来
    //排序
    for(i=0;i&lt;n;i++)
    {
        for(j=0;j&lt;n-i-1;j++)
        {
            if(a[j]&gt;a[j+1])
            {
                temp = a[j];
                a[j] = a[j+1];
                a[j+1]=temp;
            }
        }
    }
}

//创建顺序表
table *createTable()
{
    table *t = (table*)malloc(sizeof(table));
    if(!t)//判断空间开辟情况
    {
        printf(&quot;Memory Error!\n&quot;);
        return NULL;
    }
    //输入存入的数据数量
    printf(&quot;How many numbers you want to enter?\n&quot;);
    scanf(&quot;%d&quot;,&amp;t-&gt;length);
    t-&gt;data = (int*)malloc(sizeof(int)*t-&gt;length);
    if(!t-&gt;data)
    {
        printf(&quot;Memory Error!\n&quot;);
        return NULL;
    }
    //判断空间开辟情况
    printf(&quot;Enter them:\n&quot;);
    //输入数据
    for(int i=0;i&lt;t-&gt;length;i++)
    {
        scanf(&quot;%d&quot;,&amp;t-&gt;data[i]);
    }
    //调用排序算法
    Bubble_Sort(t-&gt;data,t-&gt;length);
    printf(&quot;Now:    &quot;);
    for(int i=0;i&lt;t-&gt;length;i++)
    {
        printf(&quot;%d &quot;,t-&gt;data[i]);
    }
    printf(&quot;\n&quot;);
    //展示现在的顺序
    return t;
}

//二分查找
int Binary_Search(const int a[],int x,int n)
{
    int low=0,high=n,mid;
    while(low&lt;=high)//当低位不高于高位时
    {
        mid = (high+low)/2;//求出中间位
        if(x == a[mid])//判断是否是此数
        {
            return mid;//是则返回
        }
        else//不是
        {
            if(x&gt;a[mid])low = mid+1;
            //若要找的数大于中间数，则缩小空间至原来的[mid,high]
            else high = mid-1;
            //若要找的数小于中间数，则缩小空间至原来的[low,mid]
        }
    }
    return -1;//找不到
}

int main()
{
    table *t = createTable();//创建此顺序表
    int x;
    printf(&quot;Enter the number which you wanna find: &quot;);
    scanf(&quot;%d&quot;,&amp;x);//输入你要找的数据
    int flag = Binary_Search(t-&gt;data,x,t-&gt;length);//存下数据做处理
    if(flag!=-1)//找到了则
    {
        printf(&quot;Successful!\n%d 's position is %dth\n&quot;,x,flag+1);
    }
    else//没找到
    {
        printf(&quot;Failed!\n&quot;);
    }
    return 0;
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[数据结构--图(邻接表）]]></title>
        <id>https://abelcorn.cn/post/datastruct_graph2</id>
        <link href="https://abelcorn.cn/post/datastruct_graph2">
        </link>
        <updated>2019-11-11T13:31:27.000Z</updated>
        <summary type="html"><![CDATA[<p>单身好啊，好就好在没人打扰我写代码</p>
]]></summary>
        <content type="html"><![CDATA[<p>单身好啊，好就好在没人打扰我写代码</p>
<!--more-->
<pre><code class="language-c">#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;stdbool.h&gt;

#define maxVer 30//最大顶点数
#define maxEdges 900//最大边数
#define maxWeight 100//最大权值

//边结点，存储每一个结点的边链表
typedef struct ENode
{
    int dest;
    int weight;
    struct ENode* link;
}edgeNode;

//点结点，是每一行的第一个结点
typedef struct VNode
{
    char data;
    struct ENode* adj;   
}verNode;

//图的基本结构
typedef struct 
{
    int numVer,numEdge;//点数和边数
    verNode verList[maxVer];//顶点信息集合
}graph;

//获取点总数
int numofVer(graph *g);
//获取边总数
int numofEdge(graph *g);
//获取点的位置
int getVerPos(graph *g, char v);
//获取第pos的位置顶点顺序
char getInfo(graph *g, int pos);
//获取两个结点的权值信息
int getWeight(graph *g,char v1,char v2);

//获取点总数
int numofVer(graph *g)
{
    return g-&gt;numVer;
}

//获取边总数
int numofEdge(graph *g)
{
    return g-&gt;numEdge;
}

//获取点的位置
int getVerPos(graph *g, char v)
{
    int i=0;
    while(i&lt;g-&gt;numVer &amp;&amp; g-&gt;verList[i].data != v){i++;}//当没有找到匹配v的就持续循环
    if(i&lt;g-&gt;numVer)return i;//如果最后找到了就返回位置信息
    else return -1;//不然就返回-1
}

//获取第pos的位置顶点顺序
char getInfo(graph *g, int pos)
{
    if(pos!=-1)//位置信息没问题
    {
        return g-&gt;verList[pos].data;//返回该位置的结点信息
    }
    else
    {
        return '#';//否则就返回#表示有问题
    }
}

//获取两个结点的权值信息
int getWeight(graph *g,char v1,char v2)
{
    int i=-1,j=-1;
    i = getVerPos(g,v1);
    j = getVerPos(g,v2);
    //获取两个结点的位置
    edgeNode *p = g-&gt;verList[i].adj;
    //将该结点位置的邻接链表赋给p
    while(p!=NULL &amp;&amp;p-&gt;dest != j)//当p的边不等于j的位置
    {
        p=p-&gt;link;//将p后移
    }
    if(p!=NULL)return p-&gt;weight;//返回权值
    else return -1;//返回-1
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[数据结构--图(邻接矩阵)]]></title>
        <id>https://abelcorn.cn/post/datastruct_graph1</id>
        <link href="https://abelcorn.cn/post/datastruct_graph1">
        </link>
        <updated>2019-11-11T13:29:08.000Z</updated>
        <summary type="html"><![CDATA[<p>单身狗的日常。自己看</p>
]]></summary>
        <content type="html"><![CDATA[<p>单身狗的日常。自己看</p>
<!--more-->
<pre><code class="language-c">//
// Created by abel on 2019/11/11.
//

#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;stdbool.h&gt;

#define maxVer 30//最大顶点数
#define maxEdges 900//最大边数
#define maxWeight 100//最大权值

//图的结构
typedef struct Graph
{
    int numVer,numEdge;//点数和边数
    int  verList[maxVer];//顶点数据集合
    int edgeList[maxVer][maxVer];//邻接矩阵
}graph;

//建立图*
void createGraph(graph *g);
//打印图数据*
void printGraph(graph *g);
//初始化图*
void initGraph(graph *g);
//得到顶点v在顶点数据集合中的位置*
int getVerPos(graph *g,int v);
//获取整个图的顶点数*
int numofVer(graph *g);
//获取整个图的边数*
int numofEdge(graph *g);
//得到两个点之间边的权值*
int getWeight(graph *g,int v1, int v2);
//得到顶点v的第一个邻接点*
int firstNeighbor(graph *g,int v);
//插入新顶点*
bool insertVer(graph *g);
//插入新边*
bool insertEdge(graph *g);

//建立图
void createGraph(graph *g)
{
    int ver,edge;
    printf(&quot;Number of Ver: &quot;);
    scanf(&quot;%d&quot;,&amp;ver);
    printf(&quot;Number of Edge: &quot;);
    scanf(&quot;%d&quot;,&amp;edge);
    //输入点数和边数
    g-&gt;numVer = ver;
    g-&gt;numEdge = edge;
    //将输入的点数和边数给图赋值
    printf(&quot;Please enter the data of the vers: \n&quot;);
    int value,j;
    //输入各顶点并将顶点数据存入顶集合中
    for(int i=0;i&lt;ver;i++)
    {
        scanf(&quot;%d&quot;,&amp;value);
        g-&gt;verList[i]=value;
        for(j=0;j&lt;ver;j++)//输入时初始化邻接矩阵
        {
            //如果将对角线元素全部变为0,其他的都变成maxWeight，及相当于初始化为无穷大
            g-&gt;edgeList[i][j]=(i==j)?0:maxWeight;
        }
    }
    //在输入完所有顶点信息后，开始存入邻接矩阵
    printf(&quot;Enter the two Ver and their weight every time:\n&quot;);
    int v1,v2,cost;
    for(int i=0;i&lt;edge;i++)
    {
        scanf(&quot;%d %d %d&quot;,&amp;v1,&amp;v2,&amp;cost);//输入两个点及其权值
        value = getVerPos(g,v1);//得到点1的位置
        j = getVerPos(g,v2);//得到点2的位置
        if(value != -1 &amp;&amp; j != -1)//判断位置是否有效
        {
            g-&gt;edgeList[value][j]=cost;//将权值存入邻接矩阵
            g-&gt;edgeList[j][value]=cost;//无向图对称存入
        }
        else
        {
            printf(&quot;Error Info!\n&quot;);
            abort();
        }
    }
}

//得到顶点v在顶点数据集合中的位置
int getVerPos(graph *g,int v)
{
    bool flag = false;//设置一个开关判断是否找到该顶点
    int i=-1;
    for(i=0;i&lt;g-&gt;numVer;i++)
    {
        if(v==g-&gt;verList[i])//如果找到了
        {
            flag = true;
            break;//跳出循环
        }
    }
    if(flag)//如果找到了
    {
        return i;//将位置返回
    }
    else
    {
        return -1;//否则返回-1
    }
}

//打印图数据
void printGraph(graph *g)
{
    printf(&quot;The verList: \n&quot;);//将图的顶点集合打印出来
    for(int i=0;i&lt;g-&gt;numVer;i++)
    {
        printf(&quot;%d &quot;,g-&gt;verList[i]);
    }
    printf(&quot;\n&quot;);
    printf(&quot;The Matrix Of the List:\n&quot;);//将邻接权值矩阵打印出来
    for(int i=0;i&lt;g-&gt;numVer;i++)
    {
        for(int j=0;j&lt;g-&gt;numVer;j++)
        {
            if(g-&gt;edgeList[i][j]==maxWeight)//如果权值等于最大值
            {
                printf(&quot;∞ &quot;);//以无穷大符号显示
                continue;
            }
            else
            {
                printf(&quot;%d &quot;,g-&gt;edgeList[i][j]);//否则打印权值
            }
        }
        printf(&quot;\n&quot;);
    }
}

//初始化图
void initGraph(graph *g)
{
    for(int i=0;i&lt;g-&gt;numVer;i++)
    {
        for(int j=0;j&lt;g-&gt;numVer;j++)//将邻接矩阵变为全零矩阵
        {
            g-&gt;edgeList[i][j]=0;
        }
    }
}

//获取整个图的顶点数
int numofVer(graph *g)
{
    return g-&gt;numVer;
}

//获取整个图的边数
int numofEdge(graph *g)
{
    return g-&gt;numEdge;
}

//得到两个点之间边的权值
int getWeight(graph *g,int v1, int v2)
{
    int va,vb;
    int i,j;
    printf(&quot;Enter two vers: \n&quot;);
    scanf(&quot;%d %d&quot;,&amp;va,&amp;vb);
    i = getVerPos(g,va);
    j = getVerPos(g,vb);
    //查找两个顶点的位置
    if(i!=-1&amp;&amp;j!=-1)
    {
        return g-&gt;edgeList[i][j];
        //在邻接权值矩阵中找到这条路径的权值
    }
    else
    {
        return -1;//否则返回-1
    }
}

//得到顶点v的第一个邻接点
int firstNeighbor(graph *g,int v)
{
    int pos=-1;//一个固定的位置记录符
    if(v!=-1)//如果给的点是正确的
    {
        for(int j=0;j&lt;g-&gt;numVer;j++)
        {
            if(g-&gt;edgeList[v][j]&gt;0&amp;&amp;g-&gt;edgeList[v][j]&lt;maxWeight)//查看点v有没有权值为非0或者非无穷大的边
            {
                pos = j;//若有则记录此位置
                break;
            }
        }
    }
    if(pos!=-1)
    {
        return g-&gt;verList[pos];//将该位置的顶点数据返回
    }
    return -1;
}

//插入新顶点
bool insertVer(graph *g)
{
    printf(&quot;Please enter the ver data: \n&quot;);
    int value;
    scanf(&quot;%d&quot;,&amp;value);
    g-&gt;verList[g-&gt;numVer+1]=value;//将新顶点的数据存入顶点集合
    printf(&quot;Enter the dest ver info and their weight:\n&quot;);
    int ver,cost;
    scanf(&quot;%d %d&quot;,&amp;ver,&amp;cost);//输入与新结点链接的点及其权值输入
    int i = getVerPos(g,ver);///得到已存在的该点的位置
    int j = g-&gt;numVer+1;
    if(i!=-1)
    {
        g-&gt;numVer++;
        g-&gt;numEdge++;//图的基本信息更新
        for(int k = 0;k&lt;g-&gt;numVer+1;k++)
        {
         g-&gt;edgeList[k][j]=maxWeight;//重新布置邻接矩阵
         g-&gt;edgeList[j][k]=maxWeight;
        }
        g-&gt;edgeList[j][j]=0;
        g-&gt;edgeList[i][j]=g-&gt;edgeList[j][i]=cost;//将权值写入矩阵中
        return true;
    }
    return false;
}

//插入新边
bool insertEdge(graph *g)
{
    printf(&quot;Enter two ver:\n&quot;);
    int v1,v2;
    scanf(&quot;%d %d&quot;,&amp;v1,&amp;v2);
    int i = getVerPos(g,v1);
    int j = getVerPos(g,v2);//找到输入的两个点的位置信息
    if(i!=-1 &amp;&amp; j!=-1)
    {
        int weight;
        printf(&quot;Enter the weight between them:\n&quot;);
        scanf(&quot;%d&quot;,&amp;weight);//输入两点的权值信息　
        g-&gt;edgeList[i][j]=g-&gt;edgeList[j][i]=weight;//赋值
        return true;
    }
    return false;
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[数据结构实验--在线测试提交]]></title>
        <id>https://abelcorn.cn/post/dataexp-2</id>
        <link href="https://abelcorn.cn/post/dataexp-2">
        </link>
        <updated>2019-10-25T01:44:17.000Z</updated>
        <summary type="html"><![CDATA[<p>本次是针对实验一、二的在线题目，包括三道题：合并升序链表、队列元素置逆和括号匹配问题。若有写的不好的地方还请指正。</p>
]]></summary>
        <content type="html"><![CDATA[<p>本次是针对实验一、二的在线题目，包括三道题：合并升序链表、队列元素置逆和括号匹配问题。若有写的不好的地方还请指正。</p>
<!--more-->
<p><strong>1.合并链表</strong>:</p>
<ul>
<li>【问题描述】 两个非降序链表的并集，例如将链表1-&gt;2-&gt;3 和 2-&gt;3-&gt;5 并为 1-&gt;2-&gt;3-&gt;5，只能输出结果，不能修改两个链表的数据。</li>
<li>【输入形式】 第一行为第一个链表的各结点值，以空格分隔。 第二行为第二个链表的各结点值，以空格分隔。</li>
<li>【输出形式】 合并好的链表，以非降序排列，值与值之间以空格分隔。</li>
<li>【样例输入】 4 7 10 34 1 4 6 29 34 34 52</li>
<li>【样例输出】 1 4 6 7 10 29 34 52</li>
<li>【评分标准】 要使用链表实现，否则不能得分。</li>
</ul>
<pre><code class="language-c">//@合并链表
// Created by abel on 2019/10/23.
//
#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;

typedef struct Node {
    int data;
    struct Node *next;
}list;
//输入并创建两个初始链表
void create(list *list1,list* list2)
{
    list *p1 = list1;
    list *p2 = list2;
    char ch1,ch2;
    int data;
    do
    {
        scanf(&quot;%d&quot;,&amp;data);
        list *temp;
        temp=(list*)malloc(sizeof(list));
        temp-&gt;next=0;
        temp-&gt;data=data;
        p1-&gt;next=temp;
        p1=p1-&gt;next;


    }while((ch1=getchar())!='\n');

    do
    {
        scanf(&quot;%d&quot;,&amp;data);
        list *temp;
        temp=(list*)malloc(sizeof(list));
        temp-&gt;next=0;
        temp-&gt;data=data;
        p2-&gt;next=temp;
        p2=p2-&gt;next;

    }while((ch2=getchar())!=EOF);
}
//按大小合并链表
void merge(list *list1,list* list2)
{
    list* p1=list1-&gt;next;
    list* p2=list2-&gt;next;
    list* p=list1;

    while(p1&amp;&amp;p2)
    {
        if(p1-&gt;data&lt;=p2-&gt;data)
        {
            p-&gt;next=p1;
            p=p-&gt;next;
            p1=p1-&gt;next;
        }
        else
        {
            p-&gt;next=p2;
            p=p2;
            p2=p2-&gt;next;
        }
    }
    if(p1)
    {
        p-&gt;next=p1;
    }
    else
    {
        p-&gt;next=p2;
    }
    free(list2);
}
//打印链表元素（无重复值）
void display(list *list1)
{
    list* p=list1-&gt;next;
    while(p-&gt;next)
    {
        if(p-&gt;data==p-&gt;next-&gt;data)
        {
            p=p-&gt;next;
        }
        else
        {
            printf(&quot;%d &quot;,p-&gt;data);
            p=p-&gt;next;
        }
    }printf(&quot;%d\n&quot;,p-&gt;data);
}

int main()
{
    list* list1;
    list* list2;
    list1=(list*)malloc(sizeof(list));
    list2=(list*)malloc(sizeof(list));
    list1-&gt;next=NULL;
    list2-&gt;next=NULL;

    create(list1,list2);
    merge(list1,list2);
    display(list1);
    return 0;
}
</code></pre>
<p>*<strong>2.队列置逆</strong>：</p>
<ul>
<li>【问题描述】 已知Q是一个非空队列，S是一个空栈。仅使用少量工作变量以及对队列和栈的基本操作，编写一个算法，将队列Q中的所有元素逆置。</li>
<li>【输入形式】 输入的第一行为队列元素个数，第二行为队列从首至尾的元素</li>
<li>【输出形式】 输出队列的逆置</li>
<li>【样例输入】 3 1 2 3</li>
<li>【样例输出】 3 2 1</li>
<li>【评分标准】 需采用队列与栈的知识，否则不能得分</li>
</ul>
<pre><code class="language-c">//@队列元素置逆
// Created by abel on 2019/10/23.
//

#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;stdbool.h&gt;

//建立队列的基本结构
typedef struct Queue
{
    int *data;
    int size;
    int capacity;
    int front,rear;
}queue;

//建立栈的基本结构
typedef struct Stack
{
    int *data;
    int top;
    int capacity;
}stack;

//创建队列
queue *createQueue(int n)
{
    queue *queue1 = (queue*)malloc(sizeof(queue));
    if(!queue1)
    {
        printf(&quot;Memory Error!\n&quot;);
        return NULL;
    }

    queue1-&gt;capacity = n;
    queue1-&gt;data = (int*)malloc(sizeof(int)*queue1-&gt;capacity);
    queue1-&gt;front=queue1-&gt;rear=-1;
    queue1-&gt;size=0;

    return queue1;
}

//创建栈
stack *createStack(int n)
{
    stack *stack1 = (stack*)malloc(sizeof(stack));
    if(!stack1)
    {
        printf(&quot;Memory Error!\n&quot;);
        return NULL;
    }
    stack1-&gt;capacity = n;
    stack1-&gt;data = (int*)malloc(sizeof(stack1-&gt;capacity));
    stack1-&gt;top=-1;

    return stack1;
}

//判断栈空
bool emptyStack(stack *stack1)
{
    return stack1-&gt;top==-1;
}

//判断队空
bool emptyQueue(queue *queue1)
{
    return queue1-&gt;size==0;
}

//入栈
void push(stack *stack1,int elem)
{
    stack1-&gt;top++;
    stack1-&gt;data[stack1-&gt;top]=elem;
}

//出栈
void pop(stack *stack1)
{
    if(!emptyStack(stack1))
    {
        printf(&quot;%d &quot;,stack1-&gt;data[stack1-&gt;top]);
        stack1-&gt;top--;
    }
    else
    {
        return;
    }
}

//入队
void enQueue(queue *queue1,int elem)
{
    queue1-&gt;front++;
    queue1-&gt;data[queue1-&gt;front]=elem;
    queue1-&gt;size++;
    if(queue1-&gt;rear==-1)
    {
        queue1-&gt;rear=0;
    }
}

//出队
int deQueue(queue *queue1) {
    if(!emptyQueue(queue1))
    {
        queue1-&gt;size--;
        return queue1-&gt;data[queue1-&gt;rear++];
    }
}

int main()
{
    int n;
    scanf(&quot;%d&quot;,&amp;n);
    queue *queue1 = createQueue(n);
    stack *stack1 = createStack(n);

    int a[n];
    for(int i=0;i&lt;n;i++)
    {
        scanf(&quot;%d&quot;,&amp;a[i]);
    }
    for(int i=0;i&lt;n;i++)
    {
        enQueue(queue1,a[i]);
    }
    for(int i=0;i&lt;n;i++)
    {
        push(stack1,deQueue(queue1));
    }
    for(int i=0;i&lt;n;i++)
    {
        pop(stack1);
    }

    return 0;
}
</code></pre>
<p><strong>3.括号匹配</strong>：</p>
<ul>
<li>【问题描述】 假设一算术表达式中包括三种括号：圆括号“（”和“）”，方括号“[”和“]”，花括号“{”和“}”，且三种括号可按意次序嵌套使用，试编写程序判定输入的表达式所含的括号是否正确配对出现。若匹配，则返回1，否则返回0。</li>
<li>【输入形式】 含括号的算数表达式</li>
<li>【输出形式】 若表达式中的括号正确配对，则输出1。否则，输出0。</li>
<li>【样例输入】 3+(44*[5-{6*[7*(45-10)]}])</li>
<li>【样例输出】 1</li>
<li>【样例说明】 判断括号是否匹配涉及两方面的问题，一是对左右括号的出现次数的判定，二是对不同括号的出现次序的判定。</li>
</ul>
<pre><code class="language-c">//@括号匹配
// Created by abel on 2019/10/23.
//


#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;stdbool.h&gt;


typedef struct Stack
{
    char *data;
    int capacity;
    int top;
}stack;

stack *createStack()
{
    stack *stack1 = (stack*)malloc(sizeof(stack));
    if(!stack1)
    {
        printf(&quot;Memory Error!\n&quot;);
        return NULL;
    }

    stack1-&gt;top=-1;
    stack1-&gt;capacity = 10;
    stack1-&gt;data = (char*)malloc(sizeof(char)*stack1-&gt;capacity);
    if(!stack1-&gt;data)
    {
        printf(&quot;Memory Error!\n&quot;);
        return NULL;
    }

    return stack1;
}

bool isFull(stack *stack1)
{
    return stack1-&gt;top==stack1-&gt;capacity-1;
}

bool isEmpty(stack *stack1)
{
    return stack1-&gt;top==-1;
}

void push(stack *stack1,char elem)
{
    if(!isFull(stack1))
    {
        stack1-&gt;top++;
        stack1-&gt;data[stack1-&gt;top]=elem;
    }
    else
    {
        stack1-&gt;capacity = stack1-&gt;capacity*2;
        stack1-&gt;data = realloc(stack1-&gt;data, sizeof(stack1-&gt;capacity));
        stack1-&gt;top++;
        stack1-&gt;data[stack1-&gt;top]=elem;
    }
}

char pop(stack *stack1)
{
    if(!isEmpty(stack1))
    {
        return stack1-&gt;data[stack1-&gt;top--];
    }
    else
    {
        return 0;
    }
}

int start()
{
    stack *stack1 = createStack();
    char ch;
    int flag = 0;
    while((ch=getchar())!='\n'&amp;&amp;ch!=EOF)
    {
        if((ch=='(')||(ch=='[')||(ch=='{'))
        {
            push(stack1,ch);

        }
        else if((ch==')')||(ch==']')||(ch=='}'))
        {
            char temp;
            switch (ch)
            {
                case ')':
                {
                    temp=pop(stack1);
                    if(temp=='(')
                    {
                        flag=1;
                        continue;
                    }
                    flag=0;
                    break;
                }
                case ']':
                {
                    temp = pop(stack1);
                    if(temp=='[')
                    {
                        flag=1;
                        continue;
                    }
                    flag=0;
                    break;
                }
                case '}':
                {
                    temp=pop(stack1);
                    if(temp=='{')
                    {
                        flag=1;
                        continue;
                    }
                    flag=0;
                    break;
                }
            }
        }
        else{flag=1;}
    }
    if (!isEmpty(stack1))
    {
        flag=0;
    }
    return flag;
}

int main()
{
    int a=0;
    a=start();
    printf(&quot;%d\n&quot;,a);

    return 0;
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[数据结构--循环队列]]></title>
        <id>https://abelcorn.cn/post/queue</id>
        <link href="https://abelcorn.cn/post/queue">
        </link>
        <updated>2019-10-19T02:38:26.000Z</updated>
        <summary type="html"><![CDATA[<p>一般循环数组队列</p>
]]></summary>
        <content type="html"><![CDATA[<p>一般循环数组队列</p>
<!--more-->
<p><strong>C语言版</strong>:</p>
<pre><code class="language-c">//@循环数组队列 C语言版
// Created by abel on 2019/10/19.
//

#ifndef C_DATASTRUCTURES_QUEUE_H
#define C_DATASTRUCTURES_QUEUE_H

#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;stdbool.h&gt;

#define MAXSIZE 5//默认最大容量

//队列的结点
typedef struct Queue
{
    int *data;//数组
    int capacity;//初始容量
    int front;//头
    int rear;//尾
    int size;//计数
}queue;

//创建队列
queue *createQueue()
{
    queue *queue1 = (queue*)malloc(sizeof(queue));//开辟队列空间
    if(!queue1)//检查队列空间开辟是否成功
    {
        printf(&quot;Memory Error\n&quot;);
        return NULL;
    }
    //初始化队列
    queue1-&gt;capacity = MAXSIZE;
    queue1-&gt;data = (int*)malloc(sizeof(int)*queue1-&gt;capacity);
    if(!queue1-&gt;data)//为循环数组开辟空间
    {
        printf(&quot;Memory Error\n&quot;);
        return NULL;
    }
    //初始化队列
    queue1-&gt;front=queue1-&gt;rear=-1;
    queue1-&gt;size=0;

    for(int i=0;i&lt;3;i++)//初始化3个数据做测试
    {
        queue1-&gt;data[i]=i+1;
    }
    queue1-&gt;front=2;//头索引移动到2
    queue1-&gt;size=3;//计数
    return queue1;//将此队列返回
}

//判断是否为空队列
bool isEmpty(queue *queue1)
{
    return queue1-&gt;size==0;
}

//判断是否为满队列
bool isFull(queue *queue1)
{
    return queue1-&gt;size==queue1-&gt;capacity;
}

//入队
void enQueue(queue *queue1,int elem)
{
    if(!isFull(queue1))//判断是否满队
    {
        queue1-&gt;front = (queue1-&gt;front+1)%queue1-&gt;capacity;//移动当前位置
        queue1-&gt;data[queue1-&gt;front]=elem;//存入新数据
        queue1-&gt;size++;//计数增加
        if(queue1-&gt;rear==-1)
        {
            queue1-&gt;rear=0;
        }
    }
    else
    {
        printf(&quot;Full!\n&quot;);
    }
}
//出队
void deQueue(queue *queue1)
{
    if(!isEmpty(queue1))//判断是否为空
    {
        printf(&quot;%d&quot;,queue1-&gt;data[queue1-&gt;rear]);//打印此时的数据
        queue1-&gt;rear=(queue1-&gt;rear+1)%queue1-&gt;capacity;
        queue1-&gt;size--;//减少计数
    }
    else
    {
        printf(&quot;Empty!\n&quot;);
    }
}

#endif //C_DATASTRUCTURES_QUEUE_H
</code></pre>
<p><strong>C++版本</strong>:</p>
<pre><code class="language-c++">//@循环数组队列 CPP版
// Created by abel on 2019/10/19.
//
#ifndef CPP_DATASTRUCTURES_QUEUE_H
#define CPP_DATASTRUCTURES_QUEUE_H

#include &lt;iostream&gt;
using namespace std;

const int MaxSize = 10;//默认最大长度

class Queue//队列类
{
private:
    int *data;//循环数组
    int capacity;//最大容量
    int front;
    int rear;
    int size;//计数
public:
    Queue()//构造函数
    {
        //初始化类
        capacity = MaxSize;
        data = new int[capacity];
        front=rear=-1;
        size=0;
    }
//    ~Queue()//析构函数
//    {
//        delete []data;
//    }
    //判断为空队列
    bool isEmpty()
    {
        return size==0;
    }
    //判断为满队列
    bool isFull()
    {
        return size==capacity;
    }
    void enQueue(int elem);//入队
    void deQueue();//出队
};

void Queue::enQueue(int elem) {
    if(!isFull())
    {
        front=(front+1)%capacity;
        data[front] = elem;
        size++;
        if(rear==-1)
        {
            rear=0;
        }
    }
    else
    {
        cout&lt;&lt;&quot;Full!&quot;&lt;&lt;endl;
    }
}

void Queue::deQueue() {
    if(!isEmpty())
    {
        cout&lt;&lt;data[rear]&lt;&lt;endl;
        rear = (rear+1)%capacity;
        size--;
    }
    else
    {
        cout&lt;&lt;&quot;Empty!&quot;&lt;&lt;endl;
    }
}

#endif //CPP_DATASTRUCTURES_QUEUE_H

</code></pre>
<p><strong>Java版本</strong>:</p>
<pre><code class="language-java">//@循环数组队列 Java版
// Created by abel on 2019/10/19.
//
public class Queue//队列类
{
	final int MaxSize = 10;//默认初始长度
	private int [] data;//循环数组
	private int capacity;//最大容量
	private int front;
	private int rear;
	private int size;//计数
	//构造体
	public Queue()
	{
		//初始化队列
		this.capacity = MaxSize;
		this.data = new int[this.capacity];
		this.front=this.rear=-1;
		this.size=0;
	}
	//判断为空队列
	public boolean isEmpty()
	{
		return size==0;
	}
	//判断为满队列
	public boolean isFull()
	{
		return size==this.capacity;
	}
	//入队
	public void enQueue(int elem)
	{
		if(!isFull())
		{
			this.front = (this.front+1)%this.capacity;
			data[this.front]=elem;
			this.size++;
			if(this.rear==-1)
			{
				this.rear=0;
			}
		}
		else
		{
			System.out.println(&quot;Full!&quot;);
		}
	}
	//出队
	public void deQueue()
	{
		if(!isEmpty())
		{
			System.out.println(data[rear]);
			this.rear = (this.rear+1)%this.capacity;
			this.size--;
		}
		else
		{
			System.out.println(&quot;Empty!&quot;);
		}
	}
}
</code></pre>
<p><strong>C#版本</strong>：</p>
<pre><code class="language-c#">//@循环数组队列 C#版
// Created by abel on 2019/10/19.
//
using System;

public class Queue//队列的类
{
    const int MAXSIZE = 10;//默认最大容量
    private int size;//计数
    private int capacity;//最大容量
    private int front;//
    private int rear;
    private int[] data;//循环数组
    //构造体
    public Queue()
    {
        this.capacity = MAXSIZE;
        this.data = new int[capacity];
        this.front = this.rear = -1;
        this.size = 0;
        //初始化所有信息
    }
    //判断为空队
    public bool isEmpty()
    {
        return size == 0;
    }
    //判断为满队
    public bool isFull()
    {
        return size == capacity;
    }
    //入队
    public void enQueue(int elem)
    {
        if(!isFull())
        {
            front = (front + 1) % capacity;
            data[front] = elem;
            size++;
            if(rear==-1)
            {
                rear = 0;
            }
        }
        else
        {
            Console.WriteLine(&quot;Full!&quot;);
        }
    }
    public void deQueue()
    {
        if(!isEmpty())
        {
            Console.WriteLine(data[rear]);
            rear = (rear + 1) % capacity;
            size--;
        }
        else
        {
            Console.WriteLine(&quot;Empty!&quot;);
        }
    }
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[数据结构实验--约瑟夫环]]></title>
        <id>https://abelcorn.cn/post/datastructures_ex_josephus</id>
        <link href="https://abelcorn.cn/post/datastructures_ex_josephus">
        </link>
        <updated>2019-10-19T01:32:21.000Z</updated>
        <summary type="html"><![CDATA[<p>Josephus排列问题定义如下：假设n个竞赛者排成一个环形。给定一个正整数m≤n，从第1人开始，沿环计数，第m人出列。这个过程一直进行到所有人都出列为止。最后出列者为优胜者。全部出列次序定义了1，2，…n的一个排列。称为（n，m）Josephus排列。例如，（7，3）Josephus排列为3,6,2,7,5,1,4。且若m为偶数则逆时针开始，为奇数为顺时针。</p>
]]></summary>
        <content type="html"><![CDATA[<p>Josephus排列问题定义如下：假设n个竞赛者排成一个环形。给定一个正整数m≤n，从第1人开始，沿环计数，第m人出列。这个过程一直进行到所有人都出列为止。最后出列者为优胜者。全部出列次序定义了1，2，…n的一个排列。称为（n，m）Josephus排列。例如，（7，3）Josephus排列为3,6,2,7,5,1,4。且若m为偶数则逆时针开始，为奇数为顺时针。</p>
<!--more-->
<p><strong>C语言</strong>：</p>
<pre><code class="language-c">//@约瑟夫环 C语言版本
// Created by abel on 2019/10/18.
//

#ifndef CLIONCODE_JOSEPHUS_H
#define CLIONCODE_JOSEPHUS_H

#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;stdbool.h&gt;

//约瑟夫环结点
typedef struct Josephus
{
    int data;//每个结点的数据
    struct Josephus *front;//指向前驱
    struct Josephus *next;//指向后继
}list;


//顺序打印一次
void display(list *list1,int m)
{
    if(m%2==0)
    {
        list *p = list1;
        printf(&quot;约瑟夫环当前数据为：\n&quot;);
        while (p-&gt;front!=list1)
        {
            printf(&quot;%d &quot;,p-&gt;data);
            p=p-&gt;front;
        }
        printf(&quot;%d\n&quot;,p-&gt;data);
    } else
    {
        list *p = list1;
        printf(&quot;约瑟夫环当前数据为：\n&quot;);
        while (p-&gt;next!=list1)
        {
            printf(&quot;%d &quot;,p-&gt;data);
            p=p-&gt;next;
        }
        printf(&quot;%d\n&quot;,p-&gt;data);
    }
}

//具体的操作函数
void startTheGame(list *list1,int n,int m)
{
    if(m==0)//如果m为0，则无法进行游戏
    {
        printf(&quot;Invalid Index of m!\n&quot;);
    }
    else if(m%2==0)//如果操作序列为偶数，则逆时针游戏
    {
        list *p = list1;
        //当结点数不为0
        printf(&quot;按%d为步长的序列为:\n&quot;,m);
        for(int i=1;n!=0;i++)
        {
            if(i%m==0)
            {
                printf(&quot;%d &quot;,p-&gt;data);//打印结点数据
                list *temp = p;//中间保存被删除结点的临时结点
                p = p-&gt;front;//将操作指针移到上一位
                //将已经打印过的结点与链表断开
                p-&gt;next-&gt;next-&gt;front = p;
                p-&gt;next = p-&gt;next-&gt;next;
                //将临时结点值修改
                temp-&gt;data=0;
                temp-&gt;front=temp-&gt;next=NULL;
                free(temp);//释放被打印过的结点
                n--;
            }
            else//如果没有移到固定的步长m，则继续移动
            {
                p=p-&gt;front;
            }
        }
    }
    else//如果m为奇数，则顺时针开始
    {
        list *p = list1;//操作指针
        printf(&quot;按%d为步长的序列为:\n&quot;,m);
        for(int i=1;n!=0;i++)//循环
        {
            if(i%m==0)//如果移动次数为m
            {
                printf(&quot;%d &quot;,p-&gt;data);//打印此时的结点数据
                list *temp = p;//中间结点保存被打印的结点
                p=p-&gt;next;//操作指针移向下一个
                //将被打印的结点从链表中移除
                p-&gt;front-&gt;front-&gt;next=p;
                p-&gt;front=p-&gt;front-&gt;front;
                //修改被打印结点的数据
                temp-&gt;data=0;
                temp-&gt;front=temp-&gt;next=NULL;
                free(temp);//释放此结点
                n--;//减少结点总数
            }
            else//如果移动步数非m
            {
                p=p-&gt;next;//移动操作指针
            }
        }
    }
}

//创建链表并操作
list *createLink(int n,int m)//序列
{
    list *list1 = (list*)malloc(sizeof(list));//开辟空间
    if(!list1)//判断空间开辟是否成功
    {
        printf(&quot;Memory Error!\n&quot;);
        return NULL;
    }
    //初始化第一个结点
    list1-&gt;next=list1-&gt;front=NULL;
    list1-&gt;data = 1;

    list *p = list1;//操作指针
    for(int i=2;i&lt;=n;i++)//遍历赋值
    {
        list * temp = (list*)malloc(sizeof(list));//中间结点
        if(!temp)//判断结点空间开辟是否成功
        {
            printf(&quot;Memory Error!\n&quot;);
            return NULL;
        }
        temp-&gt;data = i;//序号赋值
        temp-&gt;next=NULL;//默认next为空
        temp-&gt;front = p;//前向指针指向当前p
        p-&gt;next=temp;//p的下一个接上中间结点
        p=p-&gt;next;//p移到中间结点上
    }
    list1-&gt;front=p;
    p-&gt;next=list1;//将尾结点next接到list1(头结点)上
    return list1;
}

//程序启动的函数
void Josephus()
{
    int n=0,m=0;
    printf(&quot;请输入约瑟夫序列:\n&quot;);
    printf(&quot;总人数n: &quot;);
    scanf(&quot;%d&quot;,&amp;n);
    printf(&quot;操作步长m: &quot;);
    scanf(&quot;%d&quot;,&amp;m);
    if(n&lt;1)
    {
        printf(&quot;Invalid People Number!\n&quot;);
    }
    else
    {
        if(m&lt;1)
        {
            printf(&quot;Invalid Index!\n&quot;);
        }
        else
        {
            list *list1 = createLink(n,m);
            display(list1,m);
            startTheGame(list1,n,m);
        }
    }
}
#endif //CLIONCODE_JOSEPHUS_H
</code></pre>
<ul>
<li>在调用时，main中</li>
</ul>
<pre><code class="language-c">#include &quot;Josephus.h&quot;
int main()
{
    Josephus();
    return 0;
}
</code></pre>
<ul>
<li>运行示例如下：<br>
<code>请输入约瑟夫序列:</code><br>
<code>总人数n: 7</code><br>
<code>操作步长m: 3</code><br>
<code>约瑟夫环当前数据为：</code><br>
<code>1 2 3 4 5 6 7</code><br>
<code>按3为步长的序列为:</code><br>
<code>3 6 2 7 5 1 4</code></li>
</ul>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[数据结构--顺序栈]]></title>
        <id>https://abelcorn.cn/post/stack</id>
        <link href="https://abelcorn.cn/post/stack">
        </link>
        <updated>2019-10-15T01:03:49.000Z</updated>
        <summary type="html"><![CDATA[<p>顺序栈将以四种语言呈现，但不会有太多注释，<s>毕竟比较简单</s></p>
]]></summary>
        <content type="html"><![CDATA[<p>顺序栈将以四种语言呈现，但不会有太多注释，<s>毕竟比较简单</s></p>
<!--more-->
<ul>
<li>C语言版本</li>
</ul>
<pre><code class="language-c">//@顺序栈 C语言版
// Created by abel on 2019/10/15.
//

#ifndef C_STACK_H
#define C_STACK_H

#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;stdbool.h&gt;
//默认的最大长度
#define SIZE 10
//结点
typedef struct Stack
{
    int *data;
    int top;
    int capacity;
}stack;

//创建链表
stack *createStack()
{
    stack *stack1 = (stack*)malloc(sizeof(stack));
    if(!stack1)//检查空间开辟情况
    {
        printf(&quot;Memory Error!\n&quot;);
        return NULL;
    }
    stack1-&gt;capacity = SIZE;//最大长度
    stack1-&gt;data = (int*)malloc(sizeof(int)*stack1-&gt;capacity);//开辟数组
    stack1-&gt;top=-1;//栈位置标志
    if(!stack1-&gt;data)
    {
        printf(&quot;Memory Error!\n&quot;);
        return NULL;
    }
    for(int i=0;i&lt;3;i++)//初始化赋值进去
    {
        stack1-&gt;data[i]=i+1;
    }
    stack1-&gt;top=2;//加两个
    return stack1;
}

//判断为空
bool isEmpty(stack *stack1)
{
    return (stack1-&gt;top==-1);
}

//判断为满
bool isFull(stack *stack1)
{
    return stack1-&gt;top==stack1-&gt;capacity-1;
}

//入栈
void push(stack * stack1,int elem)
{
    if(!isFull(stack1))
    {
        stack1-&gt;data[stack1-&gt;top+1]=elem;
        stack1-&gt;top++;
    } else
    {
        printf(&quot;Full\n&quot;);
    }
}
//出栈
int pop(stack* stack1)
{
    if(!isEmpty(stack1))
    {
        return stack1-&gt;data[stack1-&gt;top--];
    }
    printf(&quot;Error\n&quot;);
    return -1;
}

//得到栈顶元素
int getElem(stack *stack1)
{
    if(!isEmpty(stack1))
    {
        return stack1-&gt;data[stack1-&gt;top];
    }
    printf(&quot;Error\n&quot;);
    return -1;
}

//显示所有数据
void display(stack *stack1)
{
    if(!isEmpty(stack1))
    {
        for(int i=0;i&lt;=stack1-&gt;top;i++)
        {
            printf(&quot;%d &quot;,stack1-&gt;data[i]);
        }
        printf(&quot;\n&quot;);
    }
    else
    {
        printf(&quot;Empty\n&quot;);
        return;
    }
}
#endif //C_STACK_H
</code></pre>
<ul>
<li>C++版本</li>
</ul>
<pre><code class="language-c++">//@顺序栈 CPP版
// Created by abel on 2019/10/15.
//

#ifndef C___STACK_H
#define C___STACK_H

#include &lt;iostream&gt;
using namespace std;

const int SIZE = 10;
class Stack
{
private:
    int *data;
    int capacity;
    int top;
public:
    Stack()//创建栈
    {
        capacity = SIZE;
        data = new int[capacity];
        top=-1;
    }

    bool isEmpty();//栈空

    bool isFull();//栈满

    void push(int elem);//入栈

    int getElem();//得到最上面元素

    int pop();//出栈

    void display();//显示所以元素，做检查
};

bool Stack::isEmpty() {
    return top==-1;
}

bool Stack::isFull() {
    return top+1==capacity;
}

void Stack::push(int elem) {
    if(!isFull())
    {
        data[top+1]=elem;
        top++;
    }
    else
    {
        cout&lt;&lt;&quot;Full!&quot;&lt;&lt;endl;
    }
}

int Stack::getElem() {
    if(!isEmpty())
    {
        return data[top];
    } else
    {
        cout&lt;&lt;&quot;empty&quot;&lt;&lt;endl;
        return -1;
    }
}

int Stack::pop() {
    if(!isEmpty())
    {
        return data[top--];
    }
    else
    {
        cout&lt;&lt;&quot;empty&quot;&lt;&lt;endl;
        return -1;
    }
}

void Stack::display() {
    if(!isEmpty())
    {
        for(int i=0;i&lt;=top;i++)
        {
            cout&lt;&lt;data[i]&lt;&lt;&quot; &quot;;
        }
        cout&lt;&lt;endl;
    }
    else
    {
        cout&lt;&lt;&quot;Empty!\n&quot;;
        return;
    }
}
#endif //C___STACK_H
</code></pre>
<ul>
<li>Java版本</li>
</ul>
<pre><code class="language-java">//@顺序栈 Java版
//Created by abel on 2019/10/15.
//
public class Stack
{
	final int SIZE = 10;
	private int top;
	private int capacity;
	private int[] data;
	
	Stack()
	{
		this.capacity = SIZE;
		this.data = new int[capacity];
		this.top = -1;
	}
	
	public boolean isEmpty()
	{
		return (top==-1);
	}
	public boolean isFull()
	{
		return (top==capacity-1);
	}
	public void enlarge()
	{
		this.capacity *= 2;
		int []temp = new int[top+1];
		for(int i=0;i&lt;top;i++)
		{
			temp[i]=this.data[i];
		}
		this.data = new int[this.capacity];
		for(int i=0;i&lt;top;i++)
		{
			this.data[i] = temp[i];
		}
	}
	public void push(int elem)
	{
		if(!isFull())
		{
			data[top+1]=elem;
			top++;
		}
		else
		{
			System.out.println(&quot;Enlarge...&quot;);
			enlarge();
			data[top+1]=elem;
			top++;
		}
	}
	public int getElem()
	{
		if(!isEmpty())
		{
			return data[top];
		}
		else
		{
			System.out.println(&quot;Empty!&quot;);
			return -1;
		}
	}
	public int pop()
	{
		if(!isEmpty())
		{
			return data[top--];
		}
		else
		{
			System.out.println(&quot;Empty!&quot;);
			return -1;
		}
	}
}
</code></pre>
<ul>
<li>以下为C#版本</li>
</ul>
<pre><code class="language-c#">//@顺序栈 C#版
//Created by abel on 2019/10/15.
//

using System;

public class Stack
{
    const int SIZE = 10;
    private int capacity;
    private int top;
    private int[] data;

    public Stack()
    {
        this.capacity = SIZE;
        this.data = new int[capacity];
        this.top = -1;
    }

    public bool isEmpty()
    {
        return (top == -1);
    }
    public bool isFull()
    {
        return (top == capacity - 1);
    }
    public void push(int elem)
    {
        if(!isFull())
        {
            top++;
            data[top] = elem;
        }
        else
        {
            Console.WriteLine(&quot;Full!&quot;);
        }
    }
    public int getELem()
    {
        if(!isEmpty())
        {
            return data[top];
        }
        return -1;
    }
    public int pop()
    {
        if(isEmpty())
        {
            return data[top--];
        }
        return -1;
    }

    
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[数据结构--单链表]]></title>
        <id>https://abelcorn.cn/post/singlelink</id>
        <link href="https://abelcorn.cn/post/singlelink">
        </link>
        <updated>2019-10-14T13:45:44.000Z</updated>
        <summary type="html"><![CDATA[<p>没人看没人看，伤心😣<br>
本版为链表结构中的单链表。双向链表和循环链表将以实验--约瑟夫环的实际应用的方式呈现。</p>
]]></summary>
        <content type="html"><![CDATA[<p>没人看没人看，伤心😣<br>
本版为链表结构中的单链表。双向链表和循环链表将以实验--约瑟夫环的实际应用的方式呈现。</p>
<!--more-->
<ul>
<li>以下为C语言的单链表</li>
</ul>
<pre><code class="language-c">//@单链表 C语言版
// Created by abel on 2019/10/14.
//

#ifndef C_SINGLELINK_H
#define C_SINGLELINK_H

#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;stdbool.h&gt;

//单链表的基本结构
typedef struct Link
{
    int data;//数据域
    struct Link *next;//结点
}link;//新名字

//初始化创建链表
link *createLink()
{
    link *link1 = (link*)malloc(sizeof(link));//分配内存
    if(!link1)//检查内存分配成功情况
    {
        printf(&quot;Memory Error!\n&quot;);
        return NULL;
    }
    link1-&gt;data=0;//初始化
    link1-&gt;next=NULL;

    link *p = link1;
    for(int i=0;i&lt;3;i++)//为测试，给链表赋初始值
    {
        link *a = (link*)malloc(sizeof(link));
        a-&gt;data = i+1;
        a-&gt;next = NULL;

        p-&gt;next = a;
        p=p-&gt;next;
    }
    return link1;
}

//判断是否为空
bool isEmpty(link *link1)
{
    return (link1==NULL);
}

//插入元素
void insertElem(link *link1,int position,int elem)
{
    if(position&lt;1)//判断位置
    {
        printf(&quot;Error Position\n&quot;);
    }
    else
    {
        link *p = link1;
        for(int i=0;i&lt;position-1;i++)//遍历到要插入的位置处
        {
            if(p==NULL)
            {
                printf(&quot;Wrong Position\n&quot;);
                exit(-1);
            }
            p=p-&gt;next;
        }
        link *link2 = (link*)malloc(sizeof(link));
        if(!link2)
        {
            printf(&quot;Temp Link Memory Error!\n&quot;);
        }
        //插入结点
        else{
            link2-&gt;data = elem;
            link2-&gt;next = p-&gt;next;
            p-&gt;next = link2;
        }
    }
}

//删除元素
int deleteElem(link *link1,int position)
{
    if(!isEmpty(link1))//判断是否为空
    {
        if(position&lt;1)//判断位置
        {
            printf(&quot;Error Position\n&quot;);
            return -1;
        }
        else
        {
            link *p = link1;
            for(int i=0;i&lt;position-1;i++)//遍历到要删除的地方
            {
                if(p==NULL)
                {
                    printf(&quot;Error Position\n&quot;);
                    return -1;
                }
                p=p-&gt;next;
            }
            int data = p-&gt;next-&gt;data;//保存被删除的值
            link *temp = (link*)malloc(sizeof(link));
            temp-&gt;next = p-&gt;next;
            p-&gt;next=p-&gt;next-&gt;next;//重新链接链表
            free(temp);//释放被删除的结点
            return data;//返回数据
        }
    } else
    {
        printf(&quot;Empty Link\n&quot;);
        return -1;
    }
}

//查找元素第一次出现的位置
int find_position(link *link1,int elem)
{
    if(!isEmpty(link1))//判断非空
    {
        link *p = link1;
        for(int i=0;p!=NULL;i++)
        {
            p=p-&gt;next;
            if(elem == p-&gt;data)
            {
                return i+1;
            }

        }
    }
    else
    {
        return -2;
    }
    return 0;
}

//遍历显示全部信息
void display(link *link1)
{
    if(!isEmpty(link1))//判断空链
    {
        link *p = link1;
        while (p-&gt;next)
        {
            p=p-&gt;next;
            printf(&quot;%d &quot;,p-&gt;data);
        }
        printf(&quot;\n&quot;);
    } else
    {
        printf(&quot;Empty!\n&quot;);
    }
}


#endif //C_SINGLELINK_H
</code></pre>
<ul>
<li>以下为C++版本的单链表</li>
</ul>
<pre><code class="language-c++">//@单链表CPP版
// Created by abel on 2019/10/14.
//

#ifndef C___SINGLELINK_H
#define C___SINGLELINK_H

#include &lt;iostream&gt;
using namespace std;

typedef struct Node
{
    int data;
    Node *next;
}link;

class Link
{
private:
    link *link1;
public:
    //构造函数
    Link();
    //插入元素
    void insertElem(int position,int elem);
    //查看是否为空
    bool isEmpty();
    //得到固定位置的元素
    int getElem(int position);
    //删除元素
    int deleteElem(int position);
    //遍历显示全部元素
    void display();
};

Link::Link() {
    link1 = new link;
    link1-&gt;data = 0;
    link1-&gt;next = nullptr;
}

void Link::insertElem(int position, int elem) {
    if(position&lt;1)
    {
        cout&lt;&lt;&quot;Error Position&quot;&lt;&lt;endl;
    }
    else
    {
        link *p = link1;
        for(int i=0;i&lt;position-1;i++)
        {
            if(p-&gt;next== nullptr)
            {
                cout&lt;&lt;&quot;Error Position!&quot;&lt;&lt;endl;
            }
            p = p-&gt;next;
        }
        link *temp = new link;
        temp-&gt;data=elem;
        temp-&gt;next = p-&gt;next;
        p-&gt;next=temp;
    }
}

bool Link::isEmpty() {
    return (link1-&gt;next== nullptr);
}

int Link::getElem(int position) {
    if(!isEmpty())
    {
        if(position&lt;1)
        {
            cout&lt;&lt;&quot;Error Position!&quot;&lt;&lt;endl;
            return -1;
        }
        else
        {
            link *p = link1;
            for(int i=0;i&lt;position-1;i++)
            {
                if(p-&gt;next== nullptr)
                {
                    cout&lt;&lt;&quot;Error Position&quot;&lt;&lt;endl;
                    break;
                }
                else
                {
                    p=p-&gt;next;
                }
            }
            p=p-&gt;next;
            return p-&gt;data;
        }
    }
    else
    {
        cout&lt;&lt;&quot;Empty!&quot;&lt;&lt;endl;
        return -1;
    }
}

int Link::deleteElem(int position){
    if(!isEmpty())
    {
        if(position&lt;1)
        {
            cout&lt;&lt;&quot;Error Position&quot;&lt;&lt;endl;
            exit(-1);
        }
        else
        {
            link *p = link1;
            for(int i=0;i&lt;position-1;i++)
            {
                if(p-&gt;next == nullptr)
                {
                    cout&lt;&lt;&quot;Error Position&quot;;
                    break;
                }
                else
                {
                    p=p-&gt;next;
                }
            }
            link *temp = new link;
            temp-&gt;next = p-&gt;next;
            temp-&gt;data = p-&gt;next-&gt;data;
            p-&gt;next = p-&gt;next-&gt;next;
            int t = temp-&gt;data;
            delete temp;
            return t;
        }
    }
    else
    {
        cout&lt;&lt;&quot;Empty!&quot;&lt;&lt;endl;
        exit(-1);
    }
}

void Link::display() {
    if(!isEmpty())//判断是否为空
    {
        link * p = link1;
        while (p-&gt;next)
        {
            p=p-&gt;next;
            cout&lt;&lt;p-&gt;data&lt;&lt;&quot; &quot;;
        }
        cout&lt;&lt;endl;
    }
    else
    {
        cout&lt;&lt;&quot;Error! Empty!&quot;&lt;&lt;endl;
    }
}
#endif //C___SINGLELINK_H
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[数据结构--顺序表]]></title>
        <id>https://abelcorn.cn/post/table</id>
        <link href="https://abelcorn.cn/post/table">
        </link>
        <updated>2019-10-11T13:59:34.000Z</updated>
        <summary type="html"><![CDATA[<ul>
<li>由于我太穷了，买不起matlab，所以它试用期到了，我暂时不写matlab的专题了。</li>
<li>毕竟这学期在学数据结构，虽然只学C语言版的，但我想总是大同小异嘛，所以从现在开始我会同步自己的代码上来。PS：<s>实际上是担心写的代码没了，所以这样保险一点。</s></li>
<li>我会以<s>C、C++和Java三种语言写</s>新增C#，当然了，因为Java(和C#)是自学的，且截止今天我才学了两天，有问题的地方还望各位大佬指正。</li>
</ul>
]]></summary>
        <content type="html"><![CDATA[<ul>
<li>由于我太穷了，买不起matlab，所以它试用期到了，我暂时不写matlab的专题了。</li>
<li>毕竟这学期在学数据结构，虽然只学C语言版的，但我想总是大同小异嘛，所以从现在开始我会同步自己的代码上来。PS：<s>实际上是担心写的代码没了，所以这样保险一点。</s></li>
<li>我会以<s>C、C++和Java三种语言写</s>新增C#，当然了，因为Java(和C#)是自学的，且截止今天我才学了两天，有问题的地方还望各位大佬指正。</li>
</ul>
<!--more-->
<p>###顺序表-C语言版：</p>
<pre><code class="language-C">//@顺序表 C版本
// Created by abel on 2019/10/11.
//

#ifndef C_TABLE_H
#define C_TABLE_H

#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;stdbool.h&gt;

#define CAPACITY 10
//为表的容量做准备

//顺序表的结构体
typedef struct Table
{
    int *data;//表的存储数组，为简便表示设置为int
    int capacity;//表的最大容量
    int length;//表的当前长度
}table;

//创建表
table *createTable()
{
    table *table1 = (table*)malloc(sizeof(table));//生成表
    //判断开辟的表空间分配是否正常
    if(!table1)
    {
        printf(&quot;Table Memory Error!\n&quot;);
        return NULL;
    }
    table1-&gt;capacity = CAPACITY;//初始化表的容量
    table1-&gt;data = (int*)malloc(sizeof(int)*table1-&gt;capacity);//为数组开辟空间
    //判断空间开辟是否成功
    if(!table1-&gt;data)
    {
        printf(&quot;Data Memory Error!\n&quot;);
        return NULL;
    }
    table1-&gt;length=0;//初始化当前长度为0

    for(int i=0;i&lt;3;i++)//给初始化数据便于测试
    {
        table1-&gt;data[i]=i+1;
    }
    table1-&gt;length=3;
    return table1;//返回该表
}

//检查表是否为空
bool isEmpty(table *table1)
{
    if(table1-&gt;length==0)
    {
        return true;
    }
    return false;
}

//检查表是否为满
bool isFull(table *table1)
{
    if(table1-&gt;length == table1-&gt;capacity)
    {
        return true;
    }
    return false;
}

//扩容
bool enlargeTable(table *table1)
{
    table1-&gt;capacity *= 2;//先将最大容量乘2
    table1-&gt;data = realloc(table1-&gt;data, sizeof(int)*table1-&gt;capacity*2);//将data数组里面的内容重新扩展
    //检查扩容是否成功
    if(!table1-&gt;data)
    {
        return false;
    }
    return true;
}

//新增数据
void pushTable(table *table1,int position,int elem)//分别是表、位置和新增的元素
{
    if(!isFull(table1))//先判断表是否满了
    {
        if(position&lt;1||position&gt;table1-&gt;length)//判断插入位置是否有问题
        {
            printf(&quot;插入位置有误!\n&quot;);
            exit(-1);//退出
        }
        for(int i=table1-&gt;length;i&gt;=position-1;i--)//遍历将插入位置及之后的元素后移
        {
            table1-&gt;data[i]=table1-&gt;data[i-1];
        }
        table1-&gt;data[position-1]=elem;//插入元素
        table1-&gt;length++;//增加长度
        printf(&quot;元素 %d 新增成功!\n&quot;,elem);//打印成功消息
    }
    else
    {
        printf(&quot;空间不足，正在扩容......!\n&quot;);
        enlargeTable(table1);//扩大容量
        //以下功能同上
        if(position&lt;1||position&gt;table1-&gt;length)
        {
            printf(&quot;插入位置有误!\n&quot;);
            exit(-1);
        }
        for(int i=table1-&gt;length;i&gt;=position-1;i--)
        {
            table1-&gt;data[i]=table1-&gt;data[i-1];
        }
        table1-&gt;data[position-1]=elem;
        table1-&gt;length++;
        printf(&quot;元素 %d 新增成功!\n&quot;,elem);
    }
}

//删除数据
int popTable(table *table1,int position)//表、所要删除的位置
{
    if(!isEmpty(table1))//判断是否是空表
    {
        if(position&lt;1||position&gt;table1-&gt;length)//检查删除位置是否正确
        {
            printf(&quot;删除的位置有误!\n&quot;);
            exit(-2);
        }
        int delete_data = table1-&gt;data[position-1];//记录被删除的元素
        for(int i=position-1;i&lt;table1-&gt;length;i++)//循环前移元素
        {
            table1-&gt;data[i]=table1-&gt;data[i+1];
        }
        table1-&gt;length--;//减少一个长度记录
        printf(&quot;表中第 %d 号元素 %d 删除成功!\n&quot;,position,delete_data);//将所删除的元素显示出来
        return delete_data;//返回它
    }
    else
    {
        printf(&quot;表已经空了，你还删啥？\n&quot;);
        return -2;
    }
}

//修改数据
void changeTable(table *table1,int position,int new_elem)//表、修改元素的位置、新元素
{
    if(!isEmpty(table1))//先判断是否为空
    {
        if(position&lt;1||position&gt;table1-&gt;length)//判断位置是否有误
        {
            printf(&quot;位置有误！\n&quot;);
        }
        else
        {
            table1-&gt;data[position-1] = new_elem;//修改元素
        }
    }
    else//如果是空表
    {
        printf(&quot;空表，你改什么？\n&quot;);
    }
}

//查找元素第一次出现的位置
int find_position(table* table1,int elem)
{
    if(!isEmpty(table1))//检查是否为空
    {
        int  position= -1;//位置信息，默认为-1
        bool flag = false; //是否查到的标志
        for(int i=0;i&lt;table1-&gt;length;i++)
        {
            if(elem==table1-&gt;data[i])
            {
                position = i+1;//记录位置
                flag = true;//开关打开
            }
        }
        if(flag)//如果找到了
        {
            return position;//返回位置
        }
        else
        {
            return -1;//否则返回-1；
        }
    }
    else
    {
        return -1;//空表也返回-1
    }
}

//查找某个位置的元素
int find_value(table* table1,int position)
{
    if(!isEmpty(table1))//检查是否为空
    {
        if(position&lt;1||position&gt;table1-&gt;length)//检查位置,若有问题
        {
            printf(&quot;位置有误\n&quot;);
            abort();//终止程序
        }
        else//若位置正确
        {
            return table1-&gt;data[position-1];//返回该位置的元素
        }
    }
    else
    {
        printf(&quot;空表\n&quot;);
        abort();//终止程序
    }
}

//遍历打印出表中的所有数据
void displayTable(table *table1)
{
    if(!isEmpty(table1))//首先判断表是否为空
    {
        printf(&quot;该表的全部数据为：\n&quot;);
        for(int i=0;i&lt;table1-&gt;length;i++)//不为空则循环遍历
        {
            printf(&quot;%d &quot;,table1-&gt;data[i]);//打印数值
        }
        printf(&quot;\n&quot;);
    }
    else//若表为空
    {
        printf(&quot;表中无数据！\n&quot;);
    }
}

//删除表
void deleteTable(table *table1)
{
    table1-&gt;length=0;
    table1-&gt;capacity=0;
    free(table1-&gt;data);
    free(table1);
    //释放空间
}
#endif //C_TABLE_H
</code></pre>
<p>###顺序表-C++版本</p>
<pre><code class="language-C++">//@顺序表 CPP版本
// Created by abel on 2019/10/11.
//

#ifndef C___TABLE_H
#define C___TABLE_H

#include &lt;iostream&gt;
using namespace std;

const int CAPACITY = 10;//定义初始化最大容量

class Table//定义顺序表类
{
private:
    int *data;//简单int数据类型数组
    int capacity;//最大容量
    int length;//当前长度
public:
    Table()//构造函数
    {
        capacity = CAPACITY;//最大容量
        data = new int[capacity];//动态开辟空间
        length=0;//默认长度
        for (int i = 0; i &lt;3 ; i++)//初始化3个数据做测试
        {
            data[i]=i+1;
        }
        length=3;//当前长度为3
    }
    bool isEmpty();//判断是否为空
    bool isFull();//判断是否为满
    void enlarge();//扩容
    void push_back(int position,int elem);//插入数据
    int pop_back(int position);//弹出数据
    void change(int position,int new_elem);//修改元素
    int find_position(int elem);//查找元素第一次出现的位置
    int find_value(int position);//得到某个位置的元素
    void display();//打印所有数据
    void deleteTable();//删除表
};

//判断是否为空
bool Table::isEmpty() {
    return length==0;
}

//判断是否为满
bool Table::isFull() {
    return length==capacity;
}

//扩容
void Table::enlarge() {
    capacity *= 2;//将最大容量翻倍
    int *new_data = new int[length];//开辟一个临时中转的数组
    for(int i=0;i&lt;length;i++)//将原来的数组拷贝到中转数组中
    {
        new_data[i]=data[i];
    }
    data = new int[capacity*2];//给data扩容
    for(int i=0;i&lt;length;i++)//再将中转数组的数据还给data
    {
        data[i]=new_data[i];
    }
    delete [] new_data;//删除中转数组
    //以上实际实现了的无非是C语言的realloc()功能
}

//插入数据
void Table::push_back(int position, int elem) {
    if(!isFull())//检查是否满表
    {
        if(position&lt;1||position&gt;length)//检查位置是否有误
        {
            cout&lt;&lt;&quot;插入位置有误&quot;&lt;&lt;endl;
        }
        else
        {
            for(int i=length;i&gt;=position-1;i--)//遍历将插入位置的元素后移
            {
                data[i] = data[i-1];
            }
            data[position-1]=elem;//新增元素
            length++;//加大空间
            cout&lt;&lt;&quot;元素&quot;&lt;&lt;elem&lt;&lt;&quot;插入成功&quot;&lt;&lt;endl;
        }
    }
    else//表满了
    {
        cout&lt;&lt;&quot;扩容中...&quot;&lt;&lt;endl;
        enlarge();//扩容

        if(position&lt;1||position&gt;length)//检查位置是否有误
        {
            cout&lt;&lt;&quot;插入位置有误&quot;&lt;&lt;endl;
        }
        else
        {
            for(int i=length;i&gt;=position-1;i--)//遍历将插入位置的元素后移
            {
                data[i] = data[i-1];
            }
            data[position-1]=elem;//新增元素
            length++;//加大空间
            cout&lt;&lt;&quot;元素&quot;&lt;&lt;elem&lt;&lt;&quot;插入成功&quot;&lt;&lt;endl;
        }
    }
}

//弹出数据
int Table::pop_back(int position) {
    if(!isEmpty())//检查是否为空
    {
        if(position&lt;1||position&gt;length)//检查位置
        {
            cout&lt;&lt;&quot;删除位置有误\n&quot;;
        }
        else
        {
            int temp = data[position-1];//记录将要删除的元素
            for(int i=position-1;i&lt;length;i++)//将该元素后面的全部前移
            {
                data[i]=data[i+1];
            }
            length--;//减少一个当前长度
            return temp;//将删除的元素返回
        }
    }
    else{
        cout&lt;&lt;&quot;空表，无值&quot;;
        return -1;
    }
}

//修改元素
void Table::change(int position, int new_elem) {
    if(!isEmpty())//判断非空
    {
        if(position&lt;1||position&gt;length)//检查位置
        {
            cout&lt;&lt;&quot;输入的位置有误&quot;&lt;&lt;endl;
        }
        else
        {
            data[position-1]=new_elem;
            cout&lt;&lt;&quot;修改成功\n&quot;;
        }
    }
    else
    {
        cout&lt;&lt;&quot;空表，你改什么？\n&quot;;
    }
}

//查找元素第一次出现的位置
int Table::find_position(int elem) {
    if(!isEmpty())//判断非空
    {
        int position = -1;//默认位置为-1
        bool flag = false;//标志
        for(int i=0;i&lt;length;i++)//遍历查找
        {
            if(data[i]==elem)//如果找到了
            {
                flag = true;//标志设为真
                position = i+1;//记录当前位置
                break;//跳出循环
            }
        }
        if(flag)//如果标志为真，即找到了
        {
            return position;//则返回第一次出现的位置
        }
        else
        {
            return -1;//否则返回-1（因为位置没有-1，故表示没找到）
        }
    }
    else
    {
        cout&lt;&lt;&quot;空表，你找什么？&quot;&lt;&lt;endl;
        return -1;
    }
}

//得到某个位置的元素
int Table::find_value(int position) {
    if(!isEmpty())//判断非空
    {
        if(position&lt;1||position&gt;length)//检查位置
        {
            cout&lt;&lt;&quot;位置错误&quot;;
            abort();//终止程序
        }
        else//如果位置正确
        {
            return data[position-1];//返回该数值
        }
    }
    else
    {
        cout&lt;&lt;&quot;空表！&quot;&lt;&lt;endl;
        abort();//终止程序
    }
}

//删除表
void Table::deleteTable() {
    capacity=0;
    length=0;
    delete[] data;
}

//打印所有数据
void Table::display() {
    if(!isEmpty())//检查是否为空
    {
        for(int i=0;i&lt;length;i++)//循环遍历打印数据
        {
            cout&lt;&lt;data[i]&lt;&lt;&quot; &quot;;
        }
        cout&lt;&lt;endl;
    }
    else
    {
        cout&lt;&lt;&quot;啥都没得，不要display了&quot;&lt;&lt;endl;
    }
}

#endif //C___TABLE_H
</code></pre>
<p>###顺序表-Java版本</p>
<ul>
<li>我刚学两天不要怼我，且注释没有上面的详细。由于很多方法都一样，所以java的版本没有写那么详细</li>
</ul>
<pre><code class="language-Java">//@顺序表 Java版本
// Created by abel on 2019/10/11.
//
public class Table {
	final int CAPACITY = 10;//最大容量
	
	private int []data;//定义数组
	private int capacity;//最大容量
	private int length;//当前长度
	
	public Table()//构造函数
	{
		this.capacity = CAPACITY;
		this.data = new int[capacity];
		this.length = 0;
		for(int i=0;i&lt;3;i++)
		{
			data[i] = (int)(Math.random()*100);//初始进入3个随机数
		}
		length =3;
	}
	//判断是否为空
	boolean isEmpty()
	{
		return (length==0);
	}
	//判断是否为满
	boolean isFull()
	{
		return (length == capacity);
	}
	//插入元素
	void push_back(int position,int elem)
	{
		if(!isFull())
		{
			if(position&lt;1||position&gt;length)
			{
				System.out.println(&quot;位置错误&quot;);
			}
			else {
				for(int i=length;i&gt;position-1;i--)
				{
					data[i]=data[i-1];
				}
				data[position-1]=elem;
				length++;
				System.out.println(&quot;插入成功&quot;);
			}
		}
		else {
			System.out.println(&quot;表满了！&quot;);
		}
	}
	//弹出元素
	int pop_back(int position)
	{
		if(!isEmpty())
		{
			if(position&lt;1||position&gt;length)
			{
				System.out.println(&quot;位置有误&quot;);
				return -1;
			}
			else {
				int temp = data[position-1];
				for(int i=position-1;i&lt;length;i++)
				{
					data[i]=data[i+1];
				}
				length--;
				return temp;
			}
		}
		else {
			System.out.println(&quot;空表&quot;);
			return -1;
		}
	}
    //查找元素第一次出现的位置
	int find_position(int elem)
	{
		if(!isEmpty())
		{
			for(int i=0;i&lt;length;i++)
			{
				if(elem==data[i])
				{
					return (i+1);
				}
			}
			System.out.println(&quot;无该️元素&quot;);
			return -1;
		}
		else {
			System.out.println(&quot;空表&quot;);
			return -1;
		}
	}
	//显示所有元素
	void display()
	{
		if(!isEmpty())//检查是否为空
		{
			for(int i=0;i&lt;length;i++)
			{
				System.out.print(data[i]+&quot; &quot;);
			}
			System.out.println();
		}
		else {
			System.out.println(&quot;空表&quot;);
		}
	}
	//置空表
	void replace()
	{
		for(int i=0;i&lt;length;i++)
		{
			data[i]=0;
		}
		length=0;
	}
}
</code></pre>
<p>**以下是C#的语言写的，其实它和Java感觉都大同小异，当然，毕竟我是小白所以还没有比较大的差异化感觉</p>
<pre><code class="language-c#">//@顺序表 C#版本
// Created by abel on 2019/10/11.
//
    class Table//顺序表
{
    const int SIZE = 10;//初始最大容量
    private int capacity;//最大容量
    private int size;//当前大小
    private int[] data;//表空间

    public Table()//构造函数，创建表
    {
        capacity = SIZE;
        size = 3;
        data = new int[capacity];
        for(int i=0;i&lt;3;i++)
        {
            data[i] = i + 1;
        }
    }

    public bool isEmpty()//判断空
    {
        return (size == 0);
    }

    public bool isFull()//判断满
    {
        return (size == capacity);
    }


    public void enlarge()
    {
        int[] temp = new int[10];
        for(int i=0;i&lt;size;i++)
        {
            temp[i] = data[i];
        }

        capacity = capacity * 2;
        data = new int[capacity];
        for (int i = 0; i &lt; size; i++)
        {
            data[i] = temp[i];
        }

    }

    public void push_back(int position,int elem)//插入元素
    {
        if(!isFull())//判断满
        {
            if(position&lt;1||position&gt;size)//判断位置
            {
                Console.WriteLine(&quot;Wrong Position!&quot;);
            }
            else
            {
                for(int i=size;i&gt;=position-1;i--)//依次后移
                {
                    data[i] = data[i - 1];
                }
                data[position-1]=elem;
                size++;
            }
        }
        else
        {
            Console.WriteLine(&quot;Enlarge the Data...&quot;);
            enlarge();//扩容
            if (position &lt; 1 || position &gt; size)//判断位置
            {
                Console.WriteLine(&quot;Wrong Position!&quot;);
            }
            else
            {
                for (int i = size; i &gt;= position - 1; i--)//依次后移
                {
                    data[i] = data[i - 1];
                }
                data[position - 1] = elem;
                size++;
            }
        }
    }

    public int find_elem(int elem)//查找元素
    {
        if(!isEmpty())
        {
            for(int i=0;i&lt;size;i++)
            {
                if (elem == data[i])
                    return i + 1;
                return -1;
            }
        }
        Console.WriteLine(&quot;Empty Table&quot;);
        return -1;
    }

    public int pop_back(int position)
    {
        if (!isEmpty())
        {
            if (position &lt; 1 || position &gt; size)
            {
                return -1;
            }
            else
            {
                int temp = data[position - 1];
                for (int i = position - 1; i &lt; size-1; i++)
                {
                    data[i] = data[i + 1];
                }
                size--;
                return temp;
            }
        }
        else
        {
            Console.WriteLine(&quot;Empty!&quot;);
            return -1;
        }
    }

    public void display()//显示所有元素
    {
        for(int i =0;i&lt;size;i++)
        {
            Console.Write(&quot;{0} &quot;, data[i]);
        }
        Console.WriteLine();
    }
}
</code></pre>
]]></content>
    </entry>
</feed>