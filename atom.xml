<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://abelcorn.cn</id>
    <title>å°çŸ³çŸ³çŸ³</title>
    <updated>2019-10-25T01:56:34.992Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://abelcorn.cn"/>
    <link rel="self" href="https://abelcorn.cn/atom.xml"/>
    <subtitle>Always do your best.</subtitle>
    <logo>https://abelcorn.cn/images/avatar.png</logo>
    <icon>https://abelcorn.cn/favicon.ico</icon>
    <rights>All rights reserved 2019, å°çŸ³çŸ³çŸ³</rights>
    <entry>
        <title type="html"><![CDATA[æ•°æ®ç»“æ„å®éªŒ--åœ¨çº¿æµ‹è¯•æäº¤]]></title>
        <id>https://abelcorn.cn/post/dataexp-2</id>
        <link href="https://abelcorn.cn/post/dataexp-2">
        </link>
        <updated>2019-10-25T01:44:17.000Z</updated>
        <summary type="html"><![CDATA[<p>æœ¬æ¬¡æ˜¯é’ˆå¯¹å®éªŒä¸€ã€äºŒçš„åœ¨çº¿é¢˜ç›®ï¼ŒåŒ…æ‹¬ä¸‰é“é¢˜ï¼šåˆå¹¶å‡åºé“¾è¡¨ã€é˜Ÿåˆ—å…ƒç´ ç½®é€†å’Œæ‹¬å·åŒ¹é…é—®é¢˜ã€‚è‹¥æœ‰å†™çš„ä¸å¥½çš„åœ°æ–¹è¿˜è¯·æŒ‡æ­£ã€‚</p>
]]></summary>
        <content type="html"><![CDATA[<p>æœ¬æ¬¡æ˜¯é’ˆå¯¹å®éªŒä¸€ã€äºŒçš„åœ¨çº¿é¢˜ç›®ï¼ŒåŒ…æ‹¬ä¸‰é“é¢˜ï¼šåˆå¹¶å‡åºé“¾è¡¨ã€é˜Ÿåˆ—å…ƒç´ ç½®é€†å’Œæ‹¬å·åŒ¹é…é—®é¢˜ã€‚è‹¥æœ‰å†™çš„ä¸å¥½çš„åœ°æ–¹è¿˜è¯·æŒ‡æ­£ã€‚</p>
<!--more-->
<p><strong>1.åˆå¹¶é“¾è¡¨</strong>:</p>
<ul>
<li>ã€é—®é¢˜æè¿°ã€‘ ä¸¤ä¸ªéé™åºé“¾è¡¨çš„å¹¶é›†ï¼Œä¾‹å¦‚å°†é“¾è¡¨1-&gt;2-&gt;3 å’Œ 2-&gt;3-&gt;5 å¹¶ä¸º 1-&gt;2-&gt;3-&gt;5ï¼Œåªèƒ½è¾“å‡ºç»“æœï¼Œä¸èƒ½ä¿®æ”¹ä¸¤ä¸ªé“¾è¡¨çš„æ•°æ®ã€‚</li>
<li>ã€è¾“å…¥å½¢å¼ã€‘ ç¬¬ä¸€è¡Œä¸ºç¬¬ä¸€ä¸ªé“¾è¡¨çš„å„ç»“ç‚¹å€¼ï¼Œä»¥ç©ºæ ¼åˆ†éš”ã€‚ ç¬¬äºŒè¡Œä¸ºç¬¬äºŒä¸ªé“¾è¡¨çš„å„ç»“ç‚¹å€¼ï¼Œä»¥ç©ºæ ¼åˆ†éš”ã€‚</li>
<li>ã€è¾“å‡ºå½¢å¼ã€‘ åˆå¹¶å¥½çš„é“¾è¡¨ï¼Œä»¥éé™åºæ’åˆ—ï¼Œå€¼ä¸å€¼ä¹‹é—´ä»¥ç©ºæ ¼åˆ†éš”ã€‚</li>
<li>ã€æ ·ä¾‹è¾“å…¥ã€‘ 4 7 10 34 1 4 6 29 34 34 52</li>
<li>ã€æ ·ä¾‹è¾“å‡ºã€‘ 1 4 6 7 10 29 34 52</li>
<li>ã€è¯„åˆ†æ ‡å‡†ã€‘ è¦ä½¿ç”¨é“¾è¡¨å®ç°ï¼Œå¦åˆ™ä¸èƒ½å¾—åˆ†ã€‚</li>
</ul>
<pre><code class="language-c">//@åˆå¹¶é“¾è¡¨
// Created by abel on 2019/10/23.
//
#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;

typedef struct Node {
    int data;
    struct Node *next;
}list;
//è¾“å…¥å¹¶åˆ›å»ºä¸¤ä¸ªåˆå§‹é“¾è¡¨
void create(list *list1,list* list2)
{
    list *p1 = list1;
    list *p2 = list2;
    char ch1,ch2;
    int data;
    do
    {
        scanf(&quot;%d&quot;,&amp;data);
        list *temp;
        temp=(list*)malloc(sizeof(list));
        temp-&gt;next=0;
        temp-&gt;data=data;
        p1-&gt;next=temp;
        p1=p1-&gt;next;


    }while((ch1=getchar())!='\n');

    do
    {
        scanf(&quot;%d&quot;,&amp;data);
        list *temp;
        temp=(list*)malloc(sizeof(list));
        temp-&gt;next=0;
        temp-&gt;data=data;
        p2-&gt;next=temp;
        p2=p2-&gt;next;

    }while((ch2=getchar())!=EOF);
}
//æŒ‰å¤§å°åˆå¹¶é“¾è¡¨
void merge(list *list1,list* list2)
{
    list* p1=list1-&gt;next;
    list* p2=list2-&gt;next;
    list* p=list1;

    while(p1&amp;&amp;p2)
    {
        if(p1-&gt;data&lt;=p2-&gt;data)
        {
            p-&gt;next=p1;
            p=p-&gt;next;
            p1=p1-&gt;next;
        }
        else
        {
            p-&gt;next=p2;
            p=p2;
            p2=p2-&gt;next;
        }
    }
    if(p1)
    {
        p-&gt;next=p1;
    }
    else
    {
        p-&gt;next=p2;
    }
    free(list2);
}
//æ‰“å°é“¾è¡¨å…ƒç´ ï¼ˆæ— é‡å¤å€¼ï¼‰
void display(list *list1)
{
    list* p=list1-&gt;next;
    while(p-&gt;next)
    {
        if(p-&gt;data==p-&gt;next-&gt;data)
        {
            p=p-&gt;next;
        }
        else
        {
            printf(&quot;%d &quot;,p-&gt;data);
            p=p-&gt;next;
        }
    }printf(&quot;%d\n&quot;,p-&gt;data);
}

int main()
{
    list* list1;
    list* list2;
    list1=(list*)malloc(sizeof(list));
    list2=(list*)malloc(sizeof(list));
    list1-&gt;next=NULL;
    list2-&gt;next=NULL;

    create(list1,list2);
    merge(list1,list2);
    display(list1);
    return 0;
}
</code></pre>
<p>*<strong>2.é˜Ÿåˆ—ç½®é€†</strong>ï¼š</p>
<ul>
<li>ã€é—®é¢˜æè¿°ã€‘ å·²çŸ¥Qæ˜¯ä¸€ä¸ªéç©ºé˜Ÿåˆ—ï¼ŒSæ˜¯ä¸€ä¸ªç©ºæ ˆã€‚ä»…ä½¿ç”¨å°‘é‡å·¥ä½œå˜é‡ä»¥åŠå¯¹é˜Ÿåˆ—å’Œæ ˆçš„åŸºæœ¬æ“ä½œï¼Œç¼–å†™ä¸€ä¸ªç®—æ³•ï¼Œå°†é˜Ÿåˆ—Qä¸­çš„æ‰€æœ‰å…ƒç´ é€†ç½®ã€‚</li>
<li>ã€è¾“å…¥å½¢å¼ã€‘ è¾“å…¥çš„ç¬¬ä¸€è¡Œä¸ºé˜Ÿåˆ—å…ƒç´ ä¸ªæ•°ï¼Œç¬¬äºŒè¡Œä¸ºé˜Ÿåˆ—ä»é¦–è‡³å°¾çš„å…ƒç´ </li>
<li>ã€è¾“å‡ºå½¢å¼ã€‘ è¾“å‡ºé˜Ÿåˆ—çš„é€†ç½®</li>
<li>ã€æ ·ä¾‹è¾“å…¥ã€‘ 3 1 2 3</li>
<li>ã€æ ·ä¾‹è¾“å‡ºã€‘ 3 2 1</li>
<li>ã€è¯„åˆ†æ ‡å‡†ã€‘ éœ€é‡‡ç”¨é˜Ÿåˆ—ä¸æ ˆçš„çŸ¥è¯†ï¼Œå¦åˆ™ä¸èƒ½å¾—åˆ†</li>
</ul>
<pre><code class="language-c">//@é˜Ÿåˆ—å…ƒç´ ç½®é€†
// Created by abel on 2019/10/23.
//

#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;stdbool.h&gt;

//å»ºç«‹é˜Ÿåˆ—çš„åŸºæœ¬ç»“æ„
typedef struct Queue
{
    int *data;
    int size;
    int capacity;
    int front,rear;
}queue;

//å»ºç«‹æ ˆçš„åŸºæœ¬ç»“æ„
typedef struct Stack
{
    int *data;
    int top;
    int capacity;
}stack;

//åˆ›å»ºé˜Ÿåˆ—
queue *createQueue(int n)
{
    queue *queue1 = (queue*)malloc(sizeof(queue));
    if(!queue1)
    {
        printf(&quot;Memory Error!\n&quot;);
        return NULL;
    }

    queue1-&gt;capacity = n;
    queue1-&gt;data = (int*)malloc(sizeof(int)*queue1-&gt;capacity);
    queue1-&gt;front=queue1-&gt;rear=-1;
    queue1-&gt;size=0;

    return queue1;
}

//åˆ›å»ºæ ˆ
stack *createStack(int n)
{
    stack *stack1 = (stack*)malloc(sizeof(stack));
    if(!stack1)
    {
        printf(&quot;Memory Error!\n&quot;);
        return NULL;
    }
    stack1-&gt;capacity = n;
    stack1-&gt;data = (int*)malloc(sizeof(stack1-&gt;capacity));
    stack1-&gt;top=-1;

    return stack1;
}

//åˆ¤æ–­æ ˆç©º
bool emptyStack(stack *stack1)
{
    return stack1-&gt;top==-1;
}

//åˆ¤æ–­é˜Ÿç©º
bool emptyQueue(queue *queue1)
{
    return queue1-&gt;size==0;
}

//å…¥æ ˆ
void push(stack *stack1,int elem)
{
    stack1-&gt;top++;
    stack1-&gt;data[stack1-&gt;top]=elem;
}

//å‡ºæ ˆ
void pop(stack *stack1)
{
    if(!emptyStack(stack1))
    {
        printf(&quot;%d &quot;,stack1-&gt;data[stack1-&gt;top]);
        stack1-&gt;top--;
    }
    else
    {
        return;
    }
}

//å…¥é˜Ÿ
void enQueue(queue *queue1,int elem)
{
    queue1-&gt;front++;
    queue1-&gt;data[queue1-&gt;front]=elem;
    queue1-&gt;size++;
    if(queue1-&gt;rear==-1)
    {
        queue1-&gt;rear=0;
    }
}

//å‡ºé˜Ÿ
int deQueue(queue *queue1) {
    if(!emptyQueue(queue1))
    {
        queue1-&gt;size--;
        return queue1-&gt;data[queue1-&gt;rear++];
    }
}

int main()
{
    int n;
    scanf(&quot;%d&quot;,&amp;n);
    queue *queue1 = createQueue(n);
    stack *stack1 = createStack(n);

    int a[n];
    for(int i=0;i&lt;n;i++)
    {
        scanf(&quot;%d&quot;,&amp;a[i]);
    }
    for(int i=0;i&lt;n;i++)
    {
        enQueue(queue1,a[i]);
    }
    for(int i=0;i&lt;n;i++)
    {
        push(stack1,deQueue(queue1));
    }
    for(int i=0;i&lt;n;i++)
    {
        pop(stack1);
    }

    return 0;
}
</code></pre>
<p><strong>3.æ‹¬å·åŒ¹é…</strong>ï¼š</p>
<ul>
<li>ã€é—®é¢˜æè¿°ã€‘ å‡è®¾ä¸€ç®—æœ¯è¡¨è¾¾å¼ä¸­åŒ…æ‹¬ä¸‰ç§æ‹¬å·ï¼šåœ†æ‹¬å·â€œï¼ˆâ€å’Œâ€œï¼‰â€ï¼Œæ–¹æ‹¬å·â€œ[â€å’Œâ€œ]â€ï¼ŒèŠ±æ‹¬å·â€œ{â€å’Œâ€œ}â€ï¼Œä¸”ä¸‰ç§æ‹¬å·å¯æŒ‰æ„æ¬¡åºåµŒå¥—ä½¿ç”¨ï¼Œè¯•ç¼–å†™ç¨‹åºåˆ¤å®šè¾“å…¥çš„è¡¨è¾¾å¼æ‰€å«çš„æ‹¬å·æ˜¯å¦æ­£ç¡®é…å¯¹å‡ºç°ã€‚è‹¥åŒ¹é…ï¼Œåˆ™è¿”å›1ï¼Œå¦åˆ™è¿”å›0ã€‚</li>
<li>ã€è¾“å…¥å½¢å¼ã€‘ å«æ‹¬å·çš„ç®—æ•°è¡¨è¾¾å¼</li>
<li>ã€è¾“å‡ºå½¢å¼ã€‘ è‹¥è¡¨è¾¾å¼ä¸­çš„æ‹¬å·æ­£ç¡®é…å¯¹ï¼Œåˆ™è¾“å‡º1ã€‚å¦åˆ™ï¼Œè¾“å‡º0ã€‚</li>
<li>ã€æ ·ä¾‹è¾“å…¥ã€‘ 3+(44*[5-{6*[7*(45-10)]}])</li>
<li>ã€æ ·ä¾‹è¾“å‡ºã€‘ 1</li>
<li>ã€æ ·ä¾‹è¯´æ˜ã€‘ åˆ¤æ–­æ‹¬å·æ˜¯å¦åŒ¹é…æ¶‰åŠä¸¤æ–¹é¢çš„é—®é¢˜ï¼Œä¸€æ˜¯å¯¹å·¦å³æ‹¬å·çš„å‡ºç°æ¬¡æ•°çš„åˆ¤å®šï¼ŒäºŒæ˜¯å¯¹ä¸åŒæ‹¬å·çš„å‡ºç°æ¬¡åºçš„åˆ¤å®šã€‚</li>
</ul>
<pre><code class="language-c">//@æ‹¬å·åŒ¹é…
// Created by abel on 2019/10/23.
//


#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;stdbool.h&gt;


typedef struct Stack
{
    char *data;
    int capacity;
    int top;
}stack;

stack *createStack()
{
    stack *stack1 = (stack*)malloc(sizeof(stack));
    if(!stack1)
    {
        printf(&quot;Memory Error!\n&quot;);
        return NULL;
    }

    stack1-&gt;top=-1;
    stack1-&gt;capacity = 10;
    stack1-&gt;data = (char*)malloc(sizeof(char)*stack1-&gt;capacity);
    if(!stack1-&gt;data)
    {
        printf(&quot;Memory Error!\n&quot;);
        return NULL;
    }

    return stack1;
}

bool isFull(stack *stack1)
{
    return stack1-&gt;top==stack1-&gt;capacity-1;
}

bool isEmpty(stack *stack1)
{
    return stack1-&gt;top==-1;
}

void push(stack *stack1,char elem)
{
    if(!isFull(stack1))
    {
        stack1-&gt;top++;
        stack1-&gt;data[stack1-&gt;top]=elem;
    }
    else
    {
        stack1-&gt;capacity = stack1-&gt;capacity*2;
        stack1-&gt;data = realloc(stack1-&gt;data, sizeof(stack1-&gt;capacity));
        stack1-&gt;top++;
        stack1-&gt;data[stack1-&gt;top]=elem;
    }
}

char pop(stack *stack1)
{
    if(!isEmpty(stack1))
    {
        return stack1-&gt;data[stack1-&gt;top--];
    }
    else
    {
        return 0;
    }
}

int start()
{
    stack *stack1 = createStack();
    char ch;
    int flag = 0;
    while((ch=getchar())!='\n'&amp;&amp;ch!=EOF)
    {
        if((ch=='(')||(ch=='[')||(ch=='{'))
        {
            push(stack1,ch);

        }
        else if((ch==')')||(ch==']')||(ch=='}'))
        {
            char temp;
            switch (ch)
            {
                case ')':
                {
                    temp=pop(stack1);
                    if(temp=='(')
                    {
                        flag=1;
                        continue;
                    }
                    flag=0;
                    break;
                }
                case ']':
                {
                    temp = pop(stack1);
                    if(temp=='[')
                    {
                        flag=1;
                        continue;
                    }
                    flag=0;
                    break;
                }
                case '}':
                {
                    temp=pop(stack1);
                    if(temp=='{')
                    {
                        flag=1;
                        continue;
                    }
                    flag=0;
                    break;
                }
            }
        }
        else{flag=1;}
    }
    if (!isEmpty(stack1))
    {
        flag=0;
    }
    return flag;
}

int main()
{
    int a=0;
    a=start();
    printf(&quot;%d\n&quot;,a);

    return 0;
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[æ•°æ®ç»“æ„--å¾ªç¯é˜Ÿåˆ—]]></title>
        <id>https://abelcorn.cn/post/queue</id>
        <link href="https://abelcorn.cn/post/queue">
        </link>
        <updated>2019-10-19T02:38:26.000Z</updated>
        <summary type="html"><![CDATA[<p>ä¸€èˆ¬å¾ªç¯æ•°ç»„é˜Ÿåˆ—</p>
]]></summary>
        <content type="html"><![CDATA[<p>ä¸€èˆ¬å¾ªç¯æ•°ç»„é˜Ÿåˆ—</p>
<!--more-->
<p><strong>Cè¯­è¨€ç‰ˆ</strong>:</p>
<pre><code class="language-c">//@å¾ªç¯æ•°ç»„é˜Ÿåˆ— Cè¯­è¨€ç‰ˆ
// Created by abel on 2019/10/19.
//

#ifndef C_DATASTRUCTURES_QUEUE_H
#define C_DATASTRUCTURES_QUEUE_H

#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;stdbool.h&gt;

#define MAXSIZE 5//é»˜è®¤æœ€å¤§å®¹é‡

//é˜Ÿåˆ—çš„ç»“ç‚¹
typedef struct Queue
{
    int *data;//æ•°ç»„
    int capacity;//åˆå§‹å®¹é‡
    int front;//å¤´
    int rear;//å°¾
    int size;//è®¡æ•°
}queue;

//åˆ›å»ºé˜Ÿåˆ—
queue *createQueue()
{
    queue *queue1 = (queue*)malloc(sizeof(queue));//å¼€è¾Ÿé˜Ÿåˆ—ç©ºé—´
    if(!queue1)//æ£€æŸ¥é˜Ÿåˆ—ç©ºé—´å¼€è¾Ÿæ˜¯å¦æˆåŠŸ
    {
        printf(&quot;Memory Error\n&quot;);
        return NULL;
    }
    //åˆå§‹åŒ–é˜Ÿåˆ—
    queue1-&gt;capacity = MAXSIZE;
    queue1-&gt;data = (int*)malloc(sizeof(int)*queue1-&gt;capacity);
    if(!queue1-&gt;data)//ä¸ºå¾ªç¯æ•°ç»„å¼€è¾Ÿç©ºé—´
    {
        printf(&quot;Memory Error\n&quot;);
        return NULL;
    }
    //åˆå§‹åŒ–é˜Ÿåˆ—
    queue1-&gt;front=queue1-&gt;rear=-1;
    queue1-&gt;size=0;

    for(int i=0;i&lt;3;i++)//åˆå§‹åŒ–3ä¸ªæ•°æ®åšæµ‹è¯•
    {
        queue1-&gt;data[i]=i+1;
    }
    queue1-&gt;front=2;//å¤´ç´¢å¼•ç§»åŠ¨åˆ°2
    queue1-&gt;size=3;//è®¡æ•°
    return queue1;//å°†æ­¤é˜Ÿåˆ—è¿”å›
}

//åˆ¤æ–­æ˜¯å¦ä¸ºç©ºé˜Ÿåˆ—
bool isEmpty(queue *queue1)
{
    return queue1-&gt;size==0;
}

//åˆ¤æ–­æ˜¯å¦ä¸ºæ»¡é˜Ÿåˆ—
bool isFull(queue *queue1)
{
    return queue1-&gt;size==queue1-&gt;capacity;
}

//å…¥é˜Ÿ
void enQueue(queue *queue1,int elem)
{
    if(!isFull(queue1))//åˆ¤æ–­æ˜¯å¦æ»¡é˜Ÿ
    {
        queue1-&gt;front = (queue1-&gt;front+1)%queue1-&gt;capacity;//ç§»åŠ¨å½“å‰ä½ç½®
        queue1-&gt;data[queue1-&gt;front]=elem;//å­˜å…¥æ–°æ•°æ®
        queue1-&gt;size++;//è®¡æ•°å¢åŠ 
        if(queue1-&gt;rear==-1)
        {
            queue1-&gt;rear=0;
        }
    }
    else
    {
        printf(&quot;Full!\n&quot;);
    }
}
//å‡ºé˜Ÿ
void deQueue(queue *queue1)
{
    if(!isEmpty(queue1))//åˆ¤æ–­æ˜¯å¦ä¸ºç©º
    {
        printf(&quot;%d&quot;,queue1-&gt;data[queue1-&gt;rear]);//æ‰“å°æ­¤æ—¶çš„æ•°æ®
        queue1-&gt;rear=(queue1-&gt;rear+1)%queue1-&gt;capacity;
        queue1-&gt;size--;//å‡å°‘è®¡æ•°
    }
    else
    {
        printf(&quot;Empty!\n&quot;);
    }
}

#endif //C_DATASTRUCTURES_QUEUE_H
</code></pre>
<p><strong>C++ç‰ˆæœ¬</strong>:</p>
<pre><code class="language-c++">//@å¾ªç¯æ•°ç»„é˜Ÿåˆ— CPPç‰ˆ
// Created by abel on 2019/10/19.
//
#ifndef CPP_DATASTRUCTURES_QUEUE_H
#define CPP_DATASTRUCTURES_QUEUE_H

#include &lt;iostream&gt;
using namespace std;

const int MaxSize = 10;//é»˜è®¤æœ€å¤§é•¿åº¦

class Queue//é˜Ÿåˆ—ç±»
{
private:
    int *data;//å¾ªç¯æ•°ç»„
    int capacity;//æœ€å¤§å®¹é‡
    int front;
    int rear;
    int size;//è®¡æ•°
public:
    Queue()//æ„é€ å‡½æ•°
    {
        //åˆå§‹åŒ–ç±»
        capacity = MaxSize;
        data = new int[capacity];
        front=rear=-1;
        size=0;
    }
//    ~Queue()//ææ„å‡½æ•°
//    {
//        delete []data;
//    }
    //åˆ¤æ–­ä¸ºç©ºé˜Ÿåˆ—
    bool isEmpty()
    {
        return size==0;
    }
    //åˆ¤æ–­ä¸ºæ»¡é˜Ÿåˆ—
    bool isFull()
    {
        return size==capacity;
    }
    void enQueue(int elem);//å…¥é˜Ÿ
    void deQueue();//å‡ºé˜Ÿ
};

void Queue::enQueue(int elem) {
    if(!isFull())
    {
        front=(front+1)%capacity;
        data[front] = elem;
        size++;
        if(rear==-1)
        {
            rear=0;
        }
    }
    else
    {
        cout&lt;&lt;&quot;Full!&quot;&lt;&lt;endl;
    }
}

void Queue::deQueue() {
    if(!isEmpty())
    {
        cout&lt;&lt;data[rear]&lt;&lt;endl;
        rear = (rear+1)%capacity;
        size--;
    }
    else
    {
        cout&lt;&lt;&quot;Empty!&quot;&lt;&lt;endl;
    }
}

#endif //CPP_DATASTRUCTURES_QUEUE_H

</code></pre>
<p><strong>Javaç‰ˆæœ¬</strong>:</p>
<pre><code class="language-java">//@å¾ªç¯æ•°ç»„é˜Ÿåˆ— Javaç‰ˆ
// Created by abel on 2019/10/19.
//
public class Queue//é˜Ÿåˆ—ç±»
{
	final int MaxSize = 10;//é»˜è®¤åˆå§‹é•¿åº¦
	private int [] data;//å¾ªç¯æ•°ç»„
	private int capacity;//æœ€å¤§å®¹é‡
	private int front;
	private int rear;
	private int size;//è®¡æ•°
	//æ„é€ ä½“
	public Queue()
	{
		//åˆå§‹åŒ–é˜Ÿåˆ—
		this.capacity = MaxSize;
		this.data = new int[this.capacity];
		this.front=this.rear=-1;
		this.size=0;
	}
	//åˆ¤æ–­ä¸ºç©ºé˜Ÿåˆ—
	public boolean isEmpty()
	{
		return size==0;
	}
	//åˆ¤æ–­ä¸ºæ»¡é˜Ÿåˆ—
	public boolean isFull()
	{
		return size==this.capacity;
	}
	//å…¥é˜Ÿ
	public void enQueue(int elem)
	{
		if(!isFull())
		{
			this.front = (this.front+1)%this.capacity;
			data[this.front]=elem;
			this.size++;
			if(this.rear==-1)
			{
				this.rear=0;
			}
		}
		else
		{
			System.out.println(&quot;Full!&quot;);
		}
	}
	//å‡ºé˜Ÿ
	public void deQueue()
	{
		if(!isEmpty())
		{
			System.out.println(data[rear]);
			this.rear = (this.rear+1)%this.capacity;
			this.size--;
		}
		else
		{
			System.out.println(&quot;Empty!&quot;);
		}
	}
}
</code></pre>
<p><strong>C#ç‰ˆæœ¬</strong>ï¼š</p>
<pre><code class="language-c#">//@å¾ªç¯æ•°ç»„é˜Ÿåˆ— C#ç‰ˆ
// Created by abel on 2019/10/19.
//
using System;

public class Queue//é˜Ÿåˆ—çš„ç±»
{
    const int MAXSIZE = 10;//é»˜è®¤æœ€å¤§å®¹é‡
    private int size;//è®¡æ•°
    private int capacity;//æœ€å¤§å®¹é‡
    private int front;//
    private int rear;
    private int[] data;//å¾ªç¯æ•°ç»„
    //æ„é€ ä½“
    public Queue()
    {
        this.capacity = MAXSIZE;
        this.data = new int[capacity];
        this.front = this.rear = -1;
        this.size = 0;
        //åˆå§‹åŒ–æ‰€æœ‰ä¿¡æ¯
    }
    //åˆ¤æ–­ä¸ºç©ºé˜Ÿ
    public bool isEmpty()
    {
        return size == 0;
    }
    //åˆ¤æ–­ä¸ºæ»¡é˜Ÿ
    public bool isFull()
    {
        return size == capacity;
    }
    //å…¥é˜Ÿ
    public void enQueue(int elem)
    {
        if(!isFull())
        {
            front = (front + 1) % capacity;
            data[front] = elem;
            size++;
            if(rear==-1)
            {
                rear = 0;
            }
        }
        else
        {
            Console.WriteLine(&quot;Full!&quot;);
        }
    }
    public void deQueue()
    {
        if(!isEmpty())
        {
            Console.WriteLine(data[rear]);
            rear = (rear + 1) % capacity;
            size--;
        }
        else
        {
            Console.WriteLine(&quot;Empty!&quot;);
        }
    }
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[æ•°æ®ç»“æ„å®éªŒ--çº¦ç‘Ÿå¤«ç¯]]></title>
        <id>https://abelcorn.cn/post/datastructures_ex_josephus</id>
        <link href="https://abelcorn.cn/post/datastructures_ex_josephus">
        </link>
        <updated>2019-10-19T01:32:21.000Z</updated>
        <summary type="html"><![CDATA[<p>Josephusæ’åˆ—é—®é¢˜å®šä¹‰å¦‚ä¸‹ï¼šå‡è®¾nä¸ªç«èµ›è€…æ’æˆä¸€ä¸ªç¯å½¢ã€‚ç»™å®šä¸€ä¸ªæ­£æ•´æ•°mâ‰¤nï¼Œä»ç¬¬1äººå¼€å§‹ï¼Œæ²¿ç¯è®¡æ•°ï¼Œç¬¬mäººå‡ºåˆ—ã€‚è¿™ä¸ªè¿‡ç¨‹ä¸€ç›´è¿›è¡Œåˆ°æ‰€æœ‰äººéƒ½å‡ºåˆ—ä¸ºæ­¢ã€‚æœ€åå‡ºåˆ—è€…ä¸ºä¼˜èƒœè€…ã€‚å…¨éƒ¨å‡ºåˆ—æ¬¡åºå®šä¹‰äº†1ï¼Œ2ï¼Œâ€¦nçš„ä¸€ä¸ªæ’åˆ—ã€‚ç§°ä¸ºï¼ˆnï¼Œmï¼‰Josephusæ’åˆ—ã€‚ä¾‹å¦‚ï¼Œï¼ˆ7ï¼Œ3ï¼‰Josephusæ’åˆ—ä¸º3,6,2,7,5,1,4ã€‚ä¸”è‹¥mä¸ºå¶æ•°åˆ™é€†æ—¶é’ˆå¼€å§‹ï¼Œä¸ºå¥‡æ•°ä¸ºé¡ºæ—¶é’ˆã€‚</p>
]]></summary>
        <content type="html"><![CDATA[<p>Josephusæ’åˆ—é—®é¢˜å®šä¹‰å¦‚ä¸‹ï¼šå‡è®¾nä¸ªç«èµ›è€…æ’æˆä¸€ä¸ªç¯å½¢ã€‚ç»™å®šä¸€ä¸ªæ­£æ•´æ•°mâ‰¤nï¼Œä»ç¬¬1äººå¼€å§‹ï¼Œæ²¿ç¯è®¡æ•°ï¼Œç¬¬mäººå‡ºåˆ—ã€‚è¿™ä¸ªè¿‡ç¨‹ä¸€ç›´è¿›è¡Œåˆ°æ‰€æœ‰äººéƒ½å‡ºåˆ—ä¸ºæ­¢ã€‚æœ€åå‡ºåˆ—è€…ä¸ºä¼˜èƒœè€…ã€‚å…¨éƒ¨å‡ºåˆ—æ¬¡åºå®šä¹‰äº†1ï¼Œ2ï¼Œâ€¦nçš„ä¸€ä¸ªæ’åˆ—ã€‚ç§°ä¸ºï¼ˆnï¼Œmï¼‰Josephusæ’åˆ—ã€‚ä¾‹å¦‚ï¼Œï¼ˆ7ï¼Œ3ï¼‰Josephusæ’åˆ—ä¸º3,6,2,7,5,1,4ã€‚ä¸”è‹¥mä¸ºå¶æ•°åˆ™é€†æ—¶é’ˆå¼€å§‹ï¼Œä¸ºå¥‡æ•°ä¸ºé¡ºæ—¶é’ˆã€‚</p>
<!--more-->
<p><strong>Cè¯­è¨€</strong>ï¼š</p>
<pre><code class="language-c">//@çº¦ç‘Ÿå¤«ç¯ Cè¯­è¨€ç‰ˆæœ¬
// Created by abel on 2019/10/18.
//

#ifndef CLIONCODE_JOSEPHUS_H
#define CLIONCODE_JOSEPHUS_H

#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;stdbool.h&gt;

//çº¦ç‘Ÿå¤«ç¯ç»“ç‚¹
typedef struct Josephus
{
    int data;//æ¯ä¸ªç»“ç‚¹çš„æ•°æ®
    struct Josephus *front;//æŒ‡å‘å‰é©±
    struct Josephus *next;//æŒ‡å‘åç»§
}list;


//é¡ºåºæ‰“å°ä¸€æ¬¡
void display(list *list1,int m)
{
    if(m%2==0)
    {
        list *p = list1;
        printf(&quot;çº¦ç‘Ÿå¤«ç¯å½“å‰æ•°æ®ä¸ºï¼š\n&quot;);
        while (p-&gt;front!=list1)
        {
            printf(&quot;%d &quot;,p-&gt;data);
            p=p-&gt;front;
        }
        printf(&quot;%d\n&quot;,p-&gt;data);
    } else
    {
        list *p = list1;
        printf(&quot;çº¦ç‘Ÿå¤«ç¯å½“å‰æ•°æ®ä¸ºï¼š\n&quot;);
        while (p-&gt;next!=list1)
        {
            printf(&quot;%d &quot;,p-&gt;data);
            p=p-&gt;next;
        }
        printf(&quot;%d\n&quot;,p-&gt;data);
    }
}

//å…·ä½“çš„æ“ä½œå‡½æ•°
void startTheGame(list *list1,int n,int m)
{
    if(m==0)//å¦‚æœmä¸º0ï¼Œåˆ™æ— æ³•è¿›è¡Œæ¸¸æˆ
    {
        printf(&quot;Invalid Index of m!\n&quot;);
    }
    else if(m%2==0)//å¦‚æœæ“ä½œåºåˆ—ä¸ºå¶æ•°ï¼Œåˆ™é€†æ—¶é’ˆæ¸¸æˆ
    {
        list *p = list1;
        //å½“ç»“ç‚¹æ•°ä¸ä¸º0
        printf(&quot;æŒ‰%dä¸ºæ­¥é•¿çš„åºåˆ—ä¸º:\n&quot;,m);
        for(int i=1;n!=0;i++)
        {
            if(i%m==0)
            {
                printf(&quot;%d &quot;,p-&gt;data);//æ‰“å°ç»“ç‚¹æ•°æ®
                list *temp = p;//ä¸­é—´ä¿å­˜è¢«åˆ é™¤ç»“ç‚¹çš„ä¸´æ—¶ç»“ç‚¹
                p = p-&gt;front;//å°†æ“ä½œæŒ‡é’ˆç§»åˆ°ä¸Šä¸€ä½
                //å°†å·²ç»æ‰“å°è¿‡çš„ç»“ç‚¹ä¸é“¾è¡¨æ–­å¼€
                p-&gt;next-&gt;next-&gt;front = p;
                p-&gt;next = p-&gt;next-&gt;next;
                //å°†ä¸´æ—¶ç»“ç‚¹å€¼ä¿®æ”¹
                temp-&gt;data=0;
                temp-&gt;front=temp-&gt;next=NULL;
                free(temp);//é‡Šæ”¾è¢«æ‰“å°è¿‡çš„ç»“ç‚¹
                n--;
            }
            else//å¦‚æœæ²¡æœ‰ç§»åˆ°å›ºå®šçš„æ­¥é•¿mï¼Œåˆ™ç»§ç»­ç§»åŠ¨
            {
                p=p-&gt;front;
            }
        }
    }
    else//å¦‚æœmä¸ºå¥‡æ•°ï¼Œåˆ™é¡ºæ—¶é’ˆå¼€å§‹
    {
        list *p = list1;//æ“ä½œæŒ‡é’ˆ
        printf(&quot;æŒ‰%dä¸ºæ­¥é•¿çš„åºåˆ—ä¸º:\n&quot;,m);
        for(int i=1;n!=0;i++)//å¾ªç¯
        {
            if(i%m==0)//å¦‚æœç§»åŠ¨æ¬¡æ•°ä¸ºm
            {
                printf(&quot;%d &quot;,p-&gt;data);//æ‰“å°æ­¤æ—¶çš„ç»“ç‚¹æ•°æ®
                list *temp = p;//ä¸­é—´ç»“ç‚¹ä¿å­˜è¢«æ‰“å°çš„ç»“ç‚¹
                p=p-&gt;next;//æ“ä½œæŒ‡é’ˆç§»å‘ä¸‹ä¸€ä¸ª
                //å°†è¢«æ‰“å°çš„ç»“ç‚¹ä»é“¾è¡¨ä¸­ç§»é™¤
                p-&gt;front-&gt;front-&gt;next=p;
                p-&gt;front=p-&gt;front-&gt;front;
                //ä¿®æ”¹è¢«æ‰“å°ç»“ç‚¹çš„æ•°æ®
                temp-&gt;data=0;
                temp-&gt;front=temp-&gt;next=NULL;
                free(temp);//é‡Šæ”¾æ­¤ç»“ç‚¹
                n--;//å‡å°‘ç»“ç‚¹æ€»æ•°
            }
            else//å¦‚æœç§»åŠ¨æ­¥æ•°ém
            {
                p=p-&gt;next;//ç§»åŠ¨æ“ä½œæŒ‡é’ˆ
            }
        }
    }
}

//åˆ›å»ºé“¾è¡¨å¹¶æ“ä½œ
list *createLink(int n,int m)//åºåˆ—
{
    list *list1 = (list*)malloc(sizeof(list));//å¼€è¾Ÿç©ºé—´
    if(!list1)//åˆ¤æ–­ç©ºé—´å¼€è¾Ÿæ˜¯å¦æˆåŠŸ
    {
        printf(&quot;Memory Error!\n&quot;);
        return NULL;
    }
    //åˆå§‹åŒ–ç¬¬ä¸€ä¸ªç»“ç‚¹
    list1-&gt;next=list1-&gt;front=NULL;
    list1-&gt;data = 1;

    list *p = list1;//æ“ä½œæŒ‡é’ˆ
    for(int i=2;i&lt;=n;i++)//éå†èµ‹å€¼
    {
        list * temp = (list*)malloc(sizeof(list));//ä¸­é—´ç»“ç‚¹
        if(!temp)//åˆ¤æ–­ç»“ç‚¹ç©ºé—´å¼€è¾Ÿæ˜¯å¦æˆåŠŸ
        {
            printf(&quot;Memory Error!\n&quot;);
            return NULL;
        }
        temp-&gt;data = i;//åºå·èµ‹å€¼
        temp-&gt;next=NULL;//é»˜è®¤nextä¸ºç©º
        temp-&gt;front = p;//å‰å‘æŒ‡é’ˆæŒ‡å‘å½“å‰p
        p-&gt;next=temp;//pçš„ä¸‹ä¸€ä¸ªæ¥ä¸Šä¸­é—´ç»“ç‚¹
        p=p-&gt;next;//pç§»åˆ°ä¸­é—´ç»“ç‚¹ä¸Š
    }
    list1-&gt;front=p;
    p-&gt;next=list1;//å°†å°¾ç»“ç‚¹nextæ¥åˆ°list1(å¤´ç»“ç‚¹)ä¸Š
    return list1;
}

//ç¨‹åºå¯åŠ¨çš„å‡½æ•°
void Josephus()
{
    int n=0,m=0;
    printf(&quot;è¯·è¾“å…¥çº¦ç‘Ÿå¤«åºåˆ—:\n&quot;);
    printf(&quot;æ€»äººæ•°n: &quot;);
    scanf(&quot;%d&quot;,&amp;n);
    printf(&quot;æ“ä½œæ­¥é•¿m: &quot;);
    scanf(&quot;%d&quot;,&amp;m);
    if(n&lt;1)
    {
        printf(&quot;Invalid People Number!\n&quot;);
    }
    else
    {
        if(m&lt;1)
        {
            printf(&quot;Invalid Index!\n&quot;);
        }
        else
        {
            list *list1 = createLink(n,m);
            display(list1,m);
            startTheGame(list1,n,m);
        }
    }
}
#endif //CLIONCODE_JOSEPHUS_H
</code></pre>
<ul>
<li>åœ¨è°ƒç”¨æ—¶ï¼Œmainä¸­</li>
</ul>
<pre><code class="language-c">#include &quot;Josephus.h&quot;
int main()
{
    Josephus();
    return 0;
}
</code></pre>
<ul>
<li>è¿è¡Œç¤ºä¾‹å¦‚ä¸‹ï¼š<br>
<code>è¯·è¾“å…¥çº¦ç‘Ÿå¤«åºåˆ—:</code><br>
<code>æ€»äººæ•°n: 7</code><br>
<code>æ“ä½œæ­¥é•¿m: 3</code><br>
<code>çº¦ç‘Ÿå¤«ç¯å½“å‰æ•°æ®ä¸ºï¼š</code><br>
<code>1 2 3 4 5 6 7</code><br>
<code>æŒ‰3ä¸ºæ­¥é•¿çš„åºåˆ—ä¸º:</code><br>
<code>3 6 2 7 5 1 4</code></li>
</ul>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[æ•°æ®ç»“æ„--é¡ºåºæ ˆ]]></title>
        <id>https://abelcorn.cn/post/stack</id>
        <link href="https://abelcorn.cn/post/stack">
        </link>
        <updated>2019-10-15T01:03:49.000Z</updated>
        <summary type="html"><![CDATA[<p>é¡ºåºæ ˆå°†ä»¥å››ç§è¯­è¨€å‘ˆç°ï¼Œä½†ä¸ä¼šæœ‰å¤ªå¤šæ³¨é‡Šï¼Œ<s>æ¯•ç«Ÿæ¯”è¾ƒç®€å•</s></p>
]]></summary>
        <content type="html"><![CDATA[<p>é¡ºåºæ ˆå°†ä»¥å››ç§è¯­è¨€å‘ˆç°ï¼Œä½†ä¸ä¼šæœ‰å¤ªå¤šæ³¨é‡Šï¼Œ<s>æ¯•ç«Ÿæ¯”è¾ƒç®€å•</s></p>
<!--more-->
<ul>
<li>Cè¯­è¨€ç‰ˆæœ¬</li>
</ul>
<pre><code class="language-c">//@é¡ºåºæ ˆ Cè¯­è¨€ç‰ˆ
// Created by abel on 2019/10/15.
//

#ifndef C_STACK_H
#define C_STACK_H

#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;stdbool.h&gt;
//é»˜è®¤çš„æœ€å¤§é•¿åº¦
#define SIZE 10
//ç»“ç‚¹
typedef struct Stack
{
    int *data;
    int top;
    int capacity;
}stack;

//åˆ›å»ºé“¾è¡¨
stack *createStack()
{
    stack *stack1 = (stack*)malloc(sizeof(stack));
    if(!stack1)//æ£€æŸ¥ç©ºé—´å¼€è¾Ÿæƒ…å†µ
    {
        printf(&quot;Memory Error!\n&quot;);
        return NULL;
    }
    stack1-&gt;capacity = SIZE;//æœ€å¤§é•¿åº¦
    stack1-&gt;data = (int*)malloc(sizeof(int)*stack1-&gt;capacity);//å¼€è¾Ÿæ•°ç»„
    stack1-&gt;top=-1;//æ ˆä½ç½®æ ‡å¿—
    if(!stack1-&gt;data)
    {
        printf(&quot;Memory Error!\n&quot;);
        return NULL;
    }
    for(int i=0;i&lt;3;i++)//åˆå§‹åŒ–èµ‹å€¼è¿›å»
    {
        stack1-&gt;data[i]=i+1;
    }
    stack1-&gt;top=2;//åŠ ä¸¤ä¸ª
    return stack1;
}

//åˆ¤æ–­ä¸ºç©º
bool isEmpty(stack *stack1)
{
    return (stack1-&gt;top==-1);
}

//åˆ¤æ–­ä¸ºæ»¡
bool isFull(stack *stack1)
{
    return stack1-&gt;top==stack1-&gt;capacity-1;
}

//å…¥æ ˆ
void push(stack * stack1,int elem)
{
    if(!isFull(stack1))
    {
        stack1-&gt;data[stack1-&gt;top+1]=elem;
        stack1-&gt;top++;
    } else
    {
        printf(&quot;Full\n&quot;);
    }
}
//å‡ºæ ˆ
int pop(stack* stack1)
{
    if(!isEmpty(stack1))
    {
        return stack1-&gt;data[stack1-&gt;top--];
    }
    printf(&quot;Error\n&quot;);
    return -1;
}

//å¾—åˆ°æ ˆé¡¶å…ƒç´ 
int getElem(stack *stack1)
{
    if(!isEmpty(stack1))
    {
        return stack1-&gt;data[stack1-&gt;top];
    }
    printf(&quot;Error\n&quot;);
    return -1;
}

//æ˜¾ç¤ºæ‰€æœ‰æ•°æ®
void display(stack *stack1)
{
    if(!isEmpty(stack1))
    {
        for(int i=0;i&lt;=stack1-&gt;top;i++)
        {
            printf(&quot;%d &quot;,stack1-&gt;data[i]);
        }
        printf(&quot;\n&quot;);
    }
    else
    {
        printf(&quot;Empty\n&quot;);
        return;
    }
}
#endif //C_STACK_H
</code></pre>
<ul>
<li>C++ç‰ˆæœ¬</li>
</ul>
<pre><code class="language-c++">//@é¡ºåºæ ˆ CPPç‰ˆ
// Created by abel on 2019/10/15.
//

#ifndef C___STACK_H
#define C___STACK_H

#include &lt;iostream&gt;
using namespace std;

const int SIZE = 10;
class Stack
{
private:
    int *data;
    int capacity;
    int top;
public:
    Stack()//åˆ›å»ºæ ˆ
    {
        capacity = SIZE;
        data = new int[capacity];
        top=-1;
    }

    bool isEmpty();//æ ˆç©º

    bool isFull();//æ ˆæ»¡

    void push(int elem);//å…¥æ ˆ

    int getElem();//å¾—åˆ°æœ€ä¸Šé¢å…ƒç´ 

    int pop();//å‡ºæ ˆ

    void display();//æ˜¾ç¤ºæ‰€ä»¥å…ƒç´ ï¼Œåšæ£€æŸ¥
};

bool Stack::isEmpty() {
    return top==-1;
}

bool Stack::isFull() {
    return top+1==capacity;
}

void Stack::push(int elem) {
    if(!isFull())
    {
        data[top+1]=elem;
        top++;
    }
    else
    {
        cout&lt;&lt;&quot;Full!&quot;&lt;&lt;endl;
    }
}

int Stack::getElem() {
    if(!isEmpty())
    {
        return data[top];
    } else
    {
        cout&lt;&lt;&quot;empty&quot;&lt;&lt;endl;
        return -1;
    }
}

int Stack::pop() {
    if(!isEmpty())
    {
        return data[top--];
    }
    else
    {
        cout&lt;&lt;&quot;empty&quot;&lt;&lt;endl;
        return -1;
    }
}

void Stack::display() {
    if(!isEmpty())
    {
        for(int i=0;i&lt;=top;i++)
        {
            cout&lt;&lt;data[i]&lt;&lt;&quot; &quot;;
        }
        cout&lt;&lt;endl;
    }
    else
    {
        cout&lt;&lt;&quot;Empty!\n&quot;;
        return;
    }
}
#endif //C___STACK_H
</code></pre>
<ul>
<li>Javaç‰ˆæœ¬</li>
</ul>
<pre><code class="language-java">//@é¡ºåºæ ˆ Javaç‰ˆ
//Created by abel on 2019/10/15.
//
public class Stack
{
	final int SIZE = 10;
	private int top;
	private int capacity;
	private int[] data;
	
	Stack()
	{
		this.capacity = SIZE;
		this.data = new int[capacity];
		this.top = -1;
	}
	
	public boolean isEmpty()
	{
		return (top==-1);
	}
	public boolean isFull()
	{
		return (top==capacity-1);
	}
	public void enlarge()
	{
		this.capacity *= 2;
		int []temp = new int[top+1];
		for(int i=0;i&lt;top;i++)
		{
			temp[i]=this.data[i];
		}
		this.data = new int[this.capacity];
		for(int i=0;i&lt;top;i++)
		{
			this.data[i] = temp[i];
		}
	}
	public void push(int elem)
	{
		if(!isFull())
		{
			data[top+1]=elem;
			top++;
		}
		else
		{
			System.out.println(&quot;Enlarge...&quot;);
			enlarge();
			data[top+1]=elem;
			top++;
		}
	}
	public int getElem()
	{
		if(!isEmpty())
		{
			return data[top];
		}
		else
		{
			System.out.println(&quot;Empty!&quot;);
			return -1;
		}
	}
	public int pop()
	{
		if(!isEmpty())
		{
			return data[top--];
		}
		else
		{
			System.out.println(&quot;Empty!&quot;);
			return -1;
		}
	}
}
</code></pre>
<ul>
<li>ä»¥ä¸‹ä¸ºC#ç‰ˆæœ¬</li>
</ul>
<pre><code class="language-c#">//@é¡ºåºæ ˆ C#ç‰ˆ
//Created by abel on 2019/10/15.
//

using System;

public class Stack
{
    const int SIZE = 10;
    private int capacity;
    private int top;
    private int[] data;

    public Stack()
    {
        this.capacity = SIZE;
        this.data = new int[capacity];
        this.top = -1;
    }

    public bool isEmpty()
    {
        return (top == -1);
    }
    public bool isFull()
    {
        return (top == capacity - 1);
    }
    public void push(int elem)
    {
        if(!isFull())
        {
            top++;
            data[top] = elem;
        }
        else
        {
            Console.WriteLine(&quot;Full!&quot;);
        }
    }
    public int getELem()
    {
        if(!isEmpty())
        {
            return data[top];
        }
        return -1;
    }
    public int pop()
    {
        if(isEmpty())
        {
            return data[top--];
        }
        return -1;
    }

    
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[æ•°æ®ç»“æ„--å•é“¾è¡¨]]></title>
        <id>https://abelcorn.cn/post/singlelink</id>
        <link href="https://abelcorn.cn/post/singlelink">
        </link>
        <updated>2019-10-14T13:45:44.000Z</updated>
        <summary type="html"><![CDATA[<p>æ²¡äººçœ‹æ²¡äººçœ‹ï¼Œä¼¤å¿ƒğŸ˜£<br>
æœ¬ç‰ˆä¸ºé“¾è¡¨ç»“æ„ä¸­çš„å•é“¾è¡¨ã€‚åŒå‘é“¾è¡¨å’Œå¾ªç¯é“¾è¡¨å°†ä»¥å®éªŒ--çº¦ç‘Ÿå¤«ç¯çš„å®é™…åº”ç”¨çš„æ–¹å¼å‘ˆç°ã€‚</p>
]]></summary>
        <content type="html"><![CDATA[<p>æ²¡äººçœ‹æ²¡äººçœ‹ï¼Œä¼¤å¿ƒğŸ˜£<br>
æœ¬ç‰ˆä¸ºé“¾è¡¨ç»“æ„ä¸­çš„å•é“¾è¡¨ã€‚åŒå‘é“¾è¡¨å’Œå¾ªç¯é“¾è¡¨å°†ä»¥å®éªŒ--çº¦ç‘Ÿå¤«ç¯çš„å®é™…åº”ç”¨çš„æ–¹å¼å‘ˆç°ã€‚</p>
<!--more-->
<ul>
<li>ä»¥ä¸‹ä¸ºCè¯­è¨€çš„å•é“¾è¡¨</li>
</ul>
<pre><code class="language-c">//@å•é“¾è¡¨ Cè¯­è¨€ç‰ˆ
// Created by abel on 2019/10/14.
//

#ifndef C_SINGLELINK_H
#define C_SINGLELINK_H

#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;stdbool.h&gt;

//å•é“¾è¡¨çš„åŸºæœ¬ç»“æ„
typedef struct Link
{
    int data;//æ•°æ®åŸŸ
    struct Link *next;//ç»“ç‚¹
}link;//æ–°åå­—

//åˆå§‹åŒ–åˆ›å»ºé“¾è¡¨
link *createLink()
{
    link *link1 = (link*)malloc(sizeof(link));//åˆ†é…å†…å­˜
    if(!link1)//æ£€æŸ¥å†…å­˜åˆ†é…æˆåŠŸæƒ…å†µ
    {
        printf(&quot;Memory Error!\n&quot;);
        return NULL;
    }
    link1-&gt;data=0;//åˆå§‹åŒ–
    link1-&gt;next=NULL;

    link *p = link1;
    for(int i=0;i&lt;3;i++)//ä¸ºæµ‹è¯•ï¼Œç»™é“¾è¡¨èµ‹åˆå§‹å€¼
    {
        link *a = (link*)malloc(sizeof(link));
        a-&gt;data = i+1;
        a-&gt;next = NULL;

        p-&gt;next = a;
        p=p-&gt;next;
    }
    return link1;
}

//åˆ¤æ–­æ˜¯å¦ä¸ºç©º
bool isEmpty(link *link1)
{
    return (link1==NULL);
}

//æ’å…¥å…ƒç´ 
void insertElem(link *link1,int position,int elem)
{
    if(position&lt;1)//åˆ¤æ–­ä½ç½®
    {
        printf(&quot;Error Position\n&quot;);
    }
    else
    {
        link *p = link1;
        for(int i=0;i&lt;position-1;i++)//éå†åˆ°è¦æ’å…¥çš„ä½ç½®å¤„
        {
            if(p==NULL)
            {
                printf(&quot;Wrong Position\n&quot;);
                exit(-1);
            }
            p=p-&gt;next;
        }
        link *link2 = (link*)malloc(sizeof(link));
        if(!link2)
        {
            printf(&quot;Temp Link Memory Error!\n&quot;);
        }
        //æ’å…¥ç»“ç‚¹
        else{
            link2-&gt;data = elem;
            link2-&gt;next = p-&gt;next;
            p-&gt;next = link2;
        }
    }
}

//åˆ é™¤å…ƒç´ 
int deleteElem(link *link1,int position)
{
    if(!isEmpty(link1))//åˆ¤æ–­æ˜¯å¦ä¸ºç©º
    {
        if(position&lt;1)//åˆ¤æ–­ä½ç½®
        {
            printf(&quot;Error Position\n&quot;);
            return -1;
        }
        else
        {
            link *p = link1;
            for(int i=0;i&lt;position-1;i++)//éå†åˆ°è¦åˆ é™¤çš„åœ°æ–¹
            {
                if(p==NULL)
                {
                    printf(&quot;Error Position\n&quot;);
                    return -1;
                }
                p=p-&gt;next;
            }
            int data = p-&gt;next-&gt;data;//ä¿å­˜è¢«åˆ é™¤çš„å€¼
            link *temp = (link*)malloc(sizeof(link));
            temp-&gt;next = p-&gt;next;
            p-&gt;next=p-&gt;next-&gt;next;//é‡æ–°é“¾æ¥é“¾è¡¨
            free(temp);//é‡Šæ”¾è¢«åˆ é™¤çš„ç»“ç‚¹
            return data;//è¿”å›æ•°æ®
        }
    } else
    {
        printf(&quot;Empty Link\n&quot;);
        return -1;
    }
}

//æŸ¥æ‰¾å…ƒç´ ç¬¬ä¸€æ¬¡å‡ºç°çš„ä½ç½®
int find_position(link *link1,int elem)
{
    if(!isEmpty(link1))//åˆ¤æ–­éç©º
    {
        link *p = link1;
        for(int i=0;p!=NULL;i++)
        {
            p=p-&gt;next;
            if(elem == p-&gt;data)
            {
                return i+1;
            }

        }
    }
    else
    {
        return -2;
    }
    return 0;
}

//éå†æ˜¾ç¤ºå…¨éƒ¨ä¿¡æ¯
void display(link *link1)
{
    if(!isEmpty(link1))//åˆ¤æ–­ç©ºé“¾
    {
        link *p = link1;
        while (p-&gt;next)
        {
            p=p-&gt;next;
            printf(&quot;%d &quot;,p-&gt;data);
        }
        printf(&quot;\n&quot;);
    } else
    {
        printf(&quot;Empty!\n&quot;);
    }
}


#endif //C_SINGLELINK_H
</code></pre>
<ul>
<li>ä»¥ä¸‹ä¸ºC++ç‰ˆæœ¬çš„å•é“¾è¡¨</li>
</ul>
<pre><code class="language-c++">//@å•é“¾è¡¨CPPç‰ˆ
// Created by abel on 2019/10/14.
//

#ifndef C___SINGLELINK_H
#define C___SINGLELINK_H

#include &lt;iostream&gt;
using namespace std;

typedef struct Node
{
    int data;
    Node *next;
}link;

class Link
{
private:
    link *link1;
public:
    //æ„é€ å‡½æ•°
    Link();
    //æ’å…¥å…ƒç´ 
    void insertElem(int position,int elem);
    //æŸ¥çœ‹æ˜¯å¦ä¸ºç©º
    bool isEmpty();
    //å¾—åˆ°å›ºå®šä½ç½®çš„å…ƒç´ 
    int getElem(int position);
    //åˆ é™¤å…ƒç´ 
    int deleteElem(int position);
    //éå†æ˜¾ç¤ºå…¨éƒ¨å…ƒç´ 
    void display();
};

Link::Link() {
    link1 = new link;
    link1-&gt;data = 0;
    link1-&gt;next = nullptr;
}

void Link::insertElem(int position, int elem) {
    if(position&lt;1)
    {
        cout&lt;&lt;&quot;Error Position&quot;&lt;&lt;endl;
    }
    else
    {
        link *p = link1;
        for(int i=0;i&lt;position-1;i++)
        {
            if(p-&gt;next== nullptr)
            {
                cout&lt;&lt;&quot;Error Position!&quot;&lt;&lt;endl;
            }
            p = p-&gt;next;
        }
        link *temp = new link;
        temp-&gt;data=elem;
        temp-&gt;next = p-&gt;next;
        p-&gt;next=temp;
    }
}

bool Link::isEmpty() {
    return (link1-&gt;next== nullptr);
}

int Link::getElem(int position) {
    if(!isEmpty())
    {
        if(position&lt;1)
        {
            cout&lt;&lt;&quot;Error Position!&quot;&lt;&lt;endl;
            return -1;
        }
        else
        {
            link *p = link1;
            for(int i=0;i&lt;position-1;i++)
            {
                if(p-&gt;next== nullptr)
                {
                    cout&lt;&lt;&quot;Error Position&quot;&lt;&lt;endl;
                    break;
                }
                else
                {
                    p=p-&gt;next;
                }
            }
            p=p-&gt;next;
            return p-&gt;data;
        }
    }
    else
    {
        cout&lt;&lt;&quot;Empty!&quot;&lt;&lt;endl;
        return -1;
    }
}

int Link::deleteElem(int position){
    if(!isEmpty())
    {
        if(position&lt;1)
        {
            cout&lt;&lt;&quot;Error Position&quot;&lt;&lt;endl;
            exit(-1);
        }
        else
        {
            link *p = link1;
            for(int i=0;i&lt;position-1;i++)
            {
                if(p-&gt;next == nullptr)
                {
                    cout&lt;&lt;&quot;Error Position&quot;;
                    break;
                }
                else
                {
                    p=p-&gt;next;
                }
            }
            link *temp = new link;
            temp-&gt;next = p-&gt;next;
            temp-&gt;data = p-&gt;next-&gt;data;
            p-&gt;next = p-&gt;next-&gt;next;
            int t = temp-&gt;data;
            delete temp;
            return t;
        }
    }
    else
    {
        cout&lt;&lt;&quot;Empty!&quot;&lt;&lt;endl;
        exit(-1);
    }
}

void Link::display() {
    if(!isEmpty())//åˆ¤æ–­æ˜¯å¦ä¸ºç©º
    {
        link * p = link1;
        while (p-&gt;next)
        {
            p=p-&gt;next;
            cout&lt;&lt;p-&gt;data&lt;&lt;&quot; &quot;;
        }
        cout&lt;&lt;endl;
    }
    else
    {
        cout&lt;&lt;&quot;Error! Empty!&quot;&lt;&lt;endl;
    }
}
#endif //C___SINGLELINK_H
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[æ•°æ®ç»“æ„--é¡ºåºè¡¨]]></title>
        <id>https://abelcorn.cn/post/table</id>
        <link href="https://abelcorn.cn/post/table">
        </link>
        <updated>2019-10-11T13:59:34.000Z</updated>
        <summary type="html"><![CDATA[<ul>
<li>ç”±äºæˆ‘å¤ªç©·äº†ï¼Œä¹°ä¸èµ·matlabï¼Œæ‰€ä»¥å®ƒè¯•ç”¨æœŸåˆ°äº†ï¼Œæˆ‘æš‚æ—¶ä¸å†™matlabçš„ä¸“é¢˜äº†ã€‚</li>
<li>æ¯•ç«Ÿè¿™å­¦æœŸåœ¨å­¦æ•°æ®ç»“æ„ï¼Œè™½ç„¶åªå­¦Cè¯­è¨€ç‰ˆçš„ï¼Œä½†æˆ‘æƒ³æ€»æ˜¯å¤§åŒå°å¼‚å˜›ï¼Œæ‰€ä»¥ä»ç°åœ¨å¼€å§‹æˆ‘ä¼šåŒæ­¥è‡ªå·±çš„ä»£ç ä¸Šæ¥ã€‚PSï¼š<s>å®é™…ä¸Šæ˜¯æ‹…å¿ƒå†™çš„ä»£ç æ²¡äº†ï¼Œæ‰€ä»¥è¿™æ ·ä¿é™©ä¸€ç‚¹ã€‚</s></li>
<li>æˆ‘ä¼šä»¥<s>Cã€C++å’ŒJavaä¸‰ç§è¯­è¨€å†™</s>æ–°å¢C#ï¼Œå½“ç„¶äº†ï¼Œå› ä¸ºJava(å’ŒC#)æ˜¯è‡ªå­¦çš„ï¼Œä¸”æˆªæ­¢ä»Šå¤©æˆ‘æ‰å­¦äº†ä¸¤å¤©ï¼Œæœ‰é—®é¢˜çš„åœ°æ–¹è¿˜æœ›å„ä½å¤§ä½¬æŒ‡æ­£ã€‚</li>
</ul>
]]></summary>
        <content type="html"><![CDATA[<ul>
<li>ç”±äºæˆ‘å¤ªç©·äº†ï¼Œä¹°ä¸èµ·matlabï¼Œæ‰€ä»¥å®ƒè¯•ç”¨æœŸåˆ°äº†ï¼Œæˆ‘æš‚æ—¶ä¸å†™matlabçš„ä¸“é¢˜äº†ã€‚</li>
<li>æ¯•ç«Ÿè¿™å­¦æœŸåœ¨å­¦æ•°æ®ç»“æ„ï¼Œè™½ç„¶åªå­¦Cè¯­è¨€ç‰ˆçš„ï¼Œä½†æˆ‘æƒ³æ€»æ˜¯å¤§åŒå°å¼‚å˜›ï¼Œæ‰€ä»¥ä»ç°åœ¨å¼€å§‹æˆ‘ä¼šåŒæ­¥è‡ªå·±çš„ä»£ç ä¸Šæ¥ã€‚PSï¼š<s>å®é™…ä¸Šæ˜¯æ‹…å¿ƒå†™çš„ä»£ç æ²¡äº†ï¼Œæ‰€ä»¥è¿™æ ·ä¿é™©ä¸€ç‚¹ã€‚</s></li>
<li>æˆ‘ä¼šä»¥<s>Cã€C++å’ŒJavaä¸‰ç§è¯­è¨€å†™</s>æ–°å¢C#ï¼Œå½“ç„¶äº†ï¼Œå› ä¸ºJava(å’ŒC#)æ˜¯è‡ªå­¦çš„ï¼Œä¸”æˆªæ­¢ä»Šå¤©æˆ‘æ‰å­¦äº†ä¸¤å¤©ï¼Œæœ‰é—®é¢˜çš„åœ°æ–¹è¿˜æœ›å„ä½å¤§ä½¬æŒ‡æ­£ã€‚</li>
</ul>
<!--more-->
<p>###é¡ºåºè¡¨-Cè¯­è¨€ç‰ˆï¼š</p>
<pre><code class="language-C">//@é¡ºåºè¡¨ Cç‰ˆæœ¬
// Created by abel on 2019/10/11.
//

#ifndef C_TABLE_H
#define C_TABLE_H

#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;stdbool.h&gt;

#define CAPACITY 10
//ä¸ºè¡¨çš„å®¹é‡åšå‡†å¤‡

//é¡ºåºè¡¨çš„ç»“æ„ä½“
typedef struct Table
{
    int *data;//è¡¨çš„å­˜å‚¨æ•°ç»„ï¼Œä¸ºç®€ä¾¿è¡¨ç¤ºè®¾ç½®ä¸ºint
    int capacity;//è¡¨çš„æœ€å¤§å®¹é‡
    int length;//è¡¨çš„å½“å‰é•¿åº¦
}table;

//åˆ›å»ºè¡¨
table *createTable()
{
    table *table1 = (table*)malloc(sizeof(table));//ç”Ÿæˆè¡¨
    //åˆ¤æ–­å¼€è¾Ÿçš„è¡¨ç©ºé—´åˆ†é…æ˜¯å¦æ­£å¸¸
    if(!table1)
    {
        printf(&quot;Table Memory Error!\n&quot;);
        return NULL;
    }
    table1-&gt;capacity = CAPACITY;//åˆå§‹åŒ–è¡¨çš„å®¹é‡
    table1-&gt;data = (int*)malloc(sizeof(int)*table1-&gt;capacity);//ä¸ºæ•°ç»„å¼€è¾Ÿç©ºé—´
    //åˆ¤æ–­ç©ºé—´å¼€è¾Ÿæ˜¯å¦æˆåŠŸ
    if(!table1-&gt;data)
    {
        printf(&quot;Data Memory Error!\n&quot;);
        return NULL;
    }
    table1-&gt;length=0;//åˆå§‹åŒ–å½“å‰é•¿åº¦ä¸º0

    for(int i=0;i&lt;3;i++)//ç»™åˆå§‹åŒ–æ•°æ®ä¾¿äºæµ‹è¯•
    {
        table1-&gt;data[i]=i+1;
    }
    table1-&gt;length=3;
    return table1;//è¿”å›è¯¥è¡¨
}

//æ£€æŸ¥è¡¨æ˜¯å¦ä¸ºç©º
bool isEmpty(table *table1)
{
    if(table1-&gt;length==0)
    {
        return true;
    }
    return false;
}

//æ£€æŸ¥è¡¨æ˜¯å¦ä¸ºæ»¡
bool isFull(table *table1)
{
    if(table1-&gt;length == table1-&gt;capacity)
    {
        return true;
    }
    return false;
}

//æ‰©å®¹
bool enlargeTable(table *table1)
{
    table1-&gt;capacity *= 2;//å…ˆå°†æœ€å¤§å®¹é‡ä¹˜2
    table1-&gt;data = realloc(table1-&gt;data, sizeof(int)*table1-&gt;capacity*2);//å°†dataæ•°ç»„é‡Œé¢çš„å†…å®¹é‡æ–°æ‰©å±•
    //æ£€æŸ¥æ‰©å®¹æ˜¯å¦æˆåŠŸ
    if(!table1-&gt;data)
    {
        return false;
    }
    return true;
}

//æ–°å¢æ•°æ®
void pushTable(table *table1,int position,int elem)//åˆ†åˆ«æ˜¯è¡¨ã€ä½ç½®å’Œæ–°å¢çš„å…ƒç´ 
{
    if(!isFull(table1))//å…ˆåˆ¤æ–­è¡¨æ˜¯å¦æ»¡äº†
    {
        if(position&lt;1||position&gt;table1-&gt;length)//åˆ¤æ–­æ’å…¥ä½ç½®æ˜¯å¦æœ‰é—®é¢˜
        {
            printf(&quot;æ’å…¥ä½ç½®æœ‰è¯¯!\n&quot;);
            exit(-1);//é€€å‡º
        }
        for(int i=table1-&gt;length;i&gt;=position-1;i--)//éå†å°†æ’å…¥ä½ç½®åŠä¹‹åçš„å…ƒç´ åç§»
        {
            table1-&gt;data[i]=table1-&gt;data[i-1];
        }
        table1-&gt;data[position-1]=elem;//æ’å…¥å…ƒç´ 
        table1-&gt;length++;//å¢åŠ é•¿åº¦
        printf(&quot;å…ƒç´  %d æ–°å¢æˆåŠŸ!\n&quot;,elem);//æ‰“å°æˆåŠŸæ¶ˆæ¯
    }
    else
    {
        printf(&quot;ç©ºé—´ä¸è¶³ï¼Œæ­£åœ¨æ‰©å®¹......!\n&quot;);
        enlargeTable(table1);//æ‰©å¤§å®¹é‡
        //ä»¥ä¸‹åŠŸèƒ½åŒä¸Š
        if(position&lt;1||position&gt;table1-&gt;length)
        {
            printf(&quot;æ’å…¥ä½ç½®æœ‰è¯¯!\n&quot;);
            exit(-1);
        }
        for(int i=table1-&gt;length;i&gt;=position-1;i--)
        {
            table1-&gt;data[i]=table1-&gt;data[i-1];
        }
        table1-&gt;data[position-1]=elem;
        table1-&gt;length++;
        printf(&quot;å…ƒç´  %d æ–°å¢æˆåŠŸ!\n&quot;,elem);
    }
}

//åˆ é™¤æ•°æ®
int popTable(table *table1,int position)//è¡¨ã€æ‰€è¦åˆ é™¤çš„ä½ç½®
{
    if(!isEmpty(table1))//åˆ¤æ–­æ˜¯å¦æ˜¯ç©ºè¡¨
    {
        if(position&lt;1||position&gt;table1-&gt;length)//æ£€æŸ¥åˆ é™¤ä½ç½®æ˜¯å¦æ­£ç¡®
        {
            printf(&quot;åˆ é™¤çš„ä½ç½®æœ‰è¯¯!\n&quot;);
            exit(-2);
        }
        int delete_data = table1-&gt;data[position-1];//è®°å½•è¢«åˆ é™¤çš„å…ƒç´ 
        for(int i=position-1;i&lt;table1-&gt;length;i++)//å¾ªç¯å‰ç§»å…ƒç´ 
        {
            table1-&gt;data[i]=table1-&gt;data[i+1];
        }
        table1-&gt;length--;//å‡å°‘ä¸€ä¸ªé•¿åº¦è®°å½•
        printf(&quot;è¡¨ä¸­ç¬¬ %d å·å…ƒç´  %d åˆ é™¤æˆåŠŸ!\n&quot;,position,delete_data);//å°†æ‰€åˆ é™¤çš„å…ƒç´ æ˜¾ç¤ºå‡ºæ¥
        return delete_data;//è¿”å›å®ƒ
    }
    else
    {
        printf(&quot;è¡¨å·²ç»ç©ºäº†ï¼Œä½ è¿˜åˆ å•¥ï¼Ÿ\n&quot;);
        return -2;
    }
}

//ä¿®æ”¹æ•°æ®
void changeTable(table *table1,int position,int new_elem)//è¡¨ã€ä¿®æ”¹å…ƒç´ çš„ä½ç½®ã€æ–°å…ƒç´ 
{
    if(!isEmpty(table1))//å…ˆåˆ¤æ–­æ˜¯å¦ä¸ºç©º
    {
        if(position&lt;1||position&gt;table1-&gt;length)//åˆ¤æ–­ä½ç½®æ˜¯å¦æœ‰è¯¯
        {
            printf(&quot;ä½ç½®æœ‰è¯¯ï¼\n&quot;);
        }
        else
        {
            table1-&gt;data[position-1] = new_elem;//ä¿®æ”¹å…ƒç´ 
        }
    }
    else//å¦‚æœæ˜¯ç©ºè¡¨
    {
        printf(&quot;ç©ºè¡¨ï¼Œä½ æ”¹ä»€ä¹ˆï¼Ÿ\n&quot;);
    }
}

//æŸ¥æ‰¾å…ƒç´ ç¬¬ä¸€æ¬¡å‡ºç°çš„ä½ç½®
int find_position(table* table1,int elem)
{
    if(!isEmpty(table1))//æ£€æŸ¥æ˜¯å¦ä¸ºç©º
    {
        int  position= -1;//ä½ç½®ä¿¡æ¯ï¼Œé»˜è®¤ä¸º-1
        bool flag = false; //æ˜¯å¦æŸ¥åˆ°çš„æ ‡å¿—
        for(int i=0;i&lt;table1-&gt;length;i++)
        {
            if(elem==table1-&gt;data[i])
            {
                position = i+1;//è®°å½•ä½ç½®
                flag = true;//å¼€å…³æ‰“å¼€
            }
        }
        if(flag)//å¦‚æœæ‰¾åˆ°äº†
        {
            return position;//è¿”å›ä½ç½®
        }
        else
        {
            return -1;//å¦åˆ™è¿”å›-1ï¼›
        }
    }
    else
    {
        return -1;//ç©ºè¡¨ä¹Ÿè¿”å›-1
    }
}

//æŸ¥æ‰¾æŸä¸ªä½ç½®çš„å…ƒç´ 
int find_value(table* table1,int position)
{
    if(!isEmpty(table1))//æ£€æŸ¥æ˜¯å¦ä¸ºç©º
    {
        if(position&lt;1||position&gt;table1-&gt;length)//æ£€æŸ¥ä½ç½®,è‹¥æœ‰é—®é¢˜
        {
            printf(&quot;ä½ç½®æœ‰è¯¯\n&quot;);
            abort();//ç»ˆæ­¢ç¨‹åº
        }
        else//è‹¥ä½ç½®æ­£ç¡®
        {
            return table1-&gt;data[position-1];//è¿”å›è¯¥ä½ç½®çš„å…ƒç´ 
        }
    }
    else
    {
        printf(&quot;ç©ºè¡¨\n&quot;);
        abort();//ç»ˆæ­¢ç¨‹åº
    }
}

//éå†æ‰“å°å‡ºè¡¨ä¸­çš„æ‰€æœ‰æ•°æ®
void displayTable(table *table1)
{
    if(!isEmpty(table1))//é¦–å…ˆåˆ¤æ–­è¡¨æ˜¯å¦ä¸ºç©º
    {
        printf(&quot;è¯¥è¡¨çš„å…¨éƒ¨æ•°æ®ä¸ºï¼š\n&quot;);
        for(int i=0;i&lt;table1-&gt;length;i++)//ä¸ä¸ºç©ºåˆ™å¾ªç¯éå†
        {
            printf(&quot;%d &quot;,table1-&gt;data[i]);//æ‰“å°æ•°å€¼
        }
        printf(&quot;\n&quot;);
    }
    else//è‹¥è¡¨ä¸ºç©º
    {
        printf(&quot;è¡¨ä¸­æ— æ•°æ®ï¼\n&quot;);
    }
}

//åˆ é™¤è¡¨
void deleteTable(table *table1)
{
    table1-&gt;length=0;
    table1-&gt;capacity=0;
    free(table1-&gt;data);
    free(table1);
    //é‡Šæ”¾ç©ºé—´
}
#endif //C_TABLE_H
</code></pre>
<p>###é¡ºåºè¡¨-C++ç‰ˆæœ¬</p>
<pre><code class="language-C++">//@é¡ºåºè¡¨ CPPç‰ˆæœ¬
// Created by abel on 2019/10/11.
//

#ifndef C___TABLE_H
#define C___TABLE_H

#include &lt;iostream&gt;
using namespace std;

const int CAPACITY = 10;//å®šä¹‰åˆå§‹åŒ–æœ€å¤§å®¹é‡

class Table//å®šä¹‰é¡ºåºè¡¨ç±»
{
private:
    int *data;//ç®€å•intæ•°æ®ç±»å‹æ•°ç»„
    int capacity;//æœ€å¤§å®¹é‡
    int length;//å½“å‰é•¿åº¦
public:
    Table()//æ„é€ å‡½æ•°
    {
        capacity = CAPACITY;//æœ€å¤§å®¹é‡
        data = new int[capacity];//åŠ¨æ€å¼€è¾Ÿç©ºé—´
        length=0;//é»˜è®¤é•¿åº¦
        for (int i = 0; i &lt;3 ; i++)//åˆå§‹åŒ–3ä¸ªæ•°æ®åšæµ‹è¯•
        {
            data[i]=i+1;
        }
        length=3;//å½“å‰é•¿åº¦ä¸º3
    }
    bool isEmpty();//åˆ¤æ–­æ˜¯å¦ä¸ºç©º
    bool isFull();//åˆ¤æ–­æ˜¯å¦ä¸ºæ»¡
    void enlarge();//æ‰©å®¹
    void push_back(int position,int elem);//æ’å…¥æ•°æ®
    int pop_back(int position);//å¼¹å‡ºæ•°æ®
    void change(int position,int new_elem);//ä¿®æ”¹å…ƒç´ 
    int find_position(int elem);//æŸ¥æ‰¾å…ƒç´ ç¬¬ä¸€æ¬¡å‡ºç°çš„ä½ç½®
    int find_value(int position);//å¾—åˆ°æŸä¸ªä½ç½®çš„å…ƒç´ 
    void display();//æ‰“å°æ‰€æœ‰æ•°æ®
    void deleteTable();//åˆ é™¤è¡¨
};

//åˆ¤æ–­æ˜¯å¦ä¸ºç©º
bool Table::isEmpty() {
    return length==0;
}

//åˆ¤æ–­æ˜¯å¦ä¸ºæ»¡
bool Table::isFull() {
    return length==capacity;
}

//æ‰©å®¹
void Table::enlarge() {
    capacity *= 2;//å°†æœ€å¤§å®¹é‡ç¿»å€
    int *new_data = new int[length];//å¼€è¾Ÿä¸€ä¸ªä¸´æ—¶ä¸­è½¬çš„æ•°ç»„
    for(int i=0;i&lt;length;i++)//å°†åŸæ¥çš„æ•°ç»„æ‹·è´åˆ°ä¸­è½¬æ•°ç»„ä¸­
    {
        new_data[i]=data[i];
    }
    data = new int[capacity*2];//ç»™dataæ‰©å®¹
    for(int i=0;i&lt;length;i++)//å†å°†ä¸­è½¬æ•°ç»„çš„æ•°æ®è¿˜ç»™data
    {
        data[i]=new_data[i];
    }
    delete [] new_data;//åˆ é™¤ä¸­è½¬æ•°ç»„
    //ä»¥ä¸Šå®é™…å®ç°äº†çš„æ— éæ˜¯Cè¯­è¨€çš„realloc()åŠŸèƒ½
}

//æ’å…¥æ•°æ®
void Table::push_back(int position, int elem) {
    if(!isFull())//æ£€æŸ¥æ˜¯å¦æ»¡è¡¨
    {
        if(position&lt;1||position&gt;length)//æ£€æŸ¥ä½ç½®æ˜¯å¦æœ‰è¯¯
        {
            cout&lt;&lt;&quot;æ’å…¥ä½ç½®æœ‰è¯¯&quot;&lt;&lt;endl;
        }
        else
        {
            for(int i=length;i&gt;=position-1;i--)//éå†å°†æ’å…¥ä½ç½®çš„å…ƒç´ åç§»
            {
                data[i] = data[i-1];
            }
            data[position-1]=elem;//æ–°å¢å…ƒç´ 
            length++;//åŠ å¤§ç©ºé—´
            cout&lt;&lt;&quot;å…ƒç´ &quot;&lt;&lt;elem&lt;&lt;&quot;æ’å…¥æˆåŠŸ&quot;&lt;&lt;endl;
        }
    }
    else//è¡¨æ»¡äº†
    {
        cout&lt;&lt;&quot;æ‰©å®¹ä¸­...&quot;&lt;&lt;endl;
        enlarge();//æ‰©å®¹

        if(position&lt;1||position&gt;length)//æ£€æŸ¥ä½ç½®æ˜¯å¦æœ‰è¯¯
        {
            cout&lt;&lt;&quot;æ’å…¥ä½ç½®æœ‰è¯¯&quot;&lt;&lt;endl;
        }
        else
        {
            for(int i=length;i&gt;=position-1;i--)//éå†å°†æ’å…¥ä½ç½®çš„å…ƒç´ åç§»
            {
                data[i] = data[i-1];
            }
            data[position-1]=elem;//æ–°å¢å…ƒç´ 
            length++;//åŠ å¤§ç©ºé—´
            cout&lt;&lt;&quot;å…ƒç´ &quot;&lt;&lt;elem&lt;&lt;&quot;æ’å…¥æˆåŠŸ&quot;&lt;&lt;endl;
        }
    }
}

//å¼¹å‡ºæ•°æ®
int Table::pop_back(int position) {
    if(!isEmpty())//æ£€æŸ¥æ˜¯å¦ä¸ºç©º
    {
        if(position&lt;1||position&gt;length)//æ£€æŸ¥ä½ç½®
        {
            cout&lt;&lt;&quot;åˆ é™¤ä½ç½®æœ‰è¯¯\n&quot;;
        }
        else
        {
            int temp = data[position-1];//è®°å½•å°†è¦åˆ é™¤çš„å…ƒç´ 
            for(int i=position-1;i&lt;length;i++)//å°†è¯¥å…ƒç´ åé¢çš„å…¨éƒ¨å‰ç§»
            {
                data[i]=data[i+1];
            }
            length--;//å‡å°‘ä¸€ä¸ªå½“å‰é•¿åº¦
            return temp;//å°†åˆ é™¤çš„å…ƒç´ è¿”å›
        }
    }
    else{
        cout&lt;&lt;&quot;ç©ºè¡¨ï¼Œæ— å€¼&quot;;
        return -1;
    }
}

//ä¿®æ”¹å…ƒç´ 
void Table::change(int position, int new_elem) {
    if(!isEmpty())//åˆ¤æ–­éç©º
    {
        if(position&lt;1||position&gt;length)//æ£€æŸ¥ä½ç½®
        {
            cout&lt;&lt;&quot;è¾“å…¥çš„ä½ç½®æœ‰è¯¯&quot;&lt;&lt;endl;
        }
        else
        {
            data[position-1]=new_elem;
            cout&lt;&lt;&quot;ä¿®æ”¹æˆåŠŸ\n&quot;;
        }
    }
    else
    {
        cout&lt;&lt;&quot;ç©ºè¡¨ï¼Œä½ æ”¹ä»€ä¹ˆï¼Ÿ\n&quot;;
    }
}

//æŸ¥æ‰¾å…ƒç´ ç¬¬ä¸€æ¬¡å‡ºç°çš„ä½ç½®
int Table::find_position(int elem) {
    if(!isEmpty())//åˆ¤æ–­éç©º
    {
        int position = -1;//é»˜è®¤ä½ç½®ä¸º-1
        bool flag = false;//æ ‡å¿—
        for(int i=0;i&lt;length;i++)//éå†æŸ¥æ‰¾
        {
            if(data[i]==elem)//å¦‚æœæ‰¾åˆ°äº†
            {
                flag = true;//æ ‡å¿—è®¾ä¸ºçœŸ
                position = i+1;//è®°å½•å½“å‰ä½ç½®
                break;//è·³å‡ºå¾ªç¯
            }
        }
        if(flag)//å¦‚æœæ ‡å¿—ä¸ºçœŸï¼Œå³æ‰¾åˆ°äº†
        {
            return position;//åˆ™è¿”å›ç¬¬ä¸€æ¬¡å‡ºç°çš„ä½ç½®
        }
        else
        {
            return -1;//å¦åˆ™è¿”å›-1ï¼ˆå› ä¸ºä½ç½®æ²¡æœ‰-1ï¼Œæ•…è¡¨ç¤ºæ²¡æ‰¾åˆ°ï¼‰
        }
    }
    else
    {
        cout&lt;&lt;&quot;ç©ºè¡¨ï¼Œä½ æ‰¾ä»€ä¹ˆï¼Ÿ&quot;&lt;&lt;endl;
        return -1;
    }
}

//å¾—åˆ°æŸä¸ªä½ç½®çš„å…ƒç´ 
int Table::find_value(int position) {
    if(!isEmpty())//åˆ¤æ–­éç©º
    {
        if(position&lt;1||position&gt;length)//æ£€æŸ¥ä½ç½®
        {
            cout&lt;&lt;&quot;ä½ç½®é”™è¯¯&quot;;
            abort();//ç»ˆæ­¢ç¨‹åº
        }
        else//å¦‚æœä½ç½®æ­£ç¡®
        {
            return data[position-1];//è¿”å›è¯¥æ•°å€¼
        }
    }
    else
    {
        cout&lt;&lt;&quot;ç©ºè¡¨ï¼&quot;&lt;&lt;endl;
        abort();//ç»ˆæ­¢ç¨‹åº
    }
}

//åˆ é™¤è¡¨
void Table::deleteTable() {
    capacity=0;
    length=0;
    delete[] data;
}

//æ‰“å°æ‰€æœ‰æ•°æ®
void Table::display() {
    if(!isEmpty())//æ£€æŸ¥æ˜¯å¦ä¸ºç©º
    {
        for(int i=0;i&lt;length;i++)//å¾ªç¯éå†æ‰“å°æ•°æ®
        {
            cout&lt;&lt;data[i]&lt;&lt;&quot; &quot;;
        }
        cout&lt;&lt;endl;
    }
    else
    {
        cout&lt;&lt;&quot;å•¥éƒ½æ²¡å¾—ï¼Œä¸è¦displayäº†&quot;&lt;&lt;endl;
    }
}

#endif //C___TABLE_H
</code></pre>
<p>###é¡ºåºè¡¨-Javaç‰ˆæœ¬</p>
<ul>
<li>æˆ‘åˆšå­¦ä¸¤å¤©ä¸è¦æ€¼æˆ‘ï¼Œä¸”æ³¨é‡Šæ²¡æœ‰ä¸Šé¢çš„è¯¦ç»†ã€‚ç”±äºå¾ˆå¤šæ–¹æ³•éƒ½ä¸€æ ·ï¼Œæ‰€ä»¥javaçš„ç‰ˆæœ¬æ²¡æœ‰å†™é‚£ä¹ˆè¯¦ç»†</li>
</ul>
<pre><code class="language-Java">//@é¡ºåºè¡¨ Javaç‰ˆæœ¬
// Created by abel on 2019/10/11.
//
public class Table {
	final int CAPACITY = 10;//æœ€å¤§å®¹é‡
	
	private int []data;//å®šä¹‰æ•°ç»„
	private int capacity;//æœ€å¤§å®¹é‡
	private int length;//å½“å‰é•¿åº¦
	
	public Table()//æ„é€ å‡½æ•°
	{
		this.capacity = CAPACITY;
		this.data = new int[capacity];
		this.length = 0;
		for(int i=0;i&lt;3;i++)
		{
			data[i] = (int)(Math.random()*100);//åˆå§‹è¿›å…¥3ä¸ªéšæœºæ•°
		}
		length =3;
	}
	//åˆ¤æ–­æ˜¯å¦ä¸ºç©º
	boolean isEmpty()
	{
		return (length==0);
	}
	//åˆ¤æ–­æ˜¯å¦ä¸ºæ»¡
	boolean isFull()
	{
		return (length == capacity);
	}
	//æ’å…¥å…ƒç´ 
	void push_back(int position,int elem)
	{
		if(!isFull())
		{
			if(position&lt;1||position&gt;length)
			{
				System.out.println(&quot;ä½ç½®é”™è¯¯&quot;);
			}
			else {
				for(int i=length;i&gt;position-1;i--)
				{
					data[i]=data[i-1];
				}
				data[position-1]=elem;
				length++;
				System.out.println(&quot;æ’å…¥æˆåŠŸ&quot;);
			}
		}
		else {
			System.out.println(&quot;è¡¨æ»¡äº†ï¼&quot;);
		}
	}
	//å¼¹å‡ºå…ƒç´ 
	int pop_back(int position)
	{
		if(!isEmpty())
		{
			if(position&lt;1||position&gt;length)
			{
				System.out.println(&quot;ä½ç½®æœ‰è¯¯&quot;);
				return -1;
			}
			else {
				int temp = data[position-1];
				for(int i=position-1;i&lt;length;i++)
				{
					data[i]=data[i+1];
				}
				length--;
				return temp;
			}
		}
		else {
			System.out.println(&quot;ç©ºè¡¨&quot;);
			return -1;
		}
	}
    //æŸ¥æ‰¾å…ƒç´ ç¬¬ä¸€æ¬¡å‡ºç°çš„ä½ç½®
	int find_position(int elem)
	{
		if(!isEmpty())
		{
			for(int i=0;i&lt;length;i++)
			{
				if(elem==data[i])
				{
					return (i+1);
				}
			}
			System.out.println(&quot;æ— è¯¥ï¸å…ƒç´ &quot;);
			return -1;
		}
		else {
			System.out.println(&quot;ç©ºè¡¨&quot;);
			return -1;
		}
	}
	//æ˜¾ç¤ºæ‰€æœ‰å…ƒç´ 
	void display()
	{
		if(!isEmpty())//æ£€æŸ¥æ˜¯å¦ä¸ºç©º
		{
			for(int i=0;i&lt;length;i++)
			{
				System.out.print(data[i]+&quot; &quot;);
			}
			System.out.println();
		}
		else {
			System.out.println(&quot;ç©ºè¡¨&quot;);
		}
	}
	//ç½®ç©ºè¡¨
	void replace()
	{
		for(int i=0;i&lt;length;i++)
		{
			data[i]=0;
		}
		length=0;
	}
}
</code></pre>
<p>**ä»¥ä¸‹æ˜¯C#çš„è¯­è¨€å†™çš„ï¼Œå…¶å®å®ƒå’ŒJavaæ„Ÿè§‰éƒ½å¤§åŒå°å¼‚ï¼Œå½“ç„¶ï¼Œæ¯•ç«Ÿæˆ‘æ˜¯å°ç™½æ‰€ä»¥è¿˜æ²¡æœ‰æ¯”è¾ƒå¤§çš„å·®å¼‚åŒ–æ„Ÿè§‰</p>
<pre><code class="language-c#">//@é¡ºåºè¡¨ C#ç‰ˆæœ¬
// Created by abel on 2019/10/11.
//
    class Table//é¡ºåºè¡¨
{
    const int SIZE = 10;//åˆå§‹æœ€å¤§å®¹é‡
    private int capacity;//æœ€å¤§å®¹é‡
    private int size;//å½“å‰å¤§å°
    private int[] data;//è¡¨ç©ºé—´

    public Table()//æ„é€ å‡½æ•°ï¼Œåˆ›å»ºè¡¨
    {
        capacity = SIZE;
        size = 3;
        data = new int[capacity];
        for(int i=0;i&lt;3;i++)
        {
            data[i] = i + 1;
        }
    }

    public bool isEmpty()//åˆ¤æ–­ç©º
    {
        return (size == 0);
    }

    public bool isFull()//åˆ¤æ–­æ»¡
    {
        return (size == capacity);
    }


    public void enlarge()
    {
        int[] temp = new int[10];
        for(int i=0;i&lt;size;i++)
        {
            temp[i] = data[i];
        }

        capacity = capacity * 2;
        data = new int[capacity];
        for (int i = 0; i &lt; size; i++)
        {
            data[i] = temp[i];
        }

    }

    public void push_back(int position,int elem)//æ’å…¥å…ƒç´ 
    {
        if(!isFull())//åˆ¤æ–­æ»¡
        {
            if(position&lt;1||position&gt;size)//åˆ¤æ–­ä½ç½®
            {
                Console.WriteLine(&quot;Wrong Position!&quot;);
            }
            else
            {
                for(int i=size;i&gt;=position-1;i--)//ä¾æ¬¡åç§»
                {
                    data[i] = data[i - 1];
                }
                data[position-1]=elem;
                size++;
            }
        }
        else
        {
            Console.WriteLine(&quot;Enlarge the Data...&quot;);
            enlarge();//æ‰©å®¹
            if (position &lt; 1 || position &gt; size)//åˆ¤æ–­ä½ç½®
            {
                Console.WriteLine(&quot;Wrong Position!&quot;);
            }
            else
            {
                for (int i = size; i &gt;= position - 1; i--)//ä¾æ¬¡åç§»
                {
                    data[i] = data[i - 1];
                }
                data[position - 1] = elem;
                size++;
            }
        }
    }

    public int find_elem(int elem)//æŸ¥æ‰¾å…ƒç´ 
    {
        if(!isEmpty())
        {
            for(int i=0;i&lt;size;i++)
            {
                if (elem == data[i])
                    return i + 1;
                return -1;
            }
        }
        Console.WriteLine(&quot;Empty Table&quot;);
        return -1;
    }

    public int pop_back(int position)
    {
        if (!isEmpty())
        {
            if (position &lt; 1 || position &gt; size)
            {
                return -1;
            }
            else
            {
                int temp = data[position - 1];
                for (int i = position - 1; i &lt; size-1; i++)
                {
                    data[i] = data[i + 1];
                }
                size--;
                return temp;
            }
        }
        else
        {
            Console.WriteLine(&quot;Empty!&quot;);
            return -1;
        }
    }

    public void display()//æ˜¾ç¤ºæ‰€æœ‰å…ƒç´ 
    {
        for(int i =0;i&lt;size;i++)
        {
            Console.Write(&quot;{0} &quot;, data[i]);
        }
        Console.WriteLine();
    }
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Decir algo]]></title>
        <id>https://abelcorn.cn/post/unexpectedtrip</id>
        <link href="https://abelcorn.cn/post/unexpectedtrip">
        </link>
        <updated>2019-10-06T13:00:00.000Z</updated>
        <summary type="html"><![CDATA[<ul>
<li>ä»»ç”±æµ·é£å¹æ‹‚ï¼Œå¿ƒé‡Œå´æœªæ›¾æ„Ÿæ¿€è¿‡è¿™æ— èŠçš„å’¸æ¶©ã€‚æƒ³æ¥å­¤ç‹¬çš„å†ç¨‹å·²é€¾8æœˆï¼Œå´ä¸æ¯«æ²¡æœ‰å¿˜å´æ˜”æ—¥çš„æ„‰æ‚¦å’Œæ‡Šæ¼ã€‚</li>
</ul>
]]></summary>
        <content type="html"><![CDATA[<ul>
<li>ä»»ç”±æµ·é£å¹æ‹‚ï¼Œå¿ƒé‡Œå´æœªæ›¾æ„Ÿæ¿€è¿‡è¿™æ— èŠçš„å’¸æ¶©ã€‚æƒ³æ¥å­¤ç‹¬çš„å†ç¨‹å·²é€¾8æœˆï¼Œå´ä¸æ¯«æ²¡æœ‰å¿˜å´æ˜”æ—¥çš„æ„‰æ‚¦å’Œæ‡Šæ¼ã€‚</li>
</ul>
<!-- more -->
<ul>
<li>å¯¹å•Šï¼Œå½“åˆä¸ºä½•è«åå…¶å¦™ï¼Œå°±åŒæœ¬ä¸å¯èƒ½åœ¨ä¸€èµ·çš„äººè®¸ä¸‹é•¿ä¹…çš„æ„¿æ™¯ã€‚ç†æ™ºåŒè‡ªå·±è®²è¯´å˜æ•°å¤ªå¤šï¼Œä½•è‹¦æ•…å¢çƒ¦æ¼ï¼Œä½†ä»æ¨ç€è‡ªå·±å¾€åå·çš„è·¯ä¸Šå‰è¿›ã€‚æˆ–è®¸ä¸æ˜¯è°å‰è°åå§ï¼Œä½†æ˜¯ä¸€å¼€å§‹å°±åœ¨å²”è·¯ä¸Šï¼Œèµ°çš„è¶Šä¹…ï¼Œäººå½±äº¦æ„ˆå‘çš„æœ¦èƒ§ã€‚</li>
<li>å¥¹ç‚¹æ’­äººçš„æŠ€å·§å¤šæ›¼å¦™ï¼Œå°±æ˜¯é‚£ä¸€ç‚¹ç‚¹ç«è‹—å¼•ç‡ƒè‡ªå·±å¯¹æœªæ¥ä¸€åˆ‡çš„ç•…æƒ³ã€‚å½·å¾¨äºç°å®ä¸­çš„æ…¨å¹ï¼Œæ€»ä¼šåœ¨å¤œæ·±æ—¶æƒ³ç€å¦‚ä½•å‹¾å‹’å‡ºé‚£ç”Ÿæ´»çš„ç¾å¥½ã€‚å¯æ˜¯ç‡ƒèµ·æ¥çš„ä¸åªæ˜¯è‡ªå·±ï¼Œè°åˆæƒ³åˆ°è¿ç€è¿™ç”»æœ¬èº«ä¹Ÿå¼€å§‹ç‡ƒçƒ§ï¼ŒæŠŠè‡ªå·±æ®·åˆ‡çš„æœŸç›¼è®²ç»™ç”»å¬ï¼Œæ­¢ä¸ä½é‚£çƒ›å…‰ï¼Œåå´æ•‘ç„šç›Šè–ªã€‚</li>
<li>äºæ˜¯å¥¹ä¸æ¯«æœªæœ‰å›é¦–çš„æƒ³æ³•ï¼Œè¿ˆç€æ­¥å­èµ°å¼€ï¼Œä½ çœ‹è¿·é›¾æœ¬æ¥å°±é®æ©ç€ä¸–é—´ï¼Œè¿™ä¸‹è¯¥æ˜¯ä»€ä¹ˆä¹Ÿçœ‹ä¸ç€äº†ã€‚</li>
<li>æ‰€ä»¥æƒ³å‘€ï¼Œè¦æ˜¯äººç±»æ²¡æœ‰æ„Ÿæƒ…å¤šå¥½ï¼Œäº‹ç‰©çš†é€»è¾‘ï¼Œäººä»¬æ˜¯ä¸æ˜¯ä¸ä¼šå†è¢«ä¼¤å¿ƒçš„äº‹é˜»ç¢ï¼Ÿäºæ˜¯é—­ç€çœ¼ç›å‘å‰èµ°ï¼Œè¦æ˜¯çœ¼é‡Œçš†å°½æ˜¯é»‘æš—ï¼Œä½•æƒ§ä½ ç»ˆä¼šæ¥çš„é»‘æš—ã€‚å¯æ˜¯æˆ‘æ€»æ˜¯æ€€å¿µé‚£è¢«æš–æ„åŒ…å›´ï¼Œè¢«é˜³å…‰æ™®ç…§çš„ä¸–ç•Œï¼Œå¸¸å¸¸åœ¨å®‰é™çš„æ—¶å€™ï¼Œåœ¨å››ä¸‹æ— äººçš„æ—¶å€™ï¼Œå·å·çš„çå¼€çœ¼ç›ã€‚åªæ¨è¿™ä¸€æ—¶åŠä¼šå„¿æ²¡æœ‰é€‚åº”ï¼Œç«Ÿç„¶ä¼šç•¥è§‰åˆºçœ¼ã€‚</li>
<li>ä½ è¯´å½“å¤§å®¶æ˜æ™ƒæ™ƒçš„ç›¯ç€æˆ‘ï¼Œè¦æ˜¯æˆ‘ä¹Ÿççœ¼å›çœ‹ç€å¥¹ï¼Œä¼šè¢«ä¼—äººè€»ç¬‘å—ï¼Ÿ</li>
<li></li>
<li>ä¹Ÿåˆ«è½»æ˜“çš„å›ç­”ï¼Œæ¯•ç«Ÿæµ·é£è¿˜æ²¡åœæ­‡ï¼Œé‚£äº›æµ·é¸¥ä»¬ä¹Ÿåœ¨åµé—¹ã€‚</li>
<li>å¥‡æ€ªå•Šï¼Œä¸ºä½•é˜´æ²‰çš„å¤©ç©ºä¸è¿·ç¦»çš„å¤§æµ·å¦‚æ­¤çš„æ²‰é‡ï¼Œå´åœ¨é‚£è½®çº¢æ—¥çš„æ˜ è¡¬ä¸‹æ˜¾å¾—å¦‚æ­¤å®Œç¾ã€‚ä¸ºä½•æˆ‘æ€»æƒ³ç€é‚£å¤©çš„å’Œé£ä¸æš–æ—¥ï¼Œå´ä¸æ„¿å“å‘³æ¯ä¸€ä¸ªå­£èŠ‚ã€‚ä»–ä»¬éƒ½æ˜¯äº²åˆ‡çš„ï¼Œåªæ˜¯ä¸çŸ¥é“ç”¨å“ªç§æ–¹å¼æ¥è¿‘æˆ‘ï¼Œä¸è‡³äºåªè´ªæ‹å¾€æ—¥ï¼Œæ¯ä¸ªè®©æˆ‘æ„Ÿåˆ°å¿ƒå®‰çš„æ—¥å­ï¼Œéƒ½æ˜¯é‚£ä¹ˆç¾å¥½ã€‚</li>
<li>æˆ‘æƒ³ï¼Œå¿ƒé‡Œä¹Ÿåº”è¯¥æ„Ÿæ¿€ï¼Œçºµä½¿è¿™æµ·é£å¹¶ä¸æ¸©æŸ”ã€‚</li>
</ul>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Matlabå­¦ä¹ ç¬”è®°ï¼ˆä¸‰ï¼‰]]></title>
        <id>https://abelcorn.cn/post/matlab-3</id>
        <link href="https://abelcorn.cn/post/matlab-3">
        </link>
        <updated>2019-09-22T11:27:48.000Z</updated>
        <summary type="html"><![CDATA[<p><em><strong>çŸ©é˜µ</strong></em></p>
]]></summary>
        <content type="html"><![CDATA[<p><em><strong>çŸ©é˜µ</strong></em></p>
<!--more-->
<h3 id="çŸ©é˜µ">çŸ©é˜µ</h3>
<p><strong>çŸ©é˜µå®šä¹‰</strong>ï¼š</p>
<ul>
<li>å¦‚3x3çš„çŸ©é˜µ<code>A=[1 2 3;4 5 6; 7 8 9]</code></li>
<li>3ç»´çŸ©é˜µï¼š<code>[[1 2 3];[2 4 6];[7 8 9]]</code></li>
<li>å¤æ•°çŸ©é˜µï¼š<code>[[1 1+i 2];[2 3+2i 1]]</code></li>
<li>çŸ©é˜µç”Ÿæˆï¼š</li>
<li>
<ul>
<li>åˆ©ç”¨Mæ–‡ä»¶å†™å…¥</li>
<li>åˆ©ç”¨æ–‡æœ¬åˆ›å»ºï¼š</li>
<li>å»ºç«‹<code>goods.txt</code>ï¼Œé‡Œé¢å†™å…¥ç›¸å…³çŸ©é˜µä¿¡æ¯ï¼Œæ¥ç€<code>load goods.txt</code></li>
</ul>
</li>
<li>åˆ›å»ºç‰¹æ®ŠçŸ©é˜µï¼š</li>
<li>
<ul>
<li><code>eye(n)</code>ï¼šåˆ›å»ºnxnçš„å•ä½çŸ©é˜µ</li>
<li><code>eye(m,n)</code>ï¼šåˆ›å»ºmxnçš„å•ä½çŸ©é˜µ</li>
<li><code>eye(size(A))</code>ï¼šåˆ›å»ºä¸AåŒç»´çš„å•ä½çŸ©é˜µ</li>
<li><code>ones(n)</code>ï¼šåˆ›å»ºnxnçš„å…¨1çŸ©é˜µ</li>
<li><code>ones(m,n)</code>ã€ <code>ones(size(A))</code></li>
<li><code>zeros(n)</code>ã€ <code>zeros(m,n)</code>ã€ <code>zeros(size(A))</code></li>
<li><code>rand(n)</code>ï¼šåœ¨<code>[0,1]</code>åŒºé—´å†…åˆ›å»ºä¸€ä¸ªnxnçš„å‡åŒ€éšæœºçŸ©é˜µ</li>
<li><code>rand(m,n)</code>ã€<code>rand(size(A))</code></li>
<li><code>compan(P)</code>ï¼šåˆ›å»ºç³»æ•°å‘é‡æ˜¯Pçš„å¤šé¡¹å¼ä¼´éšçŸ©é˜µ</li>
<li><code>diag(v)</code>ï¼šåˆ›å»ºä¸€å‘é‡vä¸­çš„å…ƒç´ ä¸ºå¯¹è§’çš„å¯¹è§’çŸ©é˜µ</li>
<li><code>hilb(n)</code>ï¼šåˆ›å»ºnxnçš„HilbertçŸ©é˜µ</li>
<li><code>magic(n)</code>ï¼šç”Ÿæˆné˜¶é­”æ–¹çŸ©é˜µ</li>
<li><code>sparse(A)</code>ï¼šå°†Aè½¬åŒ–ä¸ºç¨€ç–çŸ©é˜µï¼Œå³ç”±Açš„é0å…ƒç´ å’Œä¸‹æ ‡æ„æˆçš„ç¨€ç–çŸ©é˜µSã€‚è‹¥Aæœ¬èº«ä¸ºç¨€ç–çŸ©é˜µï¼Œåˆ™è¿”å›Aæœ¬èº«(å³ä»ç„¶ä¸ºç¨€ç–çŸ©é˜µA)</li>
</ul>
</li>
</ul>
<p><strong>çŸ©é˜µå…ƒç´ çš„è¿ç®—</strong>ï¼š</p>
<ol>
<li>å…ƒç´ ä¿®æ”¹ï¼š
<ul>
<li><code>D=[A;B C]</code>ï¼šAä¸ºåŸçŸ©é˜µï¼ŒBã€Cä¸­åŒ…å«è¦æ‰©å……çš„å…ƒç´ ï¼ŒDä¸ºæ‰©å……åçš„çŸ©é˜µ</li>
<li><code>A(m,:)=[]</code>ï¼šåˆ é™¤Açš„ç¬¬mè¡Œ</li>
<li><code>A(:,n)=[]</code>ï¼šåˆ é™¤Açš„ç¬¬nåˆ—</li>
<li><code>A(m,n) =a</code>ï¼šå¯¹Açš„ç¬¬mè¡Œnåˆ—å…ƒç´ èµ‹å€¼</li>
<li><code>A(m,:)=[a,b,c....]</code>ï¼šå¯¹Açš„ç¬¬mè¡Œèµ‹å€¼</li>
<li><code>A(:,n)=[a,b,c,...]</code></li>
</ul>
</li>
<li>ç»´åº¦ä¿®æ”¹:</li>
</ol>
<ul>
<li>çŸ©é˜µçš„å˜ç»´å¯ä»¥ç”¨ç¬¦å·â€œï¼šâ€å’Œreshapeå‡½æ•°å˜æ¢
<ul>
<li><code>A=1:12</code> <code>B=reshape(A,2,6)</code></li>
<li>ç”¨å†’å·æ³•æ—¶ï¼Œè¦æ³¨æ„éœ€å…ˆè®¾å®šä¿®æ”¹åçš„çŸ©é˜µå½¢çŠ¶</li>
<li><code>C=zeros(3,4);</code> <code>C(:)=A(:)</code></li>
</ul>
</li>
</ul>
<ol start="3">
<li>çŸ©é˜µçš„å˜å‘ï¼š
<ul>
<li><code>Rot(90)</code>ï¼šå°†Aé€†æ—¶é’ˆæ—‹è½¬90åº¦</li>
<li><code>Rot(90,k)</code>ï¼šå°†Aæ—‹è½¬<code>k*90</code>åº¦ï¼Œå…¶ä¸­kä¸ºæ­£è´Ÿæ•´æ•°</li>
<li><code>Fliplr(X)</code>:å°†Xå·¦å³ç¿»è½¬</li>
<li><code>flipud(X)</code>ï¼šå°†Xä¸Šä¸‹ç¿»è½¬</li>
<li><code>flipdim(X,dim)</code>ï¼šdim=1æ—¶å¯¹è¡Œç¿»è½¬ï¼Œdim=2æ—¶å¯¹åˆ—ç¿»è½¬</li>
</ul>
</li>
<li>çŸ©é˜µçš„æŠ½å–:</li>
</ol>
<ul>
<li>ä¸»è¦æŒ‡å¯¹è§’çº¿å…ƒç´ å’Œä¸Šä¸‹ä¸‰è§’çŸ©é˜µçš„æŠ½å–
<ul>
<li><code>diag(X,k)</code>ï¼šæŠ½å–çŸ©é˜µçš„ç¬¬kæ¡å¯¹è§’çº¿ä¸Šçš„å…ƒç´ å‘é‡ã€‚k=0è¡¨ç¤ºä¸»å¯¹è§’çº¿ï¼Œkä¸ºæ­£æ•´æ•°æ—¶æŠ½å–ä¸Šæ–¹ç¬¬kæ¡ã€‚ã€‚ã€‚ã€‚ã€‚ã€‚ã€‚</li>
<li><code>diag(X)</code>ï¼šæŠ½å–ä¸»å¯¹è§’çº¿</li>
<li><code>diag(v,k)</code>ï¼šä½¿å¾—vä¸ºæ‰€å¾—çŸ©é˜µç¬¬kæ¡å¯¹è§’çº¿ä¸Šçš„å…ƒç´ å‘é‡</li>
<li><code>diag(v)</code>ï¼šä½¿å¾—vä¸ºæ‰€å¾—çŸ©é˜µä¸»å¯¹è§’çº¿ä¸Šçš„å…ƒç´ å‘é‡</li>
<li><code>tril(X)</code>ï¼šæå–çŸ©é˜µXçš„ä¸»ä¸‹ä¸‰è§’éƒ¨åˆ†</li>
<li><code>tril(X,k)</code>ï¼šæå–ç¬¬kæ¡å¯¹è§’çº¿ä¸‹é¢çš„éƒ¨åˆ†ï¼ˆåŒ…æ‹¬ç¬¬kæ¡ï¼‰</li>
<li><code>triu(X)</code>ï¼šæå–ä¸Šä¸‰è§’</li>
<li><code>triu(X,k)</code>ï¼š........ä¸Šä¸‰è§’ï¼ˆåŒ…æ‹¬ç¬¬kæ¡ï¼‰</li>
</ul>
</li>
</ul>
<h3 id="çŸ©é˜µçš„æ•°å­¦è¿ç®—">çŸ©é˜µçš„æ•°å­¦è¿ç®—</h3>
<ul>
<li>å¾…ç»­</li>
</ul>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Matlabå­¦ä¹ ç¬”è®°ï¼ˆäºŒï¼‰]]></title>
        <id>https://abelcorn.cn/post/matlab-2</id>
        <link href="https://abelcorn.cn/post/matlab-2">
        </link>
        <updated>2019-09-20T13:22:05.000Z</updated>
        <summary type="html"><![CDATA[<p>æœ¬èŠ‚å†…å®¹å°†è¯´æ˜ä¸€èˆ¬çš„å‘é‡è¿ç®—ï¼Œä¸ºåé¢çš„çŸ©é˜µè¿ç®—åšå¥½åŸºç¡€ã€‚å‘é‡å¤§éƒ¨åˆ†ä¸ºä¸­å­¦çŸ¥è¯†ï¼Œä¸å†è¯´æ˜è®¡ç®—æ–¹æ³•ä¸ç”¨å¤„ã€‚</p>
]]></summary>
        <content type="html"><![CDATA[<p>æœ¬èŠ‚å†…å®¹å°†è¯´æ˜ä¸€èˆ¬çš„å‘é‡è¿ç®—ï¼Œä¸ºåé¢çš„çŸ©é˜µè¿ç®—åšå¥½åŸºç¡€ã€‚å‘é‡å¤§éƒ¨åˆ†ä¸ºä¸­å­¦çŸ¥è¯†ï¼Œä¸å†è¯´æ˜è®¡ç®—æ–¹æ³•ä¸ç”¨å¤„ã€‚</p>
<!--more-->
<p><em><strong>å‘é‡ä¸å¤šé¡¹å¼</strong></em></p>
<h3 id="å‘é‡">å‘é‡</h3>
<p><strong>å‘é‡çš„ç”Ÿæˆ</strong>ï¼š</p>
<ol>
<li>ç›´æ¥è¾“å…¥ï¼šè¡Œå‘é‡ï¼š<code>x=[1,2,3]</code>ï¼Œåˆ—å‘é‡ï¼š<code>x=[1;2;3]</code></li>
<li>å†’å·è¾“å…¥ï¼š<code>x=0:2:10</code>ï¼Œè¡¨ç¤ºä»0ä¸€ç›´åˆ°10ï¼Œæ­¥é•¿ä¸º2ï¼Œéš”ä¸€ä¸ªè¾“å‡ºï¼Œå³ç»“æœæ˜¯<code>x=[0,2,4,6,8,10]</code> å¦‚æœ<code>x=0:10</code>ï¼Œåˆ™é»˜è®¤æ­¥é•¿ä¸º1</li>
<li>linspaceå‡½æ•°æ³•ï¼š<code>linspace(first_value,last_value,number)</code>ï¼Œä»ç¬¬ä¸€åˆ°æœ€åçš„æ•°æ®èŒƒå›´ï¼Œå…¶ä¸­åŒ…æ‹¬numberä¸ªæ•°</li>
<li>logspaceå‡½æ•°æ³•ï¼š<code>logspace(first_value,last_value,number)</code>,è¾“å‡ºnumberä¸ªï¼Œä»10<sup>first_valueåˆ°10</sup>last_valueï¼Œå¦‚ï¼š<code>logspace(1,3,3)</code>å¯å¾—10 100 1000</li>
</ol>
<p><strong>å‘é‡å…ƒç´ çš„å¼•ç”¨</strong>ï¼š</p>
<ul>
<li>å¦‚<code>x=[1,2,3,4,5]</code>ï¼Œåˆ™<code>x(1:3)</code>è¡¨ç¤ºæŠ½å‡ºç¬¬ä¸€åˆ°ç¬¬ä¸‰ä¸ªå…ƒç´ ï¼Œå³1 2 3</li>
</ul>
<p><strong>å‘é‡è¿ç®—</strong>ï¼š</p>
<ul>
<li>
<p>å®šä¹‰å‘é‡</p>
</li>
<li>
<p>åŠ æ³•+</p>
</li>
<li>
<p>å‡æ³•-</p>
</li>
<li>
<p>ä¹˜æ³•*</p>
</li>
<li>
<p>é™¤æ³•/</p>
</li>
<li>
<p>æ··åˆè¿ç®— ï¼ˆä»¥ä¸Šå‡ä¸­å­¦çŸ¥è¯†ä¸å†èµ˜è¿°ï¼‰</p>
</li>
<li>
<p>ç‚¹ç§¯ï¼šç‚¹ç§¯å¯ç”¨<code>.*</code>æˆ–è€…<code>dot(a,b)</code>,<code>dot(a,b,dim)</code>ï¼Œå…¶ä¸­ï¼Œaå’Œbå¿…é¡»åŒç»´ï¼Œdimæ˜¯aå’Œbåœ¨dimç»´åº¦çš„ç‚¹ç§¯</p>
</li>
<li>
<p>å‰ç§¯ï¼š<code>cross(a,b)</code>,<code>cross(a,b,dim)</code></p>
</li>
<li>
<p>å·ç§¯ï¼šæˆ‘ä»¬ç§°</p>
<p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>(</mo><mi>f</mi><mo>âˆ—</mo><mi>g</mi><mo>)</mo><mo>(</mo><mi>n</mi><mo>)</mo><mi mathvariant="normal">ä¸º</mi><mi>f</mi><mo separator="true">,</mo><mi>g</mi><mi mathvariant="normal">çš„</mi><mi mathvariant="normal">å·</mi><mi mathvariant="normal">ç§¯</mi><mi mathvariant="normal">ã€‚</mi><mi mathvariant="normal">å…¶</mi><mi mathvariant="normal">è®¡</mi><mi mathvariant="normal">ç®—</mi><mi mathvariant="normal">æ–¹</mi><mi mathvariant="normal">å¼</mi><mi mathvariant="normal">ä¸º</mi><mi mathvariant="normal">ï¼š</mi><msubsup><mo>âˆ«</mo><mrow><mo>âˆ’</mo><mi mathvariant="normal">âˆ</mi></mrow><mrow><mo>+</mo><mi mathvariant="normal">âˆ</mi></mrow></msubsup><mi>f</mi><mo>(</mo><mi>Ï„</mi><mo>)</mo><mi>g</mi><mo>(</mo><mi>n</mi><mo>)</mo><mi>d</mi><mi>Ï„</mi></mrow><annotation encoding="application/x-tex">(f*g)(n)ä¸ºf,gçš„å·ç§¯ã€‚ å…¶è®¡ç®—æ–¹å¼ä¸ºï¼š \int_{-\infty}^{+\infty}f(\tau)g(n)d\tau
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">âˆ—</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:2.491512em;vertical-align:-0.970281em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="mclose">)</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mclose">)</span><span class="mord cjk_fallback">ä¸º</span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="mord cjk_fallback">çš„</span><span class="mord cjk_fallback">å·</span><span class="mord cjk_fallback">ç§¯</span><span class="mord cjk_fallback">ã€‚</span><span class="mord cjk_fallback">å…¶</span><span class="mord cjk_fallback">è®¡</span><span class="mord cjk_fallback">ç®—</span><span class="mord cjk_fallback">æ–¹</span><span class="mord cjk_fallback">å¼</span><span class="mord cjk_fallback">ä¸º</span><span class="mord cjk_fallback">ï¼š</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mop"><span class="mop op-symbol large-op" style="margin-right:0.44445em;position:relative;top:-0.0011249999999999316em;">âˆ«</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.5212310000000002em;"><span style="top:-1.7880500000000001em;margin-left:-0.44445em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">âˆ’</span><span class="mord mtight">âˆ</span></span></span></span><span style="top:-3.8129000000000004em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">+</span><span class="mord mtight">âˆ</span></span></span></span></span><span class="vlist-s">â€‹</span></span><span class="vlist-r"><span class="vlist" style="height:0.970281em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.1132em;">Ï„</span><span class="mclose">)</span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mclose">)</span><span class="mord mathdefault">d</span><span class="mord mathdefault" style="margin-right:0.1132em;">Ï„</span></span></span></span></span></p>
</li>
<li>
<p>å»å·ç§¯</p>
</li>
</ul>
<h3 id="å¤šé¡¹å¼">å¤šé¡¹å¼</h3>
<p><strong>å¤šé¡¹å¼çš„åˆ›å»º</strong>ï¼š</p>
<ul>
<li>å¤šé¡¹å¼åˆ›å»ºæ—¶åªéœ€è¦å†™å‡ºç³»æ•°ï¼Œæ²¡æœ‰çš„é¡¹å¿…é¡»ç”¨0ä»£æ›¿</li>
<li>å¦‚ï¼š<code>p=[3,2,1]</code>ï¼Œä¹‹åè¾“å…¥<code>poly2sym(p)</code>ï¼Œå°±å¾—åˆ°äº†ï¼š<code>3*x^3+2*x^2+x</code></li>
</ul>
<p><strong>å¤šé¡¹å¼çš„å››åˆ™è¿ç®—</strong>ï¼š</p>
<ul>
<li>
<p>å·ç§¯ï¼šæˆ‘ä»¬ç§°$$(f*g)(n)ä¸ºf,gçš„å·ç§¯ã€‚ å…¶è®¡ç®—æ–¹å¼ä¸ºï¼š \int_{-\infty}^{+\infty}f(\tau)g(n)d\tau$$</p>
</li>
<li>
<p>è®¡ç®—æ–¹å¼ä¸º<code>conv(p1,p2)</code></p>
</li>
<li>
<p>å»å·ç§¯ï¼š<code>[k,r]=deconv(p,q)</code>ç­‰ä»·äº<code>p=conv(q,k)+r</code></p>
</li>
<li>
<p>kè¿”å›çš„æ˜¯å¤šé¡¹å¼pé™¤ä»¥qçš„å•†ï¼Œræ˜¯ä½™å¼</p>
</li>
<li>
<p>æ ¹æ„é€ ï¼šé€šè¿‡å†™å‡ºå¤šé¡¹å¼çš„è§£ï¼Œè®©ç³»ç»Ÿè‡ªå·±æ„é€ ä¸€ä¸ªç¬¦åˆæ ¹çš„å¤šé¡¹å¼</p>
</li>
<li>
<p>å¦‚ï¼š<code>root=[-5,3+2i,3-2i]</code> åˆ™ï¼Œ<code>p=poly(root)</code>å°±æ„é€ äº†å¯¹åº”çš„ç³»æ•°è¡¨ï¼Œæ¥ç€<code>poly2sym(p)</code>å¯ä»¥ç”Ÿæˆå¤šé¡¹å¼</p>
</li>
</ul>
<p><strong>å¤šé¡¹å¼çš„å¯¼æ•°è¿ç®—</strong>ï¼š</p>
<ul>
<li>é€šè¿‡<code>polyder(p)</code>å°±å¯ä»¥å¾—åˆ°æ±‚å¯¼åçš„ç³»æ•°è¡¨ï¼Œæ¥ç€<code>poly2sym()</code>å¯ç”Ÿæˆæ±‚å¯¼åçš„å¤šé¡¹å¼</li>
<li>æ›´é«˜é˜¶çš„å¯¼æ•°ç±»ä¼¼åå¤è°ƒç”¨å°±è¡Œ</li>
</ul>
<h3 id="ç‰¹æ®Šå˜é‡">ç‰¹æ®Šå˜é‡</h3>
<p><strong>å•å…ƒå‹å˜é‡</strong>ï¼š</p>
<ul>
<li>
<p>åˆ›å»ºï¼š</p>
</li>
<li>
<ul>
<li>å¦‚ï¼š<code>A[1,2,3,4];B=3+2i;C='hhh'</code>ï¼Œåˆ™ç”Ÿæˆæ–¹å¼ä¸º<code>E={A,B,C}</code></li>
<li><code>cell(n)</code>ï¼šç”Ÿæˆn*né˜¶çš„ç©ºå•å…ƒæ•°ç»„</li>
<li><code>cell(m,n)</code></li>
<li><code>cell(m,n,p,....)</code></li>
<li><code>cell(size(A))</code>ï¼šç”Ÿæˆä¸AåŒå½¢å¼çš„å•å…ƒå‹ç©ºçŸ©é˜µ</li>
<li><code>E=cell(1,3)</code></li>
<li><code>E{1,1}=[1:4]</code></li>
<li><code>E{1,2}=B</code></li>
</ul>
</li>
<li>
<p>å¼•ç”¨ï¼š</p>
</li>
<li>
<ul>
<li><code>E{1}</code></li>
<li><code>E(1)</code></li>
</ul>
</li>
<li>
<p>å…¶ä»–å‡½æ•°ï¼š</p>
</li>
<li>
<ul>
<li><code>cellfun</code>ï¼šå¯¹å•å…ƒå‹å˜é‡ä¸­çš„å…ƒç´ ä½œç”¨çš„å‡½æ•°</li>
<li><code>celldisp</code>ï¼šæ˜¾ç¤ºå˜é‡å†…å®¹</li>
<li><code>cellplot</code>ï¼šå›¾å½¢æ˜¾ç¤º</li>
<li><code>num2cell</code>ï¼šå°†æ•°å€¼è½¬æ¢æˆå•å…ƒå‹å˜é‡</li>
<li><code>deal</code>ï¼šè¾“å…¥è¾“å‡º</li>
<li><code>cell2struct</code>ï¼šå•å…ƒå‹å˜æˆç»“æ„å‹</li>
<li><code>struct2cell</code>ï¼šå°†ç»“æ„å‹å˜æˆå•å…ƒå‹</li>
<li><code>iscell</code>ï¼šåˆ¤æ–­æ˜¯å¦ä¸ºå•å…ƒå‹</li>
<li><code>reshape</code>ï¼šæ”¹å˜å•å…ƒæ•°ç»„çš„ç»“æ„</li>
</ul>
</li>
</ul>
<p><strong>ç»“æ„å‹å˜é‡</strong>ï¼š</p>
<ul>
<li>
<p>åˆ›å»ºï¼š</p>
</li>
<li>
<ul>
<li><code>struct('field',value1,'filed2',value2,.....)</code>ï¼šè¡¨ç¤ºå»ºç«‹ä¸€ä¸ªå…·æœ‰å±æ€§ååŠå¯¹åº”æ•°æ®çš„ç»“æ„å‹æ•°ç»„</li>
<li>å¦‚ï¼š<code>p=struct('color',{'red','green'},'num',{1,2,3})</code></li>
</ul>
</li>
<li>
<p>å¼•ç”¨ï¼š</p>
</li>
<li>
<ul>
<li><code>p</code>ã€<code>p(1)</code> ã€<code>p(1).color</code></li>
</ul>
</li>
<li>
<p>å‡½æ•°ï¼š</p>
</li>
<li>
<ul>
<li><code>struct</code>ï¼šåˆ›å»ºç»“æ„å‹å˜é‡</li>
<li><code>fieldnames</code>ï¼šå¾—åˆ°ç»“æ„å‹å˜é‡çš„å±æ€§å</li>
<li><code>getfield</code>ï¼šå¾—åˆ°å±æ€§å€¼</li>
<li><code>setfield</code>ï¼šè®¾å®šå±æ€§å€¼</li>
<li><code>rmfield</code>ï¼šåˆ é™¤å±æ€§</li>
<li><code>isfield</code>ï¼šåˆ¤æ–­æ˜¯å¦ä¸ºç»“æ„å‹çš„å±æ€§</li>
<li><code>isstruct</code>ï¼šåˆ¤æ–­æ˜¯å¦ä¸ºç»“æ„å‹å˜é‡</li>
</ul>
</li>
</ul>
<p><em><strong>æ¥ç€ä¼šæ›´æ–°çŸ©é˜µè¿ç®—çš„ç›¸å…³å†…å®¹</strong></em></p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Matlabå­¦ä¹ ç¬”è®°ï¼ˆä¸€ï¼‰]]></title>
        <id>https://abelcorn.cn/post/matlab-1</id>
        <link href="https://abelcorn.cn/post/matlab-1">
        </link>
        <updated>2019-09-18T15:18:08.000Z</updated>
        <summary type="html"><![CDATA[<p><em><strong>åŸºç¡€çŸ¥è¯†</strong></em><br>
C++è€ƒè¯•ç»ˆäºç»“æŸäº†ï¼Œå¯ä»¥å¼€å§‹matlabçš„å­¦ä¹ äº†ï¼Œæœ¬éƒ¨åˆ†å†…å®¹ä»…ä¸ºè‡ªå·±åšç¬”è®°ç”¨ï¼Œä¸å±äºå¯¹å¤–æ•™ç¨‹ã€‚</p>
]]></summary>
        <content type="html"><![CDATA[<p><em><strong>åŸºç¡€çŸ¥è¯†</strong></em><br>
C++è€ƒè¯•ç»ˆäºç»“æŸäº†ï¼Œå¯ä»¥å¼€å§‹matlabçš„å­¦ä¹ äº†ï¼Œæœ¬éƒ¨åˆ†å†…å®¹ä»…ä¸ºè‡ªå·±åšç¬”è®°ç”¨ï¼Œä¸å±äºå¯¹å¤–æ•™ç¨‹ã€‚</p>
<!--more-->
<h3 id="å¸¸ç”¨æŒ‡ä»¤">å¸¸ç”¨æŒ‡ä»¤</h3>
<ul>
<li><code>cd</code>ï¼šæ˜¾ç¤ºæˆ–æ”¹å˜å·¥ä½œç›®å½•</li>
<li><code>clc</code>ï¼šæ¸…é™¤å‘½ä»¤è¡Œçª—å£</li>
<li><code>clf</code>ï¼šæ¸…é™¤å›¾å½¢çª—å£</li>
<li><code>hold</code>ï¼šä¿æŒå›¾å½¢çª—å£</li>
<li><code>diary</code>ï¼šç”Ÿæˆæ—¥å¿—æ–‡ä»¶</li>
<li><code>load</code>ï¼šåŠ è½½æŒ‡å®šæ–‡ä»¶çš„å˜é‡</li>
<li><code>dir</code>ï¼šæ˜¾ç¤ºå½“å‰ç›®å½•ä¸‹çš„æ–‡ä»¶</li>
<li><code>pack</code>ï¼šæ•´ç†å†…å­˜ç¢ç‰‡</li>
<li><code>disp</code>ï¼šæ˜¾ç¤ºå˜é‡æˆ–æ–‡å­—å†…å®¹</li>
<li><code>path</code>ï¼šæ˜¾ç¤ºæœç´¢ç›®å½•</li>
<li><code>echo</code>ï¼šå‘½ä»¤è¡Œçª—å£ä¿¡æ¯æ˜¾ç¤ºå¼€å…³</li>
<li><code>quit</code>ï¼šé€€å‡º Matlab</li>
<li><code>save</code>ï¼šä¿å­˜å†…å­˜å˜é‡æŒ‡å®šæ–‡ä»¶</li>
<li><code>type</code>ï¼šæ˜¾ç¤ºæ–‡ä»¶å†…å®¹</li>
</ul>
<h3 id="å˜é‡ä¸å¸¸é‡">å˜é‡ä¸å¸¸é‡</h3>
<p><strong>å˜é‡ï¼š</strong></p>
<ul>
<li>å˜é‡åå¿…é¡»ä»¥å­—æ¯å¼€å¤´ï¼Œä¹‹åå¯ä»¥æ˜¯ä»»æ„çš„å­—æ¯ã€æ•°å­—æˆ–ä¸‹åˆ’çº¿</li>
<li>å¤§å°å†™æ•æ„Ÿ</li>
<li>ä¸è¶…è¿‡31ä¸ªå­—ç¬¦ï¼Œç¬¬31ä¸ªåŠä¹‹åçš„ä¼šè¢«å¿½ç•¥</li>
<li>æœªåŠ è¯´æ˜çš„å‰æä¸‹ï¼Œä¸€åˆ‡å˜é‡è§†ä¸ºå±€éƒ¨å˜é‡ï¼Œå¯ç”¨globalå£°æ˜ä¸ºå…¨å±€</li>
</ul>
<p><strong>å¸¸é‡</strong>ï¼š</p>
<ul>
<li><code>ans</code>ï¼šé»˜è®¤å˜é‡ï¼Œä¸€èˆ¬ç”¨åœ¨æ˜¾ç¤ºç­”æ¡ˆ</li>
<li><code>pi</code>ï¼šåœ†å‘¨ç‡</li>
<li><code>eps</code>ï¼šæµ®ç‚¹è¿ç®—ç›¸å¯¹ç²¾åº¦</li>
<li><code>inf</code>ï¼šæ— ç©·å¤§ å¦‚1/0</li>
<li><code>NaN</code>ï¼šä¸å®šå€¼ï¼Œå¦‚0/0</li>
<li><code>i j</code>ï¼šè™šæ•°å•ä½</li>
<li><code>realmin</code>ï¼šæœ€å°æ­£æµ®ç‚¹æ•°</li>
<li><code>realmax</code>ï¼šæœ€å¤§æ­£æµ®ç‚¹æ•°</li>
</ul>
<h3 id="æ•°å€¼">æ•°å€¼</h3>
<p><strong>æ•´å‹</strong>ï¼š</p>
<ul>
<li><code>char</code>:å­—ç¬¦å‹ï¼Œå ç”¨1å­—èŠ‚</li>
<li><code>short</code>:çŸ­æ•´å‹ï¼Œå ç”¨2å­—èŠ‚</li>
<li><code>int</code>:æ•´å‹ï¼Œ4å­—èŠ‚</li>
<li><code>long</code>:é•¿æ•´å‹ï¼Œ8å­—èŠ‚</li>
<li>ä»¥ä¸Šå‡æœ‰å¯¹åº”çš„æ— ç¬¦å·ç±»å‹:<code>unsigned xxx</code></li>
</ul>
<p><strong>æµ®ç‚¹å‹</strong>ï¼š</p>
<ul>
<li>åè¿›åˆ¶ç±»å‹ï¼Œå¦‚ï¼š1.2 4.44</li>
<li>æŒ‡æ•°å½¢å¼ï¼Œå¦‚: 2.1E5  3.7e-2</li>
<li>æŒ‡æ•°æ ‡å¿—eå‰å¿…é¡»æœ‰æ•°å­—ï¼Œåé¢å¿…é¡»æœ‰é˜¶ç </li>
<li><code>float</code>ï¼šå•ç²¾åº¦ï¼Œ4å­—èŠ‚</li>
<li><code>double</code>ï¼šåŒç²¾åº¦ï¼Œ8å­—èŠ‚</li>
</ul>
<p><strong>å¤æ•°ç±»å‹</strong>ï¼š</p>
<ul>
<li>å®éƒ¨ï¼šRez=a</li>
<li>è™šéƒ¨ï¼šImz=b</li>
<li>å½“è™šéƒ¨ä¸º0ï¼Œå¯è§†ä¸ºå®æ•°ï¼›å½“å®éƒ¨ä¸º0è€Œè™šéƒ¨ä¸ä¸º0ï¼Œå«åšçº¯è™šæ•°</li>
<li>åŠ æ³•æ³•åˆ™ï¼š<code>(a+bi)+(c+di) = (a+c)+(b+d)i</code></li>
<li>å‡æ³•æ³•åˆ™ï¼š<code>(a+bi)-(c+di) = (a-c)+(b-c)i</code></li>
<li>ä¹˜æ³•æ³•åˆ™ï¼š<code>(a+bi)*(c+di) = (ac-bd)+(bc+ad)i</code></li>
<li>é™¤æ³•æ³•åˆ™ï¼š<code>(a+bi)/(c+di) = [(ac+bd)/(c^2+d^2)]+[(bc-ad)/(c^2+d^2)]i</code></li>
</ul>
<p><strong>æ•°å­—æ˜¾ç¤ºæ ¼å¼</strong>ï¼š</p>
<ul>
<li>
<p><code>format short</code>ï¼š5ä½å®šç‚¹è¡¨ç¤ºï¼ˆé»˜è®¤ï¼‰</p>
</li>
<li>
<p><code>format long</code>ï¼š15ä½å®šç‚¹è¡¨ç¤º</p>
</li>
<li>
<p><code>format short e</code>ï¼š5ä½æµ®ç‚¹è¡¨ç¤º</p>
</li>
<li>
<p><code>format short g</code>ï¼šè‡ªåŠ¨é€‰æ‹©å®šç‚¹è¿˜æ˜¯æµ®ç‚¹è¡¨ç¤º</p>
</li>
<li>
<p><code>format hex</code>ï¼šåå…­è¿›åˆ¶æ˜¾ç¤º</p>
</li>
<li>
<p><code>format +</code>ï¼šåœ¨çŸ©é˜µä¸­ï¼Œç”¨+ã€-å’Œç©ºæ ¼è¡¨ç¤ºæ­£ã€è´Ÿå’Œé›¶</p>
</li>
<li>
<p><code>format bank</code>ï¼šç”¨ç¾å…ƒå’Œç¾åˆ†å®šç‚¹è¡¨ç¤º</p>
</li>
<li>
<p><code>format rat</code>ï¼šä»¥æœ‰ç†æ•°å½¢å¼è¾“å‡ºç»“æœ</p>
</li>
<li>
<p><code>format compact</code>ï¼šå˜é‡é—´æ— ç©ºæ ¼</p>
</li>
<li>
<p><code>format loose</code>ï¼šå˜é‡é—´æœ‰ç©ºè¡Œ</p>
</li>
<li>
<p>ä»¥ä¸Šè¾“å‡ºæ–¹å¼:</p>
<pre><code class="language-matlab">format long,pi
</code></pre>
</li>
</ul>
<h3 id="è¿ç®—ç¬¦">è¿ç®—ç¬¦</h3>
<p>é™¤ç®€å•çš„å››åˆ™è¿ç®—å¤–ï¼Œè¿˜æœ‰ç‚¹ä¹˜<code>.*</code>ï¼Œç­‰ï¼ŒåæœŸè¿ç®—ä¼šé‡åˆ°</p>
<p><strong>å…³ç³»è¿ç®—ç¬¦</strong>ï¼š</p>
<ul>
<li><code>==</code>ï¼šç­‰äº</li>
<li><code>~=</code>ï¼šä¸ç­‰äº</li>
<li><code>&gt;``&gt;=``&lt;``&lt;=</code>ï¼šæ¯”è¾ƒ</li>
<li>ä»¥ä¸Šè¿”å›å€¼ä¸º0æˆ–1</li>
</ul>
<p><strong>é€»è¾‘è¿ç®—æ³•</strong>ï¼š</p>
<ul>
<li><code>-</code>ï¼šé€»è¾‘ä¸</li>
<li><code>|</code>ï¼šé€»è¾‘æˆ–</li>
<li><code>~</code>ï¼šé€»è¾‘é</li>
<li><code>xor</code>ï¼šé€»è¾‘å¼‚æˆ–</li>
<li><code>any</code>ï¼šæœ‰éé›¶å…ƒç´ åˆ™ä¸ºçœŸ</li>
<li><code>all</code>ï¼šæ‰€æœ‰å…ƒç´ å‡éé›¶æ‰ä¸ºçœŸ</li>
</ul>
<h3 id="å‡½æ•°è¿ç®—">å‡½æ•°è¿ç®—</h3>
<p><strong>å¤æ•°è¿ç®—</strong>ï¼š</p>
<ul>
<li><code>abs</code>:æ¨¡</li>
<li><code>angle</code>ï¼šå¤æ•°ç›¸è§’</li>
<li><code>complex</code>ï¼šç”¨å®éƒ¨å’Œè™šéƒ¨æ„é€ ä¸€ä¸ªå¤æ•°</li>
<li><code>conj</code>ï¼šå¤æ•°çš„å…±è½­</li>
<li><code>imag</code>ï¼šè™šéƒ¨</li>
<li><code>real</code>ï¼šå®éƒ¨</li>
<li><code>unwrap</code>ï¼šè°ƒæ•´çŸ©é˜µå…ƒç´ çš„ç›¸ä½</li>
<li><code>isreal</code>ï¼šåˆ¤æ–­æ˜¯å¦ä¸ºå®æ•°çŸ©é˜µ</li>
<li><code>cplxpair</code>ï¼šæŠŠå¤æ•°çŸ©é˜µæ’åˆ—æˆå¤å…±è½­å¯¹</li>
</ul>
<p><strong>ä¸‰è§’å‡½æ•°è¿ç®—</strong>ï¼š</p>
<ul>
<li><code>sin()</code>ï¼š</li>
<li><code>cos()</code></li>
<li><code>tan()</code></li>
<li><code>cot()</code></li>
<li><code>sec()</code>ï¼šæ­£å‰²</li>
<li><code>csc()</code>ï¼šä½™å‰²<br>
<em><strong>åæœŸå°†æ›´æ–°å‘é‡ä¸å¤šé¡¹å¼çš„å†…å®¹</strong></em></li>
</ul>
]]></content>
    </entry>
</feed>