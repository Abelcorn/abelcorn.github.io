<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://abelcorn.cn</id>
    <title>å°çŸ³çŸ³çŸ³</title>
    <updated>2019-11-24T10:58:47.776Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://abelcorn.cn"/>
    <link rel="self" href="https://abelcorn.cn/atom.xml"/>
    <subtitle>Always do your best.</subtitle>
    <logo>https://abelcorn.cn/images/avatar.png</logo>
    <icon>https://abelcorn.cn/favicon.ico</icon>
    <rights>All rights reserved 2019, å°çŸ³çŸ³çŸ³</rights>
    <entry>
        <title type="html"><![CDATA[æ•°æ®ç»“æ„--åŒç«¯é˜Ÿåˆ—]]></title>
        <id>https://abelcorn.cn/post/datastruct-deque</id>
        <link href="https://abelcorn.cn/post/datastruct-deque">
        </link>
        <updated>2019-11-22T23:20:00.000Z</updated>
        <summary type="html"><![CDATA[<p>å®éªŒäº”è¦æ±‚å®ç°ç®€å•çš„STLä¸­çš„dequeåŠŸèƒ½ï¼Œæ•…åœ¨æ­¤é€šè¿‡å¾ªç¯æ•°ç»„çš„æ–¹å¼å®ç°ä¹‹ã€‚</p>
]]></summary>
        <content type="html"><![CDATA[<p>å®éªŒäº”è¦æ±‚å®ç°ç®€å•çš„STLä¸­çš„dequeåŠŸèƒ½ï¼Œæ•…åœ¨æ­¤é€šè¿‡å¾ªç¯æ•°ç»„çš„æ–¹å¼å®ç°ä¹‹ã€‚</p>
<!--more-->
<pre><code class="language-c">//@å®éªŒäº” å®ç°ç±»STLçš„åŒç«¯é˜Ÿåˆ—dequeï¼ˆå¾ªç¯æ•°ç»„ç‰ˆï¼‰
// Created by abel on 2019/11/23.
//

#ifndef DEQUE_H
#define DEQUE_H

#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;stdbool.h&gt;
#define maxSize 10//é»˜è®¤æœ€å¤§é•¿åº¦

typedef int ElemType;//æŠ½è±¡åŸºæœ¬æ•°æ®
typedef struct {//åŒç«¯é˜Ÿåˆ—åŸºæœ¬ç»“æ„
    ElemType *data;//æ•°æ®å­˜å‚¨çš„æ•°ç»„
    int capacity;//æœ€å¤§å®¹é‡
    int front,rear;//å¤´ã€å°¾æŒ‡é’ˆ
    int size;//ä¿å­˜å½“å‰å­˜çš„æ•°æ®
}deque;

deque *createDeque();//åˆ›å»ºä¸€ä¸ªé˜Ÿåˆ—
deque *createADeque(int size);//åˆ›å»ºä¸€ä¸ªä»¥sizeä¸ºå®¹é‡çš„åŒç«¯é˜Ÿåˆ—
bool isEmpty(deque *q);//åˆ¤æ–­é˜Ÿåˆ—æ˜¯å¦ä¸ºç©ºé˜Ÿåˆ—
bool isFull(deque *q);//åˆ¤æ–­ä¸€ä¸ªé˜Ÿåˆ—æ˜¯å¦ä¸ºæ»¡é˜Ÿåˆ—
bool Push_front(deque *q, ElemType x);//å°†å…ƒç´ å‹å…¥é˜Ÿå¤´
bool Push_back(deque *q,ElemType x);//å°†å…ƒç´ å‹å…¥é˜Ÿå°¾
ElemType Pop_front(deque *q);//å¼¹å‡ºé˜Ÿå¤´å…ƒç´ 
ElemType getFront(deque *q);//å¾—åˆ°é˜Ÿå¤´å…ƒç´ 
ElemType Pop_back(deque *q);//å¼¹å‡ºé˜Ÿå°¾å…ƒç´ 
ElemType getBack(deque *q);//å¾—åˆ°é˜Ÿå°¾å…ƒç´ 
void Display(deque *q);//ä»å¤´åˆ°å°¾æ˜¾ç¤ºæ•°æ®
int getSize(deque *q);//å¾—åˆ°é˜Ÿåˆ—å½“å‰å¾—åˆ°çš„å…ƒç´ ä¸ªæ•°
int getCapacity(deque *q);//å¾—åˆ°å½“å‰é˜Ÿåˆ—çš„æœ€å¤§å®¹é‡

//åˆå§‹åˆ›å»ºåŒç«¯é˜Ÿåˆ—
deque *createDeque()
{
    //åˆ›å»ºä¸€ä¸ªåˆå§‹çš„å­˜å‚¨åœ°å€ï¼Œå¼€è¾Ÿç©ºé—´
    deque *q = (deque *) malloc(sizeof(deque));
    if(!q)//åˆ¤æ–­ç©ºé—´å¼€è¾Ÿæ˜¯å¦æˆåŠŸ
    {
        printf(&quot;Memory Error--&gt;deque!\n&quot;);
        return NULL;
    }
    q-&gt;capacity = maxSize;//åˆå§‹åŒ–æœ€å¤§å®¹é‡
    q-&gt;size=0;
    q-&gt;front = q-&gt;rear=0;//åˆå§‹åŒ–å¤´ã€å°¾æŒ‡é’ˆä½ç½®
    q-&gt;data = (ElemType*)malloc(sizeof(ElemType)*q-&gt;capacity);//å¼€è¾ŸåŸºæœ¬å­˜å‚¨æ•°ç»„çš„å­˜å‚¨ç©ºé—´
    if(!q-&gt;data)//åˆ¤æ–­ç©ºé—´å¼€è¾Ÿæƒ…å†µ
    {
        printf(&quot;Memory Error--&gt;deque.data[size]!\n&quot;);
        return NULL;
    }
    return q;//å°†è¯¥é˜Ÿåˆ—è¿”å›
}
//åˆ›å»ºä¸€ä¸ªä»¥sizeä¸ºå®¹é‡çš„åŒç«¯é˜Ÿåˆ—
deque *createADeque(int size)
{
    deque *q = (deque*)malloc(sizeof(deque));
    if(!q)//åˆ¤æ–­ç©ºé—´å¼€è¾Ÿæ˜¯å¦æˆåŠŸ
    {
        printf(&quot;Memory Error--&gt;deque!\n&quot;);
        return NULL;
    }
    //åˆå§‹åŒ–å„é¡¹å‚æ•°
    q-&gt;capacity = size;
    q-&gt;size = 0;
    q-&gt;rear = q-&gt;front = 0;
    q-&gt;data = (ElemType *)malloc(sizeof(ElemType)*q-&gt;capacity);
    if(!q-&gt;data)//ä¸ºæ•°æ®å­˜å‚¨æ•°ç»„å¼€è¾Ÿç©ºé—´
    {
        printf(&quot;Memory Error--&gt;deque.data[size]!\n&quot;);
        return NULL;
    }
    return q;
}

//åˆ¤æ–­é˜Ÿåˆ—æ˜¯å¦ä¸ºç©º
bool isEmpty(deque *q)
{
    return (q-&gt;front==q-&gt;rear);
}
//åˆ¤æ–­é˜Ÿåˆ—æ˜¯å¦ä¸ºæ»¡
bool isFull(deque *q)
{
    return ((q-&gt;rear+1)%maxSize==q-&gt;front);
}
//ä»¥ä¸Šå¯ç”¨sizeä»£æ›¿
//ä»å¤´å…¥é˜Ÿ
bool Push_front(deque *q, ElemType x)
{
    //å¦‚æœé˜Ÿæ»¡åˆ™ä¸æ’å…¥å¹¶è¿”å›
    if(isFull(q))
    {
        return false;
    }
    else//å¦åˆ™
    {
        q-&gt;front = (q-&gt;front-1+maxSize)%maxSize;//å…ˆå°†é˜Ÿå¤´æŒ‡é’ˆé€†æ—¶é’ˆç§»ä¸€ä½
        q-&gt;data[q-&gt;front]=x;//èµ‹å€¼
        q-&gt;size++;
        return true;
    }
}

//ä»å°¾éƒ¨å…¥é˜Ÿ
bool Push_back(deque *q,ElemType x)
{
    if(isFull(q)) //å¦‚æœé˜Ÿæ»¡åˆ™ä¸æ’å…¥å¹¶è¿”å›
    {
        return false;
    }
    else//å¦åˆ™
    {
        q-&gt;data[q-&gt;rear]=x;//å°†æ•°æ®å†™å…¥è¯¥å°¾éƒ¨ä½ç½®
        q-&gt;rear=(q-&gt;rear+1)%maxSize;//å°†å°¾æŒ‡é’ˆåç§»
        q-&gt;size++;
        return true;
    }
}

//å¤´éƒ¨å‡ºé˜Ÿ
ElemType Pop_front(deque *q)
{
    //åˆ¤æ–­æ˜¯å¦ä¸ºç©º
   if(isEmpty(q))
   {
       return -999;
   }
   else//å¦‚æœä¸ä¸ºç©º
   {
       ElemType  x= q-&gt;data[q-&gt;front];//å°†å¤´æŒ‡é’ˆæŒ‡å‘çš„ä½ç½®çš„å€¼èµ‹ç»™x
       q-&gt;front = (q-&gt;front+1)%maxSize;//å¤´æŒ‡é’ˆé¡ºæ—¶é’ˆåç§»
       return x;
   }
}
//å¾—åˆ°å¤´éƒ¨å…ƒç´ 
ElemType getFront(deque *q)
{
    if(isEmpty(q))return -999;//å¦‚æœä¸ºç©ºåˆ™è¿”å›-999
    else return q-&gt;data[q-&gt;front];//å¦åˆ™è¿”å›å½“å‰å¤´æŒ‡é’ˆçš„å€¼
}

//å°¾éƒ¨å‡ºé˜Ÿ
ElemType Pop_back(deque *q)
{
    if(isEmpty(q))//åˆ¤æ–­é˜Ÿåˆ—æ˜¯å¦ä¸ºç©º
    {
        return -999;
    }
    else//å¦åˆ™
    {
        q-&gt;rear = (q-&gt;rear+maxSize-1)%maxSize;//å°†å°¾éƒ¨é€†æ—¶é’ˆç§»åŠ¨ä¸€ä½
        ElemType  x = q-&gt;data[q-&gt;rear];//å°†å°¾éƒ¨çš„å€¼ç»™x
        return x;
    }
}
//å¾—åˆ°å°¾æ•°æ®
ElemType getBack(deque *q)
{
    if(isEmpty(q))return -999;//åˆ¤æ–­æ˜¯å¦ä¸ºç©º
    else return q-&gt;data[q-&gt;rear];//è¿”å›å°¾éƒ¨æ•°æ®
}

//æ‰“å°å…¨éƒ¨å…ƒç´ 
void Display(deque *q)
{
    for(int i=0;i&lt;q-&gt;size;i++)
    {
        printf(&quot;%d &quot;,q-&gt;data[(q-&gt;front+i)%maxSize]);
    }
    printf(&quot;\n&quot;);
}
//å¾—åˆ°å½“å‰å…ƒç´ æ•°é‡
int getSize(deque *q)
{
    return q-&gt;size;
}
//å¾—åˆ°å½“å‰é˜Ÿåˆ—çš„æœ€å¤§å®¹é‡
int getCapacity(deque *q)
{
    return q-&gt;capacity;
}


#endif //DEQUE_H
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[æ•°æ®ç»“æ„--äºŒåˆ†æŸ¥æ‰¾]]></title>
        <id>https://abelcorn.cn/post/datastruct_search1</id>
        <link href="https://abelcorn.cn/post/datastruct_search1">
        </link>
        <updated>2019-11-12T13:32:52.000Z</updated>
        <summary type="html"><![CDATA[<p>å•èº«ä½¿äººå¿«ä¹ã€‚<br>
<br><br>
æˆ‘çœŸğŸŒ¶ï¸ğŸ”</p>
]]></summary>
        <content type="html"><![CDATA[<p>å•èº«ä½¿äººå¿«ä¹ã€‚<br>
<br><br>
æˆ‘çœŸğŸŒ¶ï¸ğŸ”</p>
<!--more-->
<pre><code class="language-c">#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;

//åˆ›å»ºä¸€ä¸ªé¡ºåºè¡¨ç»“æ„
typedef struct Table
{
    int *data;//å­˜æ•°æ®
    int length;//è¡¨é•¿åº¦
}table;

//å†’æ³¡æ’åº
void Bubble_Sort(int a[],int n)
{
    int temp;
    int i,j;
    printf(&quot;Original: &quot;);
    for(i=0;i&lt;n;i++)
    {
        printf(&quot;%d &quot;,a[i]);
    }
    printf(&quot;\n&quot;);
    //å…ˆå°†åŸå§‹æ•°æ®æ‰“å°å‡ºæ¥
    //æ’åº
    for(i=0;i&lt;n;i++)
    {
        for(j=0;j&lt;n-i-1;j++)
        {
            if(a[j]&gt;a[j+1])
            {
                temp = a[j];
                a[j] = a[j+1];
                a[j+1]=temp;
            }
        }
    }
}

//åˆ›å»ºé¡ºåºè¡¨
table *createTable()
{
    table *t = (table*)malloc(sizeof(table));
    if(!t)//åˆ¤æ–­ç©ºé—´å¼€è¾Ÿæƒ…å†µ
    {
        printf(&quot;Memory Error!\n&quot;);
        return NULL;
    }
    //è¾“å…¥å­˜å…¥çš„æ•°æ®æ•°é‡
    printf(&quot;How many numbers you want to enter?\n&quot;);
    scanf(&quot;%d&quot;,&amp;t-&gt;length);
    t-&gt;data = (int*)malloc(sizeof(int)*t-&gt;length);
    if(!t-&gt;data)
    {
        printf(&quot;Memory Error!\n&quot;);
        return NULL;
    }
    //åˆ¤æ–­ç©ºé—´å¼€è¾Ÿæƒ…å†µ
    printf(&quot;Enter them:\n&quot;);
    //è¾“å…¥æ•°æ®
    for(int i=0;i&lt;t-&gt;length;i++)
    {
        scanf(&quot;%d&quot;,&amp;t-&gt;data[i]);
    }
    //è°ƒç”¨æ’åºç®—æ³•
    Bubble_Sort(t-&gt;data,t-&gt;length);
    printf(&quot;Now:    &quot;);
    for(int i=0;i&lt;t-&gt;length;i++)
    {
        printf(&quot;%d &quot;,t-&gt;data[i]);
    }
    printf(&quot;\n&quot;);
    //å±•ç¤ºç°åœ¨çš„é¡ºåº
    return t;
}

//äºŒåˆ†æŸ¥æ‰¾
int Binary_Search(const int a[],int x,int n)
{
    int low=0,high=n,mid;
    while(low&lt;=high)//å½“ä½ä½ä¸é«˜äºé«˜ä½æ—¶
    {
        mid = (high+low)/2;//æ±‚å‡ºä¸­é—´ä½
        if(x == a[mid])//åˆ¤æ–­æ˜¯å¦æ˜¯æ­¤æ•°
        {
            return mid;//æ˜¯åˆ™è¿”å›
        }
        else//ä¸æ˜¯
        {
            if(x&gt;a[mid])low = mid+1;
            //è‹¥è¦æ‰¾çš„æ•°å¤§äºä¸­é—´æ•°ï¼Œåˆ™ç¼©å°ç©ºé—´è‡³åŸæ¥çš„[mid,high]
            else high = mid-1;
            //è‹¥è¦æ‰¾çš„æ•°å°äºä¸­é—´æ•°ï¼Œåˆ™ç¼©å°ç©ºé—´è‡³åŸæ¥çš„[low,mid]
        }
    }
    return -1;//æ‰¾ä¸åˆ°
}

int main()
{
    table *t = createTable();//åˆ›å»ºæ­¤é¡ºåºè¡¨
    int x;
    printf(&quot;Enter the number which you wanna find: &quot;);
    scanf(&quot;%d&quot;,&amp;x);//è¾“å…¥ä½ è¦æ‰¾çš„æ•°æ®
    int flag = Binary_Search(t-&gt;data,x,t-&gt;length);//å­˜ä¸‹æ•°æ®åšå¤„ç†
    if(flag!=-1)//æ‰¾åˆ°äº†åˆ™
    {
        printf(&quot;Successful!\n%d 's position is %dth\n&quot;,x,flag+1);
    }
    else//æ²¡æ‰¾åˆ°
    {
        printf(&quot;Failed!\n&quot;);
    }
    return 0;
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[æ•°æ®ç»“æ„--å›¾(é‚»æ¥è¡¨ï¼‰]]></title>
        <id>https://abelcorn.cn/post/datastruct_graph2</id>
        <link href="https://abelcorn.cn/post/datastruct_graph2">
        </link>
        <updated>2019-11-11T13:31:27.000Z</updated>
        <summary type="html"><![CDATA[<p>å•èº«å¥½å•Šï¼Œå¥½å°±å¥½åœ¨æ²¡äººæ‰“æ‰°æˆ‘å†™ä»£ç </p>
]]></summary>
        <content type="html"><![CDATA[<p>å•èº«å¥½å•Šï¼Œå¥½å°±å¥½åœ¨æ²¡äººæ‰“æ‰°æˆ‘å†™ä»£ç </p>
<!--more-->
<pre><code class="language-c">#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;stdbool.h&gt;

#define maxVer 30//æœ€å¤§é¡¶ç‚¹æ•°
#define maxEdges 900//æœ€å¤§è¾¹æ•°
#define maxWeight 100//æœ€å¤§æƒå€¼

//è¾¹ç»“ç‚¹ï¼Œå­˜å‚¨æ¯ä¸€ä¸ªç»“ç‚¹çš„è¾¹é“¾è¡¨
typedef struct ENode
{
    int dest;
    int weight;
    struct ENode* link;
}edgeNode;

//ç‚¹ç»“ç‚¹ï¼Œæ˜¯æ¯ä¸€è¡Œçš„ç¬¬ä¸€ä¸ªç»“ç‚¹
typedef struct VNode
{
    char data;
    struct ENode* adj;   
}verNode;

//å›¾çš„åŸºæœ¬ç»“æ„
typedef struct 
{
    int numVer,numEdge;//ç‚¹æ•°å’Œè¾¹æ•°
    verNode verList[maxVer];//é¡¶ç‚¹ä¿¡æ¯é›†åˆ
}graph;

//è·å–ç‚¹æ€»æ•°
int numofVer(graph *g);
//è·å–è¾¹æ€»æ•°
int numofEdge(graph *g);
//è·å–ç‚¹çš„ä½ç½®
int getVerPos(graph *g, char v);
//è·å–ç¬¬posçš„ä½ç½®é¡¶ç‚¹é¡ºåº
char getInfo(graph *g, int pos);
//è·å–ä¸¤ä¸ªç»“ç‚¹çš„æƒå€¼ä¿¡æ¯
int getWeight(graph *g,char v1,char v2);

//è·å–ç‚¹æ€»æ•°
int numofVer(graph *g)
{
    return g-&gt;numVer;
}

//è·å–è¾¹æ€»æ•°
int numofEdge(graph *g)
{
    return g-&gt;numEdge;
}

//è·å–ç‚¹çš„ä½ç½®
int getVerPos(graph *g, char v)
{
    int i=0;
    while(i&lt;g-&gt;numVer &amp;&amp; g-&gt;verList[i].data != v){i++;}//å½“æ²¡æœ‰æ‰¾åˆ°åŒ¹é…vçš„å°±æŒç»­å¾ªç¯
    if(i&lt;g-&gt;numVer)return i;//å¦‚æœæœ€åæ‰¾åˆ°äº†å°±è¿”å›ä½ç½®ä¿¡æ¯
    else return -1;//ä¸ç„¶å°±è¿”å›-1
}

//è·å–ç¬¬posçš„ä½ç½®é¡¶ç‚¹é¡ºåº
char getInfo(graph *g, int pos)
{
    if(pos!=-1)//ä½ç½®ä¿¡æ¯æ²¡é—®é¢˜
    {
        return g-&gt;verList[pos].data;//è¿”å›è¯¥ä½ç½®çš„ç»“ç‚¹ä¿¡æ¯
    }
    else
    {
        return '#';//å¦åˆ™å°±è¿”å›#è¡¨ç¤ºæœ‰é—®é¢˜
    }
}

//è·å–ä¸¤ä¸ªç»“ç‚¹çš„æƒå€¼ä¿¡æ¯
int getWeight(graph *g,char v1,char v2)
{
    int i=-1,j=-1;
    i = getVerPos(g,v1);
    j = getVerPos(g,v2);
    //è·å–ä¸¤ä¸ªç»“ç‚¹çš„ä½ç½®
    edgeNode *p = g-&gt;verList[i].adj;
    //å°†è¯¥ç»“ç‚¹ä½ç½®çš„é‚»æ¥é“¾è¡¨èµ‹ç»™p
    while(p!=NULL &amp;&amp;p-&gt;dest != j)//å½“pçš„è¾¹ä¸ç­‰äºjçš„ä½ç½®
    {
        p=p-&gt;link;//å°†påç§»
    }
    if(p!=NULL)return p-&gt;weight;//è¿”å›æƒå€¼
    else return -1;//è¿”å›-1
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[æ•°æ®ç»“æ„--å›¾(é‚»æ¥çŸ©é˜µ)]]></title>
        <id>https://abelcorn.cn/post/datastruct_graph1</id>
        <link href="https://abelcorn.cn/post/datastruct_graph1">
        </link>
        <updated>2019-11-11T13:29:08.000Z</updated>
        <summary type="html"><![CDATA[<p>å•èº«ç‹—çš„æ—¥å¸¸ã€‚è‡ªå·±çœ‹</p>
]]></summary>
        <content type="html"><![CDATA[<p>å•èº«ç‹—çš„æ—¥å¸¸ã€‚è‡ªå·±çœ‹</p>
<!--more-->
<pre><code class="language-c">//
// Created by abel on 2019/11/11.
//

#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;stdbool.h&gt;

#define maxVer 30//æœ€å¤§é¡¶ç‚¹æ•°
#define maxEdges 900//æœ€å¤§è¾¹æ•°
#define maxWeight 100//æœ€å¤§æƒå€¼

//å›¾çš„ç»“æ„
typedef struct Graph
{
    int numVer,numEdge;//ç‚¹æ•°å’Œè¾¹æ•°
    int  verList[maxVer];//é¡¶ç‚¹æ•°æ®é›†åˆ
    int edgeList[maxVer][maxVer];//é‚»æ¥çŸ©é˜µ
}graph;

//å»ºç«‹å›¾*
void createGraph(graph *g);
//æ‰“å°å›¾æ•°æ®*
void printGraph(graph *g);
//åˆå§‹åŒ–å›¾*
void initGraph(graph *g);
//å¾—åˆ°é¡¶ç‚¹våœ¨é¡¶ç‚¹æ•°æ®é›†åˆä¸­çš„ä½ç½®*
int getVerPos(graph *g,int v);
//è·å–æ•´ä¸ªå›¾çš„é¡¶ç‚¹æ•°*
int numofVer(graph *g);
//è·å–æ•´ä¸ªå›¾çš„è¾¹æ•°*
int numofEdge(graph *g);
//å¾—åˆ°ä¸¤ä¸ªç‚¹ä¹‹é—´è¾¹çš„æƒå€¼*
int getWeight(graph *g,int v1, int v2);
//å¾—åˆ°é¡¶ç‚¹vçš„ç¬¬ä¸€ä¸ªé‚»æ¥ç‚¹*
int firstNeighbor(graph *g,int v);
//æ’å…¥æ–°é¡¶ç‚¹*
bool insertVer(graph *g);
//æ’å…¥æ–°è¾¹*
bool insertEdge(graph *g);

//å»ºç«‹å›¾
void createGraph(graph *g)
{
    int ver,edge;
    printf(&quot;Number of Ver: &quot;);
    scanf(&quot;%d&quot;,&amp;ver);
    printf(&quot;Number of Edge: &quot;);
    scanf(&quot;%d&quot;,&amp;edge);
    //è¾“å…¥ç‚¹æ•°å’Œè¾¹æ•°
    g-&gt;numVer = ver;
    g-&gt;numEdge = edge;
    //å°†è¾“å…¥çš„ç‚¹æ•°å’Œè¾¹æ•°ç»™å›¾èµ‹å€¼
    printf(&quot;Please enter the data of the vers: \n&quot;);
    int value,j;
    //è¾“å…¥å„é¡¶ç‚¹å¹¶å°†é¡¶ç‚¹æ•°æ®å­˜å…¥é¡¶é›†åˆä¸­
    for(int i=0;i&lt;ver;i++)
    {
        scanf(&quot;%d&quot;,&amp;value);
        g-&gt;verList[i]=value;
        for(j=0;j&lt;ver;j++)//è¾“å…¥æ—¶åˆå§‹åŒ–é‚»æ¥çŸ©é˜µ
        {
            //å¦‚æœå°†å¯¹è§’çº¿å…ƒç´ å…¨éƒ¨å˜ä¸º0,å…¶ä»–çš„éƒ½å˜æˆmaxWeightï¼ŒåŠç›¸å½“äºåˆå§‹åŒ–ä¸ºæ— ç©·å¤§
            g-&gt;edgeList[i][j]=(i==j)?0:maxWeight;
        }
    }
    //åœ¨è¾“å…¥å®Œæ‰€æœ‰é¡¶ç‚¹ä¿¡æ¯åï¼Œå¼€å§‹å­˜å…¥é‚»æ¥çŸ©é˜µ
    printf(&quot;Enter the two Ver and their weight every time:\n&quot;);
    int v1,v2,cost;
    for(int i=0;i&lt;edge;i++)
    {
        scanf(&quot;%d %d %d&quot;,&amp;v1,&amp;v2,&amp;cost);//è¾“å…¥ä¸¤ä¸ªç‚¹åŠå…¶æƒå€¼
        value = getVerPos(g,v1);//å¾—åˆ°ç‚¹1çš„ä½ç½®
        j = getVerPos(g,v2);//å¾—åˆ°ç‚¹2çš„ä½ç½®
        if(value != -1 &amp;&amp; j != -1)//åˆ¤æ–­ä½ç½®æ˜¯å¦æœ‰æ•ˆ
        {
            g-&gt;edgeList[value][j]=cost;//å°†æƒå€¼å­˜å…¥é‚»æ¥çŸ©é˜µ
            g-&gt;edgeList[j][value]=cost;//æ— å‘å›¾å¯¹ç§°å­˜å…¥
        }
        else
        {
            printf(&quot;Error Info!\n&quot;);
            abort();
        }
    }
}

//å¾—åˆ°é¡¶ç‚¹våœ¨é¡¶ç‚¹æ•°æ®é›†åˆä¸­çš„ä½ç½®
int getVerPos(graph *g,int v)
{
    bool flag = false;//è®¾ç½®ä¸€ä¸ªå¼€å…³åˆ¤æ–­æ˜¯å¦æ‰¾åˆ°è¯¥é¡¶ç‚¹
    int i=-1;
    for(i=0;i&lt;g-&gt;numVer;i++)
    {
        if(v==g-&gt;verList[i])//å¦‚æœæ‰¾åˆ°äº†
        {
            flag = true;
            break;//è·³å‡ºå¾ªç¯
        }
    }
    if(flag)//å¦‚æœæ‰¾åˆ°äº†
    {
        return i;//å°†ä½ç½®è¿”å›
    }
    else
    {
        return -1;//å¦åˆ™è¿”å›-1
    }
}

//æ‰“å°å›¾æ•°æ®
void printGraph(graph *g)
{
    printf(&quot;The verList: \n&quot;);//å°†å›¾çš„é¡¶ç‚¹é›†åˆæ‰“å°å‡ºæ¥
    for(int i=0;i&lt;g-&gt;numVer;i++)
    {
        printf(&quot;%d &quot;,g-&gt;verList[i]);
    }
    printf(&quot;\n&quot;);
    printf(&quot;The Matrix Of the List:\n&quot;);//å°†é‚»æ¥æƒå€¼çŸ©é˜µæ‰“å°å‡ºæ¥
    for(int i=0;i&lt;g-&gt;numVer;i++)
    {
        for(int j=0;j&lt;g-&gt;numVer;j++)
        {
            if(g-&gt;edgeList[i][j]==maxWeight)//å¦‚æœæƒå€¼ç­‰äºæœ€å¤§å€¼
            {
                printf(&quot;âˆ &quot;);//ä»¥æ— ç©·å¤§ç¬¦å·æ˜¾ç¤º
                continue;
            }
            else
            {
                printf(&quot;%d &quot;,g-&gt;edgeList[i][j]);//å¦åˆ™æ‰“å°æƒå€¼
            }
        }
        printf(&quot;\n&quot;);
    }
}

//åˆå§‹åŒ–å›¾
void initGraph(graph *g)
{
    for(int i=0;i&lt;g-&gt;numVer;i++)
    {
        for(int j=0;j&lt;g-&gt;numVer;j++)//å°†é‚»æ¥çŸ©é˜µå˜ä¸ºå…¨é›¶çŸ©é˜µ
        {
            g-&gt;edgeList[i][j]=0;
        }
    }
}

//è·å–æ•´ä¸ªå›¾çš„é¡¶ç‚¹æ•°
int numofVer(graph *g)
{
    return g-&gt;numVer;
}

//è·å–æ•´ä¸ªå›¾çš„è¾¹æ•°
int numofEdge(graph *g)
{
    return g-&gt;numEdge;
}

//å¾—åˆ°ä¸¤ä¸ªç‚¹ä¹‹é—´è¾¹çš„æƒå€¼
int getWeight(graph *g,int v1, int v2)
{
    int va,vb;
    int i,j;
    printf(&quot;Enter two vers: \n&quot;);
    scanf(&quot;%d %d&quot;,&amp;va,&amp;vb);
    i = getVerPos(g,va);
    j = getVerPos(g,vb);
    //æŸ¥æ‰¾ä¸¤ä¸ªé¡¶ç‚¹çš„ä½ç½®
    if(i!=-1&amp;&amp;j!=-1)
    {
        return g-&gt;edgeList[i][j];
        //åœ¨é‚»æ¥æƒå€¼çŸ©é˜µä¸­æ‰¾åˆ°è¿™æ¡è·¯å¾„çš„æƒå€¼
    }
    else
    {
        return -1;//å¦åˆ™è¿”å›-1
    }
}

//å¾—åˆ°é¡¶ç‚¹vçš„ç¬¬ä¸€ä¸ªé‚»æ¥ç‚¹
int firstNeighbor(graph *g,int v)
{
    int pos=-1;//ä¸€ä¸ªå›ºå®šçš„ä½ç½®è®°å½•ç¬¦
    if(v!=-1)//å¦‚æœç»™çš„ç‚¹æ˜¯æ­£ç¡®çš„
    {
        for(int j=0;j&lt;g-&gt;numVer;j++)
        {
            if(g-&gt;edgeList[v][j]&gt;0&amp;&amp;g-&gt;edgeList[v][j]&lt;maxWeight)//æŸ¥çœ‹ç‚¹væœ‰æ²¡æœ‰æƒå€¼ä¸ºé0æˆ–è€…éæ— ç©·å¤§çš„è¾¹
            {
                pos = j;//è‹¥æœ‰åˆ™è®°å½•æ­¤ä½ç½®
                break;
            }
        }
    }
    if(pos!=-1)
    {
        return g-&gt;verList[pos];//å°†è¯¥ä½ç½®çš„é¡¶ç‚¹æ•°æ®è¿”å›
    }
    return -1;
}

//æ’å…¥æ–°é¡¶ç‚¹
bool insertVer(graph *g)
{
    printf(&quot;Please enter the ver data: \n&quot;);
    int value;
    scanf(&quot;%d&quot;,&amp;value);
    g-&gt;verList[g-&gt;numVer+1]=value;//å°†æ–°é¡¶ç‚¹çš„æ•°æ®å­˜å…¥é¡¶ç‚¹é›†åˆ
    printf(&quot;Enter the dest ver info and their weight:\n&quot;);
    int ver,cost;
    scanf(&quot;%d %d&quot;,&amp;ver,&amp;cost);//è¾“å…¥ä¸æ–°ç»“ç‚¹é“¾æ¥çš„ç‚¹åŠå…¶æƒå€¼è¾“å…¥
    int i = getVerPos(g,ver);///å¾—åˆ°å·²å­˜åœ¨çš„è¯¥ç‚¹çš„ä½ç½®
    int j = g-&gt;numVer+1;
    if(i!=-1)
    {
        g-&gt;numVer++;
        g-&gt;numEdge++;//å›¾çš„åŸºæœ¬ä¿¡æ¯æ›´æ–°
        for(int k = 0;k&lt;g-&gt;numVer+1;k++)
        {
         g-&gt;edgeList[k][j]=maxWeight;//é‡æ–°å¸ƒç½®é‚»æ¥çŸ©é˜µ
         g-&gt;edgeList[j][k]=maxWeight;
        }
        g-&gt;edgeList[j][j]=0;
        g-&gt;edgeList[i][j]=g-&gt;edgeList[j][i]=cost;//å°†æƒå€¼å†™å…¥çŸ©é˜µä¸­
        return true;
    }
    return false;
}

//æ’å…¥æ–°è¾¹
bool insertEdge(graph *g)
{
    printf(&quot;Enter two ver:\n&quot;);
    int v1,v2;
    scanf(&quot;%d %d&quot;,&amp;v1,&amp;v2);
    int i = getVerPos(g,v1);
    int j = getVerPos(g,v2);//æ‰¾åˆ°è¾“å…¥çš„ä¸¤ä¸ªç‚¹çš„ä½ç½®ä¿¡æ¯
    if(i!=-1 &amp;&amp; j!=-1)
    {
        int weight;
        printf(&quot;Enter the weight between them:\n&quot;);
        scanf(&quot;%d&quot;,&amp;weight);//è¾“å…¥ä¸¤ç‚¹çš„æƒå€¼ä¿¡æ¯ã€€
        g-&gt;edgeList[i][j]=g-&gt;edgeList[j][i]=weight;//èµ‹å€¼
        return true;
    }
    return false;
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[æ•°æ®ç»“æ„å®éªŒ--åœ¨çº¿æµ‹è¯•æäº¤]]></title>
        <id>https://abelcorn.cn/post/dataexp-2</id>
        <link href="https://abelcorn.cn/post/dataexp-2">
        </link>
        <updated>2019-10-25T01:44:17.000Z</updated>
        <summary type="html"><![CDATA[<p>æœ¬æ¬¡æ˜¯é’ˆå¯¹å®éªŒä¸€ã€äºŒçš„åœ¨çº¿é¢˜ç›®ï¼ŒåŒ…æ‹¬ä¸‰é“é¢˜ï¼šåˆå¹¶å‡åºé“¾è¡¨ã€é˜Ÿåˆ—å…ƒç´ ç½®é€†å’Œæ‹¬å·åŒ¹é…é—®é¢˜ã€‚è‹¥æœ‰å†™çš„ä¸å¥½çš„åœ°æ–¹è¿˜è¯·æŒ‡æ­£ã€‚</p>
]]></summary>
        <content type="html"><![CDATA[<p>æœ¬æ¬¡æ˜¯é’ˆå¯¹å®éªŒä¸€ã€äºŒçš„åœ¨çº¿é¢˜ç›®ï¼ŒåŒ…æ‹¬ä¸‰é“é¢˜ï¼šåˆå¹¶å‡åºé“¾è¡¨ã€é˜Ÿåˆ—å…ƒç´ ç½®é€†å’Œæ‹¬å·åŒ¹é…é—®é¢˜ã€‚è‹¥æœ‰å†™çš„ä¸å¥½çš„åœ°æ–¹è¿˜è¯·æŒ‡æ­£ã€‚</p>
<!--more-->
<p><strong>1.åˆå¹¶é“¾è¡¨</strong>:</p>
<ul>
<li>ã€é—®é¢˜æè¿°ã€‘ ä¸¤ä¸ªéé™åºé“¾è¡¨çš„å¹¶é›†ï¼Œä¾‹å¦‚å°†é“¾è¡¨1-&gt;2-&gt;3 å’Œ 2-&gt;3-&gt;5 å¹¶ä¸º 1-&gt;2-&gt;3-&gt;5ï¼Œåªèƒ½è¾“å‡ºç»“æœï¼Œä¸èƒ½ä¿®æ”¹ä¸¤ä¸ªé“¾è¡¨çš„æ•°æ®ã€‚</li>
<li>ã€è¾“å…¥å½¢å¼ã€‘ ç¬¬ä¸€è¡Œä¸ºç¬¬ä¸€ä¸ªé“¾è¡¨çš„å„ç»“ç‚¹å€¼ï¼Œä»¥ç©ºæ ¼åˆ†éš”ã€‚ ç¬¬äºŒè¡Œä¸ºç¬¬äºŒä¸ªé“¾è¡¨çš„å„ç»“ç‚¹å€¼ï¼Œä»¥ç©ºæ ¼åˆ†éš”ã€‚</li>
<li>ã€è¾“å‡ºå½¢å¼ã€‘ åˆå¹¶å¥½çš„é“¾è¡¨ï¼Œä»¥éé™åºæ’åˆ—ï¼Œå€¼ä¸å€¼ä¹‹é—´ä»¥ç©ºæ ¼åˆ†éš”ã€‚</li>
<li>ã€æ ·ä¾‹è¾“å…¥ã€‘ 4 7 10 34 1 4 6 29 34 34 52</li>
<li>ã€æ ·ä¾‹è¾“å‡ºã€‘ 1 4 6 7 10 29 34 52</li>
<li>ã€è¯„åˆ†æ ‡å‡†ã€‘ è¦ä½¿ç”¨é“¾è¡¨å®ç°ï¼Œå¦åˆ™ä¸èƒ½å¾—åˆ†ã€‚</li>
</ul>
<pre><code class="language-c">//@åˆå¹¶é“¾è¡¨
// Created by abel on 2019/10/23.
//
#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;

typedef struct Node {
    int data;
    struct Node *next;
}list;
//è¾“å…¥å¹¶åˆ›å»ºä¸¤ä¸ªåˆå§‹é“¾è¡¨
void create(list *list1,list* list2)
{
    list *p1 = list1;
    list *p2 = list2;
    char ch1,ch2;
    int data;
    do
    {
        scanf(&quot;%d&quot;,&amp;data);
        list *temp;
        temp=(list*)malloc(sizeof(list));
        temp-&gt;next=0;
        temp-&gt;data=data;
        p1-&gt;next=temp;
        p1=p1-&gt;next;


    }while((ch1=getchar())!='\n');

    do
    {
        scanf(&quot;%d&quot;,&amp;data);
        list *temp;
        temp=(list*)malloc(sizeof(list));
        temp-&gt;next=0;
        temp-&gt;data=data;
        p2-&gt;next=temp;
        p2=p2-&gt;next;

    }while((ch2=getchar())!=EOF);
}
//æŒ‰å¤§å°åˆå¹¶é“¾è¡¨
void merge(list *list1,list* list2)
{
    list* p1=list1-&gt;next;
    list* p2=list2-&gt;next;
    list* p=list1;

    while(p1&amp;&amp;p2)
    {
        if(p1-&gt;data&lt;=p2-&gt;data)
        {
            p-&gt;next=p1;
            p=p-&gt;next;
            p1=p1-&gt;next;
        }
        else
        {
            p-&gt;next=p2;
            p=p2;
            p2=p2-&gt;next;
        }
    }
    if(p1)
    {
        p-&gt;next=p1;
    }
    else
    {
        p-&gt;next=p2;
    }
    free(list2);
}
//æ‰“å°é“¾è¡¨å…ƒç´ ï¼ˆæ— é‡å¤å€¼ï¼‰
void display(list *list1)
{
    list* p=list1-&gt;next;
    while(p-&gt;next)
    {
        if(p-&gt;data==p-&gt;next-&gt;data)
        {
            p=p-&gt;next;
        }
        else
        {
            printf(&quot;%d &quot;,p-&gt;data);
            p=p-&gt;next;
        }
    }printf(&quot;%d\n&quot;,p-&gt;data);
}

int main()
{
    list* list1;
    list* list2;
    list1=(list*)malloc(sizeof(list));
    list2=(list*)malloc(sizeof(list));
    list1-&gt;next=NULL;
    list2-&gt;next=NULL;

    create(list1,list2);
    merge(list1,list2);
    display(list1);
    return 0;
}
</code></pre>
<p>*<strong>2.é˜Ÿåˆ—ç½®é€†</strong>ï¼š</p>
<ul>
<li>ã€é—®é¢˜æè¿°ã€‘ å·²çŸ¥Qæ˜¯ä¸€ä¸ªéç©ºé˜Ÿåˆ—ï¼ŒSæ˜¯ä¸€ä¸ªç©ºæ ˆã€‚ä»…ä½¿ç”¨å°‘é‡å·¥ä½œå˜é‡ä»¥åŠå¯¹é˜Ÿåˆ—å’Œæ ˆçš„åŸºæœ¬æ“ä½œï¼Œç¼–å†™ä¸€ä¸ªç®—æ³•ï¼Œå°†é˜Ÿåˆ—Qä¸­çš„æ‰€æœ‰å…ƒç´ é€†ç½®ã€‚</li>
<li>ã€è¾“å…¥å½¢å¼ã€‘ è¾“å…¥çš„ç¬¬ä¸€è¡Œä¸ºé˜Ÿåˆ—å…ƒç´ ä¸ªæ•°ï¼Œç¬¬äºŒè¡Œä¸ºé˜Ÿåˆ—ä»é¦–è‡³å°¾çš„å…ƒç´ </li>
<li>ã€è¾“å‡ºå½¢å¼ã€‘ è¾“å‡ºé˜Ÿåˆ—çš„é€†ç½®</li>
<li>ã€æ ·ä¾‹è¾“å…¥ã€‘ 3 1 2 3</li>
<li>ã€æ ·ä¾‹è¾“å‡ºã€‘ 3 2 1</li>
<li>ã€è¯„åˆ†æ ‡å‡†ã€‘ éœ€é‡‡ç”¨é˜Ÿåˆ—ä¸æ ˆçš„çŸ¥è¯†ï¼Œå¦åˆ™ä¸èƒ½å¾—åˆ†</li>
</ul>
<pre><code class="language-c">//@é˜Ÿåˆ—å…ƒç´ ç½®é€†
// Created by abel on 2019/10/23.
//

#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;stdbool.h&gt;

//å»ºç«‹é˜Ÿåˆ—çš„åŸºæœ¬ç»“æ„
typedef struct Queue
{
    int *data;
    int size;
    int capacity;
    int front,rear;
}queue;

//å»ºç«‹æ ˆçš„åŸºæœ¬ç»“æ„
typedef struct Stack
{
    int *data;
    int top;
    int capacity;
}stack;

//åˆ›å»ºé˜Ÿåˆ—
queue *createQueue(int n)
{
    queue *queue1 = (queue*)malloc(sizeof(queue));
    if(!queue1)
    {
        printf(&quot;Memory Error!\n&quot;);
        return NULL;
    }

    queue1-&gt;capacity = n;
    queue1-&gt;data = (int*)malloc(sizeof(int)*queue1-&gt;capacity);
    queue1-&gt;front=queue1-&gt;rear=-1;
    queue1-&gt;size=0;

    return queue1;
}

//åˆ›å»ºæ ˆ
stack *createStack(int n)
{
    stack *stack1 = (stack*)malloc(sizeof(stack));
    if(!stack1)
    {
        printf(&quot;Memory Error!\n&quot;);
        return NULL;
    }
    stack1-&gt;capacity = n;
    stack1-&gt;data = (int*)malloc(sizeof(stack1-&gt;capacity));
    stack1-&gt;top=-1;

    return stack1;
}

//åˆ¤æ–­æ ˆç©º
bool emptyStack(stack *stack1)
{
    return stack1-&gt;top==-1;
}

//åˆ¤æ–­é˜Ÿç©º
bool emptyQueue(queue *queue1)
{
    return queue1-&gt;size==0;
}

//å…¥æ ˆ
void push(stack *stack1,int elem)
{
    stack1-&gt;top++;
    stack1-&gt;data[stack1-&gt;top]=elem;
}

//å‡ºæ ˆ
void pop(stack *stack1)
{
    if(!emptyStack(stack1))
    {
        printf(&quot;%d &quot;,stack1-&gt;data[stack1-&gt;top]);
        stack1-&gt;top--;
    }
    else
    {
        return;
    }
}

//å…¥é˜Ÿ
void enQueue(queue *queue1,int elem)
{
    queue1-&gt;front++;
    queue1-&gt;data[queue1-&gt;front]=elem;
    queue1-&gt;size++;
    if(queue1-&gt;rear==-1)
    {
        queue1-&gt;rear=0;
    }
}

//å‡ºé˜Ÿ
int deQueue(queue *queue1) {
    if(!emptyQueue(queue1))
    {
        queue1-&gt;size--;
        return queue1-&gt;data[queue1-&gt;rear++];
    }
}

int main()
{
    int n;
    scanf(&quot;%d&quot;,&amp;n);
    queue *queue1 = createQueue(n);
    stack *stack1 = createStack(n);

    int a[n];
    for(int i=0;i&lt;n;i++)
    {
        scanf(&quot;%d&quot;,&amp;a[i]);
    }
    for(int i=0;i&lt;n;i++)
    {
        enQueue(queue1,a[i]);
    }
    for(int i=0;i&lt;n;i++)
    {
        push(stack1,deQueue(queue1));
    }
    for(int i=0;i&lt;n;i++)
    {
        pop(stack1);
    }

    return 0;
}
</code></pre>
<p><strong>3.æ‹¬å·åŒ¹é…</strong>ï¼š</p>
<ul>
<li>ã€é—®é¢˜æè¿°ã€‘ å‡è®¾ä¸€ç®—æœ¯è¡¨è¾¾å¼ä¸­åŒ…æ‹¬ä¸‰ç§æ‹¬å·ï¼šåœ†æ‹¬å·â€œï¼ˆâ€å’Œâ€œï¼‰â€ï¼Œæ–¹æ‹¬å·â€œ[â€å’Œâ€œ]â€ï¼ŒèŠ±æ‹¬å·â€œ{â€å’Œâ€œ}â€ï¼Œä¸”ä¸‰ç§æ‹¬å·å¯æŒ‰æ„æ¬¡åºåµŒå¥—ä½¿ç”¨ï¼Œè¯•ç¼–å†™ç¨‹åºåˆ¤å®šè¾“å…¥çš„è¡¨è¾¾å¼æ‰€å«çš„æ‹¬å·æ˜¯å¦æ­£ç¡®é…å¯¹å‡ºç°ã€‚è‹¥åŒ¹é…ï¼Œåˆ™è¿”å›1ï¼Œå¦åˆ™è¿”å›0ã€‚</li>
<li>ã€è¾“å…¥å½¢å¼ã€‘ å«æ‹¬å·çš„ç®—æ•°è¡¨è¾¾å¼</li>
<li>ã€è¾“å‡ºå½¢å¼ã€‘ è‹¥è¡¨è¾¾å¼ä¸­çš„æ‹¬å·æ­£ç¡®é…å¯¹ï¼Œåˆ™è¾“å‡º1ã€‚å¦åˆ™ï¼Œè¾“å‡º0ã€‚</li>
<li>ã€æ ·ä¾‹è¾“å…¥ã€‘ 3+(44*[5-{6*[7*(45-10)]}])</li>
<li>ã€æ ·ä¾‹è¾“å‡ºã€‘ 1</li>
<li>ã€æ ·ä¾‹è¯´æ˜ã€‘ åˆ¤æ–­æ‹¬å·æ˜¯å¦åŒ¹é…æ¶‰åŠä¸¤æ–¹é¢çš„é—®é¢˜ï¼Œä¸€æ˜¯å¯¹å·¦å³æ‹¬å·çš„å‡ºç°æ¬¡æ•°çš„åˆ¤å®šï¼ŒäºŒæ˜¯å¯¹ä¸åŒæ‹¬å·çš„å‡ºç°æ¬¡åºçš„åˆ¤å®šã€‚</li>
</ul>
<pre><code class="language-c">//@æ‹¬å·åŒ¹é…
// Created by abel on 2019/10/23.
//


#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;stdbool.h&gt;


typedef struct Stack
{
    char *data;
    int capacity;
    int top;
}stack;

stack *createStack()
{
    stack *stack1 = (stack*)malloc(sizeof(stack));
    if(!stack1)
    {
        printf(&quot;Memory Error!\n&quot;);
        return NULL;
    }

    stack1-&gt;top=-1;
    stack1-&gt;capacity = 10;
    stack1-&gt;data = (char*)malloc(sizeof(char)*stack1-&gt;capacity);
    if(!stack1-&gt;data)
    {
        printf(&quot;Memory Error!\n&quot;);
        return NULL;
    }

    return stack1;
}

bool isFull(stack *stack1)
{
    return stack1-&gt;top==stack1-&gt;capacity-1;
}

bool isEmpty(stack *stack1)
{
    return stack1-&gt;top==-1;
}

void push(stack *stack1,char elem)
{
    if(!isFull(stack1))
    {
        stack1-&gt;top++;
        stack1-&gt;data[stack1-&gt;top]=elem;
    }
    else
    {
        stack1-&gt;capacity = stack1-&gt;capacity*2;
        stack1-&gt;data = realloc(stack1-&gt;data, sizeof(stack1-&gt;capacity));
        stack1-&gt;top++;
        stack1-&gt;data[stack1-&gt;top]=elem;
    }
}

char pop(stack *stack1)
{
    if(!isEmpty(stack1))
    {
        return stack1-&gt;data[stack1-&gt;top--];
    }
    else
    {
        return 0;
    }
}

int start()
{
    stack *stack1 = createStack();
    char ch;
    int flag = 0;
    while((ch=getchar())!='\n'&amp;&amp;ch!=EOF)
    {
        if((ch=='(')||(ch=='[')||(ch=='{'))
        {
            push(stack1,ch);

        }
        else if((ch==')')||(ch==']')||(ch=='}'))
        {
            char temp;
            switch (ch)
            {
                case ')':
                {
                    temp=pop(stack1);
                    if(temp=='(')
                    {
                        flag=1;
                        continue;
                    }
                    flag=0;
                    break;
                }
                case ']':
                {
                    temp = pop(stack1);
                    if(temp=='[')
                    {
                        flag=1;
                        continue;
                    }
                    flag=0;
                    break;
                }
                case '}':
                {
                    temp=pop(stack1);
                    if(temp=='{')
                    {
                        flag=1;
                        continue;
                    }
                    flag=0;
                    break;
                }
            }
        }
        else{flag=1;}
    }
    if (!isEmpty(stack1))
    {
        flag=0;
    }
    return flag;
}

int main()
{
    int a=0;
    a=start();
    printf(&quot;%d\n&quot;,a);

    return 0;
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[æ•°æ®ç»“æ„--å¾ªç¯é˜Ÿåˆ—]]></title>
        <id>https://abelcorn.cn/post/queue</id>
        <link href="https://abelcorn.cn/post/queue">
        </link>
        <updated>2019-10-19T02:38:26.000Z</updated>
        <summary type="html"><![CDATA[<p>ä¸€èˆ¬å¾ªç¯æ•°ç»„é˜Ÿåˆ—</p>
]]></summary>
        <content type="html"><![CDATA[<p>ä¸€èˆ¬å¾ªç¯æ•°ç»„é˜Ÿåˆ—</p>
<!--more-->
<p><strong>Cè¯­è¨€ç‰ˆ</strong>:</p>
<pre><code class="language-c">//@å¾ªç¯æ•°ç»„é˜Ÿåˆ— Cè¯­è¨€ç‰ˆ
// Created by abel on 2019/10/19.
//

#ifndef C_DATASTRUCTURES_QUEUE_H
#define C_DATASTRUCTURES_QUEUE_H

#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;stdbool.h&gt;

#define MAXSIZE 5//é»˜è®¤æœ€å¤§å®¹é‡

//é˜Ÿåˆ—çš„ç»“ç‚¹
typedef struct Queue
{
    int *data;//æ•°ç»„
    int capacity;//åˆå§‹å®¹é‡
    int front;//å¤´
    int rear;//å°¾
    int size;//è®¡æ•°
}queue;

//åˆ›å»ºé˜Ÿåˆ—
queue *createQueue()
{
    queue *queue1 = (queue*)malloc(sizeof(queue));//å¼€è¾Ÿé˜Ÿåˆ—ç©ºé—´
    if(!queue1)//æ£€æŸ¥é˜Ÿåˆ—ç©ºé—´å¼€è¾Ÿæ˜¯å¦æˆåŠŸ
    {
        printf(&quot;Memory Error\n&quot;);
        return NULL;
    }
    //åˆå§‹åŒ–é˜Ÿåˆ—
    queue1-&gt;capacity = MAXSIZE;
    queue1-&gt;data = (int*)malloc(sizeof(int)*queue1-&gt;capacity);
    if(!queue1-&gt;data)//ä¸ºå¾ªç¯æ•°ç»„å¼€è¾Ÿç©ºé—´
    {
        printf(&quot;Memory Error\n&quot;);
        return NULL;
    }
    //åˆå§‹åŒ–é˜Ÿåˆ—
    queue1-&gt;front=queue1-&gt;rear=-1;
    queue1-&gt;size=0;

    for(int i=0;i&lt;3;i++)//åˆå§‹åŒ–3ä¸ªæ•°æ®åšæµ‹è¯•
    {
        queue1-&gt;data[i]=i+1;
    }
    queue1-&gt;front=2;//å¤´ç´¢å¼•ç§»åŠ¨åˆ°2
    queue1-&gt;size=3;//è®¡æ•°
    return queue1;//å°†æ­¤é˜Ÿåˆ—è¿”å›
}

//åˆ¤æ–­æ˜¯å¦ä¸ºç©ºé˜Ÿåˆ—
bool isEmpty(queue *queue1)
{
    return queue1-&gt;size==0;
}

//åˆ¤æ–­æ˜¯å¦ä¸ºæ»¡é˜Ÿåˆ—
bool isFull(queue *queue1)
{
    return queue1-&gt;size==queue1-&gt;capacity;
}

//å…¥é˜Ÿ
void enQueue(queue *queue1,int elem)
{
    if(!isFull(queue1))//åˆ¤æ–­æ˜¯å¦æ»¡é˜Ÿ
    {
        queue1-&gt;front = (queue1-&gt;front+1)%queue1-&gt;capacity;//ç§»åŠ¨å½“å‰ä½ç½®
        queue1-&gt;data[queue1-&gt;front]=elem;//å­˜å…¥æ–°æ•°æ®
        queue1-&gt;size++;//è®¡æ•°å¢åŠ 
        if(queue1-&gt;rear==-1)
        {
            queue1-&gt;rear=0;
        }
    }
    else
    {
        printf(&quot;Full!\n&quot;);
    }
}
//å‡ºé˜Ÿ
void deQueue(queue *queue1)
{
    if(!isEmpty(queue1))//åˆ¤æ–­æ˜¯å¦ä¸ºç©º
    {
        printf(&quot;%d&quot;,queue1-&gt;data[queue1-&gt;rear]);//æ‰“å°æ­¤æ—¶çš„æ•°æ®
        queue1-&gt;rear=(queue1-&gt;rear+1)%queue1-&gt;capacity;
        queue1-&gt;size--;//å‡å°‘è®¡æ•°
    }
    else
    {
        printf(&quot;Empty!\n&quot;);
    }
}

#endif //C_DATASTRUCTURES_QUEUE_H
</code></pre>
<p><strong>C++ç‰ˆæœ¬</strong>:</p>
<pre><code class="language-c++">//@å¾ªç¯æ•°ç»„é˜Ÿåˆ— CPPç‰ˆ
// Created by abel on 2019/10/19.
//
#ifndef CPP_DATASTRUCTURES_QUEUE_H
#define CPP_DATASTRUCTURES_QUEUE_H

#include &lt;iostream&gt;
using namespace std;

const int MaxSize = 10;//é»˜è®¤æœ€å¤§é•¿åº¦

class Queue//é˜Ÿåˆ—ç±»
{
private:
    int *data;//å¾ªç¯æ•°ç»„
    int capacity;//æœ€å¤§å®¹é‡
    int front;
    int rear;
    int size;//è®¡æ•°
public:
    Queue()//æ„é€ å‡½æ•°
    {
        //åˆå§‹åŒ–ç±»
        capacity = MaxSize;
        data = new int[capacity];
        front=rear=-1;
        size=0;
    }
//    ~Queue()//ææ„å‡½æ•°
//    {
//        delete []data;
//    }
    //åˆ¤æ–­ä¸ºç©ºé˜Ÿåˆ—
    bool isEmpty()
    {
        return size==0;
    }
    //åˆ¤æ–­ä¸ºæ»¡é˜Ÿåˆ—
    bool isFull()
    {
        return size==capacity;
    }
    void enQueue(int elem);//å…¥é˜Ÿ
    void deQueue();//å‡ºé˜Ÿ
};

void Queue::enQueue(int elem) {
    if(!isFull())
    {
        front=(front+1)%capacity;
        data[front] = elem;
        size++;
        if(rear==-1)
        {
            rear=0;
        }
    }
    else
    {
        cout&lt;&lt;&quot;Full!&quot;&lt;&lt;endl;
    }
}

void Queue::deQueue() {
    if(!isEmpty())
    {
        cout&lt;&lt;data[rear]&lt;&lt;endl;
        rear = (rear+1)%capacity;
        size--;
    }
    else
    {
        cout&lt;&lt;&quot;Empty!&quot;&lt;&lt;endl;
    }
}

#endif //CPP_DATASTRUCTURES_QUEUE_H

</code></pre>
<p><strong>Javaç‰ˆæœ¬</strong>:</p>
<pre><code class="language-java">//@å¾ªç¯æ•°ç»„é˜Ÿåˆ— Javaç‰ˆ
// Created by abel on 2019/10/19.
//
public class Queue//é˜Ÿåˆ—ç±»
{
	final int MaxSize = 10;//é»˜è®¤åˆå§‹é•¿åº¦
	private int [] data;//å¾ªç¯æ•°ç»„
	private int capacity;//æœ€å¤§å®¹é‡
	private int front;
	private int rear;
	private int size;//è®¡æ•°
	//æ„é€ ä½“
	public Queue()
	{
		//åˆå§‹åŒ–é˜Ÿåˆ—
		this.capacity = MaxSize;
		this.data = new int[this.capacity];
		this.front=this.rear=-1;
		this.size=0;
	}
	//åˆ¤æ–­ä¸ºç©ºé˜Ÿåˆ—
	public boolean isEmpty()
	{
		return size==0;
	}
	//åˆ¤æ–­ä¸ºæ»¡é˜Ÿåˆ—
	public boolean isFull()
	{
		return size==this.capacity;
	}
	//å…¥é˜Ÿ
	public void enQueue(int elem)
	{
		if(!isFull())
		{
			this.front = (this.front+1)%this.capacity;
			data[this.front]=elem;
			this.size++;
			if(this.rear==-1)
			{
				this.rear=0;
			}
		}
		else
		{
			System.out.println(&quot;Full!&quot;);
		}
	}
	//å‡ºé˜Ÿ
	public void deQueue()
	{
		if(!isEmpty())
		{
			System.out.println(data[rear]);
			this.rear = (this.rear+1)%this.capacity;
			this.size--;
		}
		else
		{
			System.out.println(&quot;Empty!&quot;);
		}
	}
}
</code></pre>
<p><strong>C#ç‰ˆæœ¬</strong>ï¼š</p>
<pre><code class="language-c#">//@å¾ªç¯æ•°ç»„é˜Ÿåˆ— C#ç‰ˆ
// Created by abel on 2019/10/19.
//
using System;

public class Queue//é˜Ÿåˆ—çš„ç±»
{
    const int MAXSIZE = 10;//é»˜è®¤æœ€å¤§å®¹é‡
    private int size;//è®¡æ•°
    private int capacity;//æœ€å¤§å®¹é‡
    private int front;//
    private int rear;
    private int[] data;//å¾ªç¯æ•°ç»„
    //æ„é€ ä½“
    public Queue()
    {
        this.capacity = MAXSIZE;
        this.data = new int[capacity];
        this.front = this.rear = -1;
        this.size = 0;
        //åˆå§‹åŒ–æ‰€æœ‰ä¿¡æ¯
    }
    //åˆ¤æ–­ä¸ºç©ºé˜Ÿ
    public bool isEmpty()
    {
        return size == 0;
    }
    //åˆ¤æ–­ä¸ºæ»¡é˜Ÿ
    public bool isFull()
    {
        return size == capacity;
    }
    //å…¥é˜Ÿ
    public void enQueue(int elem)
    {
        if(!isFull())
        {
            front = (front + 1) % capacity;
            data[front] = elem;
            size++;
            if(rear==-1)
            {
                rear = 0;
            }
        }
        else
        {
            Console.WriteLine(&quot;Full!&quot;);
        }
    }
    public void deQueue()
    {
        if(!isEmpty())
        {
            Console.WriteLine(data[rear]);
            rear = (rear + 1) % capacity;
            size--;
        }
        else
        {
            Console.WriteLine(&quot;Empty!&quot;);
        }
    }
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[æ•°æ®ç»“æ„å®éªŒ--çº¦ç‘Ÿå¤«ç¯]]></title>
        <id>https://abelcorn.cn/post/datastructures_ex_josephus</id>
        <link href="https://abelcorn.cn/post/datastructures_ex_josephus">
        </link>
        <updated>2019-10-19T01:32:21.000Z</updated>
        <summary type="html"><![CDATA[<p>Josephusæ’åˆ—é—®é¢˜å®šä¹‰å¦‚ä¸‹ï¼šå‡è®¾nä¸ªç«èµ›è€…æ’æˆä¸€ä¸ªç¯å½¢ã€‚ç»™å®šä¸€ä¸ªæ­£æ•´æ•°mâ‰¤nï¼Œä»ç¬¬1äººå¼€å§‹ï¼Œæ²¿ç¯è®¡æ•°ï¼Œç¬¬mäººå‡ºåˆ—ã€‚è¿™ä¸ªè¿‡ç¨‹ä¸€ç›´è¿›è¡Œåˆ°æ‰€æœ‰äººéƒ½å‡ºåˆ—ä¸ºæ­¢ã€‚æœ€åå‡ºåˆ—è€…ä¸ºä¼˜èƒœè€…ã€‚å…¨éƒ¨å‡ºåˆ—æ¬¡åºå®šä¹‰äº†1ï¼Œ2ï¼Œâ€¦nçš„ä¸€ä¸ªæ’åˆ—ã€‚ç§°ä¸ºï¼ˆnï¼Œmï¼‰Josephusæ’åˆ—ã€‚ä¾‹å¦‚ï¼Œï¼ˆ7ï¼Œ3ï¼‰Josephusæ’åˆ—ä¸º3,6,2,7,5,1,4ã€‚ä¸”è‹¥mä¸ºå¶æ•°åˆ™é€†æ—¶é’ˆå¼€å§‹ï¼Œä¸ºå¥‡æ•°ä¸ºé¡ºæ—¶é’ˆã€‚</p>
]]></summary>
        <content type="html"><![CDATA[<p>Josephusæ’åˆ—é—®é¢˜å®šä¹‰å¦‚ä¸‹ï¼šå‡è®¾nä¸ªç«èµ›è€…æ’æˆä¸€ä¸ªç¯å½¢ã€‚ç»™å®šä¸€ä¸ªæ­£æ•´æ•°mâ‰¤nï¼Œä»ç¬¬1äººå¼€å§‹ï¼Œæ²¿ç¯è®¡æ•°ï¼Œç¬¬mäººå‡ºåˆ—ã€‚è¿™ä¸ªè¿‡ç¨‹ä¸€ç›´è¿›è¡Œåˆ°æ‰€æœ‰äººéƒ½å‡ºåˆ—ä¸ºæ­¢ã€‚æœ€åå‡ºåˆ—è€…ä¸ºä¼˜èƒœè€…ã€‚å…¨éƒ¨å‡ºåˆ—æ¬¡åºå®šä¹‰äº†1ï¼Œ2ï¼Œâ€¦nçš„ä¸€ä¸ªæ’åˆ—ã€‚ç§°ä¸ºï¼ˆnï¼Œmï¼‰Josephusæ’åˆ—ã€‚ä¾‹å¦‚ï¼Œï¼ˆ7ï¼Œ3ï¼‰Josephusæ’åˆ—ä¸º3,6,2,7,5,1,4ã€‚ä¸”è‹¥mä¸ºå¶æ•°åˆ™é€†æ—¶é’ˆå¼€å§‹ï¼Œä¸ºå¥‡æ•°ä¸ºé¡ºæ—¶é’ˆã€‚</p>
<!--more-->
<p><strong>Cè¯­è¨€</strong>ï¼š</p>
<pre><code class="language-c">//@çº¦ç‘Ÿå¤«ç¯ Cè¯­è¨€ç‰ˆæœ¬
// Created by abel on 2019/10/18.
//

#ifndef CLIONCODE_JOSEPHUS_H
#define CLIONCODE_JOSEPHUS_H

#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;stdbool.h&gt;

//çº¦ç‘Ÿå¤«ç¯ç»“ç‚¹
typedef struct Josephus
{
    int data;//æ¯ä¸ªç»“ç‚¹çš„æ•°æ®
    struct Josephus *front;//æŒ‡å‘å‰é©±
    struct Josephus *next;//æŒ‡å‘åç»§
}list;


//é¡ºåºæ‰“å°ä¸€æ¬¡
void display(list *list1,int m)
{
    if(m%2==0)
    {
        list *p = list1;
        printf(&quot;çº¦ç‘Ÿå¤«ç¯å½“å‰æ•°æ®ä¸ºï¼š\n&quot;);
        while (p-&gt;front!=list1)
        {
            printf(&quot;%d &quot;,p-&gt;data);
            p=p-&gt;front;
        }
        printf(&quot;%d\n&quot;,p-&gt;data);
    } else
    {
        list *p = list1;
        printf(&quot;çº¦ç‘Ÿå¤«ç¯å½“å‰æ•°æ®ä¸ºï¼š\n&quot;);
        while (p-&gt;next!=list1)
        {
            printf(&quot;%d &quot;,p-&gt;data);
            p=p-&gt;next;
        }
        printf(&quot;%d\n&quot;,p-&gt;data);
    }
}

//å…·ä½“çš„æ“ä½œå‡½æ•°
void startTheGame(list *list1,int n,int m)
{
    if(m==0)//å¦‚æœmä¸º0ï¼Œåˆ™æ— æ³•è¿›è¡Œæ¸¸æˆ
    {
        printf(&quot;Invalid Index of m!\n&quot;);
    }
    else if(m%2==0)//å¦‚æœæ“ä½œåºåˆ—ä¸ºå¶æ•°ï¼Œåˆ™é€†æ—¶é’ˆæ¸¸æˆ
    {
        list *p = list1;
        //å½“ç»“ç‚¹æ•°ä¸ä¸º0
        printf(&quot;æŒ‰%dä¸ºæ­¥é•¿çš„åºåˆ—ä¸º:\n&quot;,m);
        for(int i=1;n!=0;i++)
        {
            if(i%m==0)
            {
                printf(&quot;%d &quot;,p-&gt;data);//æ‰“å°ç»“ç‚¹æ•°æ®
                list *temp = p;//ä¸­é—´ä¿å­˜è¢«åˆ é™¤ç»“ç‚¹çš„ä¸´æ—¶ç»“ç‚¹
                p = p-&gt;front;//å°†æ“ä½œæŒ‡é’ˆç§»åˆ°ä¸Šä¸€ä½
                //å°†å·²ç»æ‰“å°è¿‡çš„ç»“ç‚¹ä¸é“¾è¡¨æ–­å¼€
                p-&gt;next-&gt;next-&gt;front = p;
                p-&gt;next = p-&gt;next-&gt;next;
                //å°†ä¸´æ—¶ç»“ç‚¹å€¼ä¿®æ”¹
                temp-&gt;data=0;
                temp-&gt;front=temp-&gt;next=NULL;
                free(temp);//é‡Šæ”¾è¢«æ‰“å°è¿‡çš„ç»“ç‚¹
                n--;
            }
            else//å¦‚æœæ²¡æœ‰ç§»åˆ°å›ºå®šçš„æ­¥é•¿mï¼Œåˆ™ç»§ç»­ç§»åŠ¨
            {
                p=p-&gt;front;
            }
        }
    }
    else//å¦‚æœmä¸ºå¥‡æ•°ï¼Œåˆ™é¡ºæ—¶é’ˆå¼€å§‹
    {
        list *p = list1;//æ“ä½œæŒ‡é’ˆ
        printf(&quot;æŒ‰%dä¸ºæ­¥é•¿çš„åºåˆ—ä¸º:\n&quot;,m);
        for(int i=1;n!=0;i++)//å¾ªç¯
        {
            if(i%m==0)//å¦‚æœç§»åŠ¨æ¬¡æ•°ä¸ºm
            {
                printf(&quot;%d &quot;,p-&gt;data);//æ‰“å°æ­¤æ—¶çš„ç»“ç‚¹æ•°æ®
                list *temp = p;//ä¸­é—´ç»“ç‚¹ä¿å­˜è¢«æ‰“å°çš„ç»“ç‚¹
                p=p-&gt;next;//æ“ä½œæŒ‡é’ˆç§»å‘ä¸‹ä¸€ä¸ª
                //å°†è¢«æ‰“å°çš„ç»“ç‚¹ä»é“¾è¡¨ä¸­ç§»é™¤
                p-&gt;front-&gt;front-&gt;next=p;
                p-&gt;front=p-&gt;front-&gt;front;
                //ä¿®æ”¹è¢«æ‰“å°ç»“ç‚¹çš„æ•°æ®
                temp-&gt;data=0;
                temp-&gt;front=temp-&gt;next=NULL;
                free(temp);//é‡Šæ”¾æ­¤ç»“ç‚¹
                n--;//å‡å°‘ç»“ç‚¹æ€»æ•°
            }
            else//å¦‚æœç§»åŠ¨æ­¥æ•°ém
            {
                p=p-&gt;next;//ç§»åŠ¨æ“ä½œæŒ‡é’ˆ
            }
        }
    }
}

//åˆ›å»ºé“¾è¡¨å¹¶æ“ä½œ
list *createLink(int n,int m)//åºåˆ—
{
    list *list1 = (list*)malloc(sizeof(list));//å¼€è¾Ÿç©ºé—´
    if(!list1)//åˆ¤æ–­ç©ºé—´å¼€è¾Ÿæ˜¯å¦æˆåŠŸ
    {
        printf(&quot;Memory Error!\n&quot;);
        return NULL;
    }
    //åˆå§‹åŒ–ç¬¬ä¸€ä¸ªç»“ç‚¹
    list1-&gt;next=list1-&gt;front=NULL;
    list1-&gt;data = 1;

    list *p = list1;//æ“ä½œæŒ‡é’ˆ
    for(int i=2;i&lt;=n;i++)//éå†èµ‹å€¼
    {
        list * temp = (list*)malloc(sizeof(list));//ä¸­é—´ç»“ç‚¹
        if(!temp)//åˆ¤æ–­ç»“ç‚¹ç©ºé—´å¼€è¾Ÿæ˜¯å¦æˆåŠŸ
        {
            printf(&quot;Memory Error!\n&quot;);
            return NULL;
        }
        temp-&gt;data = i;//åºå·èµ‹å€¼
        temp-&gt;next=NULL;//é»˜è®¤nextä¸ºç©º
        temp-&gt;front = p;//å‰å‘æŒ‡é’ˆæŒ‡å‘å½“å‰p
        p-&gt;next=temp;//pçš„ä¸‹ä¸€ä¸ªæ¥ä¸Šä¸­é—´ç»“ç‚¹
        p=p-&gt;next;//pç§»åˆ°ä¸­é—´ç»“ç‚¹ä¸Š
    }
    list1-&gt;front=p;
    p-&gt;next=list1;//å°†å°¾ç»“ç‚¹nextæ¥åˆ°list1(å¤´ç»“ç‚¹)ä¸Š
    return list1;
}

//ç¨‹åºå¯åŠ¨çš„å‡½æ•°
void Josephus()
{
    int n=0,m=0;
    printf(&quot;è¯·è¾“å…¥çº¦ç‘Ÿå¤«åºåˆ—:\n&quot;);
    printf(&quot;æ€»äººæ•°n: &quot;);
    scanf(&quot;%d&quot;,&amp;n);
    printf(&quot;æ“ä½œæ­¥é•¿m: &quot;);
    scanf(&quot;%d&quot;,&amp;m);
    if(n&lt;1)
    {
        printf(&quot;Invalid People Number!\n&quot;);
    }
    else
    {
        if(m&lt;1)
        {
            printf(&quot;Invalid Index!\n&quot;);
        }
        else
        {
            list *list1 = createLink(n,m);
            display(list1,m);
            startTheGame(list1,n,m);
        }
    }
}
#endif //CLIONCODE_JOSEPHUS_H
</code></pre>
<ul>
<li>åœ¨è°ƒç”¨æ—¶ï¼Œmainä¸­</li>
</ul>
<pre><code class="language-c">#include &quot;Josephus.h&quot;
int main()
{
    Josephus();
    return 0;
}
</code></pre>
<ul>
<li>è¿è¡Œç¤ºä¾‹å¦‚ä¸‹ï¼š<br>
<code>è¯·è¾“å…¥çº¦ç‘Ÿå¤«åºåˆ—:</code><br>
<code>æ€»äººæ•°n: 7</code><br>
<code>æ“ä½œæ­¥é•¿m: 3</code><br>
<code>çº¦ç‘Ÿå¤«ç¯å½“å‰æ•°æ®ä¸ºï¼š</code><br>
<code>1 2 3 4 5 6 7</code><br>
<code>æŒ‰3ä¸ºæ­¥é•¿çš„åºåˆ—ä¸º:</code><br>
<code>3 6 2 7 5 1 4</code></li>
</ul>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[æ•°æ®ç»“æ„--é¡ºåºæ ˆ]]></title>
        <id>https://abelcorn.cn/post/stack</id>
        <link href="https://abelcorn.cn/post/stack">
        </link>
        <updated>2019-10-15T01:03:49.000Z</updated>
        <summary type="html"><![CDATA[<p>é¡ºåºæ ˆå°†ä»¥å››ç§è¯­è¨€å‘ˆç°ï¼Œä½†ä¸ä¼šæœ‰å¤ªå¤šæ³¨é‡Šï¼Œ<s>æ¯•ç«Ÿæ¯”è¾ƒç®€å•</s></p>
]]></summary>
        <content type="html"><![CDATA[<p>é¡ºåºæ ˆå°†ä»¥å››ç§è¯­è¨€å‘ˆç°ï¼Œä½†ä¸ä¼šæœ‰å¤ªå¤šæ³¨é‡Šï¼Œ<s>æ¯•ç«Ÿæ¯”è¾ƒç®€å•</s></p>
<!--more-->
<ul>
<li>Cè¯­è¨€ç‰ˆæœ¬</li>
</ul>
<pre><code class="language-c">//@é¡ºåºæ ˆ Cè¯­è¨€ç‰ˆ
// Created by abel on 2019/10/15.
//

#ifndef C_STACK_H
#define C_STACK_H

#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;stdbool.h&gt;
//é»˜è®¤çš„æœ€å¤§é•¿åº¦
#define SIZE 10
//ç»“ç‚¹
typedef struct Stack
{
    int *data;
    int top;
    int capacity;
}stack;

//åˆ›å»ºé“¾è¡¨
stack *createStack()
{
    stack *stack1 = (stack*)malloc(sizeof(stack));
    if(!stack1)//æ£€æŸ¥ç©ºé—´å¼€è¾Ÿæƒ…å†µ
    {
        printf(&quot;Memory Error!\n&quot;);
        return NULL;
    }
    stack1-&gt;capacity = SIZE;//æœ€å¤§é•¿åº¦
    stack1-&gt;data = (int*)malloc(sizeof(int)*stack1-&gt;capacity);//å¼€è¾Ÿæ•°ç»„
    stack1-&gt;top=-1;//æ ˆä½ç½®æ ‡å¿—
    if(!stack1-&gt;data)
    {
        printf(&quot;Memory Error!\n&quot;);
        return NULL;
    }
    for(int i=0;i&lt;3;i++)//åˆå§‹åŒ–èµ‹å€¼è¿›å»
    {
        stack1-&gt;data[i]=i+1;
    }
    stack1-&gt;top=2;//åŠ ä¸¤ä¸ª
    return stack1;
}

//åˆ¤æ–­ä¸ºç©º
bool isEmpty(stack *stack1)
{
    return (stack1-&gt;top==-1);
}

//åˆ¤æ–­ä¸ºæ»¡
bool isFull(stack *stack1)
{
    return stack1-&gt;top==stack1-&gt;capacity-1;
}

//å…¥æ ˆ
void push(stack * stack1,int elem)
{
    if(!isFull(stack1))
    {
        stack1-&gt;data[stack1-&gt;top+1]=elem;
        stack1-&gt;top++;
    } else
    {
        printf(&quot;Full\n&quot;);
    }
}
//å‡ºæ ˆ
int pop(stack* stack1)
{
    if(!isEmpty(stack1))
    {
        return stack1-&gt;data[stack1-&gt;top--];
    }
    printf(&quot;Error\n&quot;);
    return -1;
}

//å¾—åˆ°æ ˆé¡¶å…ƒç´ 
int getElem(stack *stack1)
{
    if(!isEmpty(stack1))
    {
        return stack1-&gt;data[stack1-&gt;top];
    }
    printf(&quot;Error\n&quot;);
    return -1;
}

//æ˜¾ç¤ºæ‰€æœ‰æ•°æ®
void display(stack *stack1)
{
    if(!isEmpty(stack1))
    {
        for(int i=0;i&lt;=stack1-&gt;top;i++)
        {
            printf(&quot;%d &quot;,stack1-&gt;data[i]);
        }
        printf(&quot;\n&quot;);
    }
    else
    {
        printf(&quot;Empty\n&quot;);
        return;
    }
}
#endif //C_STACK_H
</code></pre>
<ul>
<li>C++ç‰ˆæœ¬</li>
</ul>
<pre><code class="language-c++">//@é¡ºåºæ ˆ CPPç‰ˆ
// Created by abel on 2019/10/15.
//

#ifndef C___STACK_H
#define C___STACK_H

#include &lt;iostream&gt;
using namespace std;

const int SIZE = 10;
class Stack
{
private:
    int *data;
    int capacity;
    int top;
public:
    Stack()//åˆ›å»ºæ ˆ
    {
        capacity = SIZE;
        data = new int[capacity];
        top=-1;
    }

    bool isEmpty();//æ ˆç©º

    bool isFull();//æ ˆæ»¡

    void push(int elem);//å…¥æ ˆ

    int getElem();//å¾—åˆ°æœ€ä¸Šé¢å…ƒç´ 

    int pop();//å‡ºæ ˆ

    void display();//æ˜¾ç¤ºæ‰€ä»¥å…ƒç´ ï¼Œåšæ£€æŸ¥
};

bool Stack::isEmpty() {
    return top==-1;
}

bool Stack::isFull() {
    return top+1==capacity;
}

void Stack::push(int elem) {
    if(!isFull())
    {
        data[top+1]=elem;
        top++;
    }
    else
    {
        cout&lt;&lt;&quot;Full!&quot;&lt;&lt;endl;
    }
}

int Stack::getElem() {
    if(!isEmpty())
    {
        return data[top];
    } else
    {
        cout&lt;&lt;&quot;empty&quot;&lt;&lt;endl;
        return -1;
    }
}

int Stack::pop() {
    if(!isEmpty())
    {
        return data[top--];
    }
    else
    {
        cout&lt;&lt;&quot;empty&quot;&lt;&lt;endl;
        return -1;
    }
}

void Stack::display() {
    if(!isEmpty())
    {
        for(int i=0;i&lt;=top;i++)
        {
            cout&lt;&lt;data[i]&lt;&lt;&quot; &quot;;
        }
        cout&lt;&lt;endl;
    }
    else
    {
        cout&lt;&lt;&quot;Empty!\n&quot;;
        return;
    }
}
#endif //C___STACK_H
</code></pre>
<ul>
<li>Javaç‰ˆæœ¬</li>
</ul>
<pre><code class="language-java">//@é¡ºåºæ ˆ Javaç‰ˆ
//Created by abel on 2019/10/15.
//
public class Stack
{
	final int SIZE = 10;
	private int top;
	private int capacity;
	private int[] data;
	
	Stack()
	{
		this.capacity = SIZE;
		this.data = new int[capacity];
		this.top = -1;
	}
	
	public boolean isEmpty()
	{
		return (top==-1);
	}
	public boolean isFull()
	{
		return (top==capacity-1);
	}
	public void enlarge()
	{
		this.capacity *= 2;
		int []temp = new int[top+1];
		for(int i=0;i&lt;top;i++)
		{
			temp[i]=this.data[i];
		}
		this.data = new int[this.capacity];
		for(int i=0;i&lt;top;i++)
		{
			this.data[i] = temp[i];
		}
	}
	public void push(int elem)
	{
		if(!isFull())
		{
			data[top+1]=elem;
			top++;
		}
		else
		{
			System.out.println(&quot;Enlarge...&quot;);
			enlarge();
			data[top+1]=elem;
			top++;
		}
	}
	public int getElem()
	{
		if(!isEmpty())
		{
			return data[top];
		}
		else
		{
			System.out.println(&quot;Empty!&quot;);
			return -1;
		}
	}
	public int pop()
	{
		if(!isEmpty())
		{
			return data[top--];
		}
		else
		{
			System.out.println(&quot;Empty!&quot;);
			return -1;
		}
	}
}
</code></pre>
<ul>
<li>ä»¥ä¸‹ä¸ºC#ç‰ˆæœ¬</li>
</ul>
<pre><code class="language-c#">//@é¡ºåºæ ˆ C#ç‰ˆ
//Created by abel on 2019/10/15.
//

using System;

public class Stack
{
    const int SIZE = 10;
    private int capacity;
    private int top;
    private int[] data;

    public Stack()
    {
        this.capacity = SIZE;
        this.data = new int[capacity];
        this.top = -1;
    }

    public bool isEmpty()
    {
        return (top == -1);
    }
    public bool isFull()
    {
        return (top == capacity - 1);
    }
    public void push(int elem)
    {
        if(!isFull())
        {
            top++;
            data[top] = elem;
        }
        else
        {
            Console.WriteLine(&quot;Full!&quot;);
        }
    }
    public int getELem()
    {
        if(!isEmpty())
        {
            return data[top];
        }
        return -1;
    }
    public int pop()
    {
        if(isEmpty())
        {
            return data[top--];
        }
        return -1;
    }

    
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[æ•°æ®ç»“æ„--å•é“¾è¡¨]]></title>
        <id>https://abelcorn.cn/post/singlelink</id>
        <link href="https://abelcorn.cn/post/singlelink">
        </link>
        <updated>2019-10-14T13:45:44.000Z</updated>
        <summary type="html"><![CDATA[<p>æ²¡äººçœ‹æ²¡äººçœ‹ï¼Œä¼¤å¿ƒğŸ˜£<br>
æœ¬ç‰ˆä¸ºé“¾è¡¨ç»“æ„ä¸­çš„å•é“¾è¡¨ã€‚åŒå‘é“¾è¡¨å’Œå¾ªç¯é“¾è¡¨å°†ä»¥å®éªŒ--çº¦ç‘Ÿå¤«ç¯çš„å®é™…åº”ç”¨çš„æ–¹å¼å‘ˆç°ã€‚</p>
]]></summary>
        <content type="html"><![CDATA[<p>æ²¡äººçœ‹æ²¡äººçœ‹ï¼Œä¼¤å¿ƒğŸ˜£<br>
æœ¬ç‰ˆä¸ºé“¾è¡¨ç»“æ„ä¸­çš„å•é“¾è¡¨ã€‚åŒå‘é“¾è¡¨å’Œå¾ªç¯é“¾è¡¨å°†ä»¥å®éªŒ--çº¦ç‘Ÿå¤«ç¯çš„å®é™…åº”ç”¨çš„æ–¹å¼å‘ˆç°ã€‚</p>
<!--more-->
<ul>
<li>ä»¥ä¸‹ä¸ºCè¯­è¨€çš„å•é“¾è¡¨</li>
</ul>
<pre><code class="language-c">//@å•é“¾è¡¨ Cè¯­è¨€ç‰ˆ
// Created by abel on 2019/10/14.
//

#ifndef C_SINGLELINK_H
#define C_SINGLELINK_H

#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;stdbool.h&gt;

//å•é“¾è¡¨çš„åŸºæœ¬ç»“æ„
typedef struct Link
{
    int data;//æ•°æ®åŸŸ
    struct Link *next;//ç»“ç‚¹
}link;//æ–°åå­—

//åˆå§‹åŒ–åˆ›å»ºé“¾è¡¨
link *createLink()
{
    link *link1 = (link*)malloc(sizeof(link));//åˆ†é…å†…å­˜
    if(!link1)//æ£€æŸ¥å†…å­˜åˆ†é…æˆåŠŸæƒ…å†µ
    {
        printf(&quot;Memory Error!\n&quot;);
        return NULL;
    }
    link1-&gt;data=0;//åˆå§‹åŒ–
    link1-&gt;next=NULL;

    link *p = link1;
    for(int i=0;i&lt;3;i++)//ä¸ºæµ‹è¯•ï¼Œç»™é“¾è¡¨èµ‹åˆå§‹å€¼
    {
        link *a = (link*)malloc(sizeof(link));
        a-&gt;data = i+1;
        a-&gt;next = NULL;

        p-&gt;next = a;
        p=p-&gt;next;
    }
    return link1;
}

//åˆ¤æ–­æ˜¯å¦ä¸ºç©º
bool isEmpty(link *link1)
{
    return (link1==NULL);
}

//æ’å…¥å…ƒç´ 
void insertElem(link *link1,int position,int elem)
{
    if(position&lt;1)//åˆ¤æ–­ä½ç½®
    {
        printf(&quot;Error Position\n&quot;);
    }
    else
    {
        link *p = link1;
        for(int i=0;i&lt;position-1;i++)//éå†åˆ°è¦æ’å…¥çš„ä½ç½®å¤„
        {
            if(p==NULL)
            {
                printf(&quot;Wrong Position\n&quot;);
                exit(-1);
            }
            p=p-&gt;next;
        }
        link *link2 = (link*)malloc(sizeof(link));
        if(!link2)
        {
            printf(&quot;Temp Link Memory Error!\n&quot;);
        }
        //æ’å…¥ç»“ç‚¹
        else{
            link2-&gt;data = elem;
            link2-&gt;next = p-&gt;next;
            p-&gt;next = link2;
        }
    }
}

//åˆ é™¤å…ƒç´ 
int deleteElem(link *link1,int position)
{
    if(!isEmpty(link1))//åˆ¤æ–­æ˜¯å¦ä¸ºç©º
    {
        if(position&lt;1)//åˆ¤æ–­ä½ç½®
        {
            printf(&quot;Error Position\n&quot;);
            return -1;
        }
        else
        {
            link *p = link1;
            for(int i=0;i&lt;position-1;i++)//éå†åˆ°è¦åˆ é™¤çš„åœ°æ–¹
            {
                if(p==NULL)
                {
                    printf(&quot;Error Position\n&quot;);
                    return -1;
                }
                p=p-&gt;next;
            }
            int data = p-&gt;next-&gt;data;//ä¿å­˜è¢«åˆ é™¤çš„å€¼
            link *temp = (link*)malloc(sizeof(link));
            temp-&gt;next = p-&gt;next;
            p-&gt;next=p-&gt;next-&gt;next;//é‡æ–°é“¾æ¥é“¾è¡¨
            free(temp);//é‡Šæ”¾è¢«åˆ é™¤çš„ç»“ç‚¹
            return data;//è¿”å›æ•°æ®
        }
    } else
    {
        printf(&quot;Empty Link\n&quot;);
        return -1;
    }
}

//æŸ¥æ‰¾å…ƒç´ ç¬¬ä¸€æ¬¡å‡ºç°çš„ä½ç½®
int find_position(link *link1,int elem)
{
    if(!isEmpty(link1))//åˆ¤æ–­éç©º
    {
        link *p = link1;
        for(int i=0;p!=NULL;i++)
        {
            p=p-&gt;next;
            if(elem == p-&gt;data)
            {
                return i+1;
            }

        }
    }
    else
    {
        return -2;
    }
    return 0;
}

//éå†æ˜¾ç¤ºå…¨éƒ¨ä¿¡æ¯
void display(link *link1)
{
    if(!isEmpty(link1))//åˆ¤æ–­ç©ºé“¾
    {
        link *p = link1;
        while (p-&gt;next)
        {
            p=p-&gt;next;
            printf(&quot;%d &quot;,p-&gt;data);
        }
        printf(&quot;\n&quot;);
    } else
    {
        printf(&quot;Empty!\n&quot;);
    }
}


#endif //C_SINGLELINK_H
</code></pre>
<ul>
<li>ä»¥ä¸‹ä¸ºC++ç‰ˆæœ¬çš„å•é“¾è¡¨</li>
</ul>
<pre><code class="language-c++">//@å•é“¾è¡¨CPPç‰ˆ
// Created by abel on 2019/10/14.
//

#ifndef C___SINGLELINK_H
#define C___SINGLELINK_H

#include &lt;iostream&gt;
using namespace std;

typedef struct Node
{
    int data;
    Node *next;
}link;

class Link
{
private:
    link *link1;
public:
    //æ„é€ å‡½æ•°
    Link();
    //æ’å…¥å…ƒç´ 
    void insertElem(int position,int elem);
    //æŸ¥çœ‹æ˜¯å¦ä¸ºç©º
    bool isEmpty();
    //å¾—åˆ°å›ºå®šä½ç½®çš„å…ƒç´ 
    int getElem(int position);
    //åˆ é™¤å…ƒç´ 
    int deleteElem(int position);
    //éå†æ˜¾ç¤ºå…¨éƒ¨å…ƒç´ 
    void display();
};

Link::Link() {
    link1 = new link;
    link1-&gt;data = 0;
    link1-&gt;next = nullptr;
}

void Link::insertElem(int position, int elem) {
    if(position&lt;1)
    {
        cout&lt;&lt;&quot;Error Position&quot;&lt;&lt;endl;
    }
    else
    {
        link *p = link1;
        for(int i=0;i&lt;position-1;i++)
        {
            if(p-&gt;next== nullptr)
            {
                cout&lt;&lt;&quot;Error Position!&quot;&lt;&lt;endl;
            }
            p = p-&gt;next;
        }
        link *temp = new link;
        temp-&gt;data=elem;
        temp-&gt;next = p-&gt;next;
        p-&gt;next=temp;
    }
}

bool Link::isEmpty() {
    return (link1-&gt;next== nullptr);
}

int Link::getElem(int position) {
    if(!isEmpty())
    {
        if(position&lt;1)
        {
            cout&lt;&lt;&quot;Error Position!&quot;&lt;&lt;endl;
            return -1;
        }
        else
        {
            link *p = link1;
            for(int i=0;i&lt;position-1;i++)
            {
                if(p-&gt;next== nullptr)
                {
                    cout&lt;&lt;&quot;Error Position&quot;&lt;&lt;endl;
                    break;
                }
                else
                {
                    p=p-&gt;next;
                }
            }
            p=p-&gt;next;
            return p-&gt;data;
        }
    }
    else
    {
        cout&lt;&lt;&quot;Empty!&quot;&lt;&lt;endl;
        return -1;
    }
}

int Link::deleteElem(int position){
    if(!isEmpty())
    {
        if(position&lt;1)
        {
            cout&lt;&lt;&quot;Error Position&quot;&lt;&lt;endl;
            exit(-1);
        }
        else
        {
            link *p = link1;
            for(int i=0;i&lt;position-1;i++)
            {
                if(p-&gt;next == nullptr)
                {
                    cout&lt;&lt;&quot;Error Position&quot;;
                    break;
                }
                else
                {
                    p=p-&gt;next;
                }
            }
            link *temp = new link;
            temp-&gt;next = p-&gt;next;
            temp-&gt;data = p-&gt;next-&gt;data;
            p-&gt;next = p-&gt;next-&gt;next;
            int t = temp-&gt;data;
            delete temp;
            return t;
        }
    }
    else
    {
        cout&lt;&lt;&quot;Empty!&quot;&lt;&lt;endl;
        exit(-1);
    }
}

void Link::display() {
    if(!isEmpty())//åˆ¤æ–­æ˜¯å¦ä¸ºç©º
    {
        link * p = link1;
        while (p-&gt;next)
        {
            p=p-&gt;next;
            cout&lt;&lt;p-&gt;data&lt;&lt;&quot; &quot;;
        }
        cout&lt;&lt;endl;
    }
    else
    {
        cout&lt;&lt;&quot;Error! Empty!&quot;&lt;&lt;endl;
    }
}
#endif //C___SINGLELINK_H
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[æ•°æ®ç»“æ„--é¡ºåºè¡¨]]></title>
        <id>https://abelcorn.cn/post/table</id>
        <link href="https://abelcorn.cn/post/table">
        </link>
        <updated>2019-10-11T13:59:34.000Z</updated>
        <summary type="html"><![CDATA[<ul>
<li>ç”±äºæˆ‘å¤ªç©·äº†ï¼Œä¹°ä¸èµ·matlabï¼Œæ‰€ä»¥å®ƒè¯•ç”¨æœŸåˆ°äº†ï¼Œæˆ‘æš‚æ—¶ä¸å†™matlabçš„ä¸“é¢˜äº†ã€‚</li>
<li>æ¯•ç«Ÿè¿™å­¦æœŸåœ¨å­¦æ•°æ®ç»“æ„ï¼Œè™½ç„¶åªå­¦Cè¯­è¨€ç‰ˆçš„ï¼Œä½†æˆ‘æƒ³æ€»æ˜¯å¤§åŒå°å¼‚å˜›ï¼Œæ‰€ä»¥ä»ç°åœ¨å¼€å§‹æˆ‘ä¼šåŒæ­¥è‡ªå·±çš„ä»£ç ä¸Šæ¥ã€‚PSï¼š<s>å®é™…ä¸Šæ˜¯æ‹…å¿ƒå†™çš„ä»£ç æ²¡äº†ï¼Œæ‰€ä»¥è¿™æ ·ä¿é™©ä¸€ç‚¹ã€‚</s></li>
<li>æˆ‘ä¼šä»¥<s>Cã€C++å’ŒJavaä¸‰ç§è¯­è¨€å†™</s>æ–°å¢C#ï¼Œå½“ç„¶äº†ï¼Œå› ä¸ºJava(å’ŒC#)æ˜¯è‡ªå­¦çš„ï¼Œä¸”æˆªæ­¢ä»Šå¤©æˆ‘æ‰å­¦äº†ä¸¤å¤©ï¼Œæœ‰é—®é¢˜çš„åœ°æ–¹è¿˜æœ›å„ä½å¤§ä½¬æŒ‡æ­£ã€‚</li>
</ul>
]]></summary>
        <content type="html"><![CDATA[<ul>
<li>ç”±äºæˆ‘å¤ªç©·äº†ï¼Œä¹°ä¸èµ·matlabï¼Œæ‰€ä»¥å®ƒè¯•ç”¨æœŸåˆ°äº†ï¼Œæˆ‘æš‚æ—¶ä¸å†™matlabçš„ä¸“é¢˜äº†ã€‚</li>
<li>æ¯•ç«Ÿè¿™å­¦æœŸåœ¨å­¦æ•°æ®ç»“æ„ï¼Œè™½ç„¶åªå­¦Cè¯­è¨€ç‰ˆçš„ï¼Œä½†æˆ‘æƒ³æ€»æ˜¯å¤§åŒå°å¼‚å˜›ï¼Œæ‰€ä»¥ä»ç°åœ¨å¼€å§‹æˆ‘ä¼šåŒæ­¥è‡ªå·±çš„ä»£ç ä¸Šæ¥ã€‚PSï¼š<s>å®é™…ä¸Šæ˜¯æ‹…å¿ƒå†™çš„ä»£ç æ²¡äº†ï¼Œæ‰€ä»¥è¿™æ ·ä¿é™©ä¸€ç‚¹ã€‚</s></li>
<li>æˆ‘ä¼šä»¥<s>Cã€C++å’ŒJavaä¸‰ç§è¯­è¨€å†™</s>æ–°å¢C#ï¼Œå½“ç„¶äº†ï¼Œå› ä¸ºJava(å’ŒC#)æ˜¯è‡ªå­¦çš„ï¼Œä¸”æˆªæ­¢ä»Šå¤©æˆ‘æ‰å­¦äº†ä¸¤å¤©ï¼Œæœ‰é—®é¢˜çš„åœ°æ–¹è¿˜æœ›å„ä½å¤§ä½¬æŒ‡æ­£ã€‚</li>
</ul>
<!--more-->
<p>###é¡ºåºè¡¨-Cè¯­è¨€ç‰ˆï¼š</p>
<pre><code class="language-C">//@é¡ºåºè¡¨ Cç‰ˆæœ¬
// Created by abel on 2019/10/11.
//

#ifndef C_TABLE_H
#define C_TABLE_H

#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;stdbool.h&gt;

#define CAPACITY 10
//ä¸ºè¡¨çš„å®¹é‡åšå‡†å¤‡

//é¡ºåºè¡¨çš„ç»“æ„ä½“
typedef struct Table
{
    int *data;//è¡¨çš„å­˜å‚¨æ•°ç»„ï¼Œä¸ºç®€ä¾¿è¡¨ç¤ºè®¾ç½®ä¸ºint
    int capacity;//è¡¨çš„æœ€å¤§å®¹é‡
    int length;//è¡¨çš„å½“å‰é•¿åº¦
}table;

//åˆ›å»ºè¡¨
table *createTable()
{
    table *table1 = (table*)malloc(sizeof(table));//ç”Ÿæˆè¡¨
    //åˆ¤æ–­å¼€è¾Ÿçš„è¡¨ç©ºé—´åˆ†é…æ˜¯å¦æ­£å¸¸
    if(!table1)
    {
        printf(&quot;Table Memory Error!\n&quot;);
        return NULL;
    }
    table1-&gt;capacity = CAPACITY;//åˆå§‹åŒ–è¡¨çš„å®¹é‡
    table1-&gt;data = (int*)malloc(sizeof(int)*table1-&gt;capacity);//ä¸ºæ•°ç»„å¼€è¾Ÿç©ºé—´
    //åˆ¤æ–­ç©ºé—´å¼€è¾Ÿæ˜¯å¦æˆåŠŸ
    if(!table1-&gt;data)
    {
        printf(&quot;Data Memory Error!\n&quot;);
        return NULL;
    }
    table1-&gt;length=0;//åˆå§‹åŒ–å½“å‰é•¿åº¦ä¸º0

    for(int i=0;i&lt;3;i++)//ç»™åˆå§‹åŒ–æ•°æ®ä¾¿äºæµ‹è¯•
    {
        table1-&gt;data[i]=i+1;
    }
    table1-&gt;length=3;
    return table1;//è¿”å›è¯¥è¡¨
}

//æ£€æŸ¥è¡¨æ˜¯å¦ä¸ºç©º
bool isEmpty(table *table1)
{
    if(table1-&gt;length==0)
    {
        return true;
    }
    return false;
}

//æ£€æŸ¥è¡¨æ˜¯å¦ä¸ºæ»¡
bool isFull(table *table1)
{
    if(table1-&gt;length == table1-&gt;capacity)
    {
        return true;
    }
    return false;
}

//æ‰©å®¹
bool enlargeTable(table *table1)
{
    table1-&gt;capacity *= 2;//å…ˆå°†æœ€å¤§å®¹é‡ä¹˜2
    table1-&gt;data = realloc(table1-&gt;data, sizeof(int)*table1-&gt;capacity*2);//å°†dataæ•°ç»„é‡Œé¢çš„å†…å®¹é‡æ–°æ‰©å±•
    //æ£€æŸ¥æ‰©å®¹æ˜¯å¦æˆåŠŸ
    if(!table1-&gt;data)
    {
        return false;
    }
    return true;
}

//æ–°å¢æ•°æ®
void pushTable(table *table1,int position,int elem)//åˆ†åˆ«æ˜¯è¡¨ã€ä½ç½®å’Œæ–°å¢çš„å…ƒç´ 
{
    if(!isFull(table1))//å…ˆåˆ¤æ–­è¡¨æ˜¯å¦æ»¡äº†
    {
        if(position&lt;1||position&gt;table1-&gt;length)//åˆ¤æ–­æ’å…¥ä½ç½®æ˜¯å¦æœ‰é—®é¢˜
        {
            printf(&quot;æ’å…¥ä½ç½®æœ‰è¯¯!\n&quot;);
            exit(-1);//é€€å‡º
        }
        for(int i=table1-&gt;length;i&gt;=position-1;i--)//éå†å°†æ’å…¥ä½ç½®åŠä¹‹åçš„å…ƒç´ åç§»
        {
            table1-&gt;data[i]=table1-&gt;data[i-1];
        }
        table1-&gt;data[position-1]=elem;//æ’å…¥å…ƒç´ 
        table1-&gt;length++;//å¢åŠ é•¿åº¦
        printf(&quot;å…ƒç´  %d æ–°å¢æˆåŠŸ!\n&quot;,elem);//æ‰“å°æˆåŠŸæ¶ˆæ¯
    }
    else
    {
        printf(&quot;ç©ºé—´ä¸è¶³ï¼Œæ­£åœ¨æ‰©å®¹......!\n&quot;);
        enlargeTable(table1);//æ‰©å¤§å®¹é‡
        //ä»¥ä¸‹åŠŸèƒ½åŒä¸Š
        if(position&lt;1||position&gt;table1-&gt;length)
        {
            printf(&quot;æ’å…¥ä½ç½®æœ‰è¯¯!\n&quot;);
            exit(-1);
        }
        for(int i=table1-&gt;length;i&gt;=position-1;i--)
        {
            table1-&gt;data[i]=table1-&gt;data[i-1];
        }
        table1-&gt;data[position-1]=elem;
        table1-&gt;length++;
        printf(&quot;å…ƒç´  %d æ–°å¢æˆåŠŸ!\n&quot;,elem);
    }
}

//åˆ é™¤æ•°æ®
int popTable(table *table1,int position)//è¡¨ã€æ‰€è¦åˆ é™¤çš„ä½ç½®
{
    if(!isEmpty(table1))//åˆ¤æ–­æ˜¯å¦æ˜¯ç©ºè¡¨
    {
        if(position&lt;1||position&gt;table1-&gt;length)//æ£€æŸ¥åˆ é™¤ä½ç½®æ˜¯å¦æ­£ç¡®
        {
            printf(&quot;åˆ é™¤çš„ä½ç½®æœ‰è¯¯!\n&quot;);
            exit(-2);
        }
        int delete_data = table1-&gt;data[position-1];//è®°å½•è¢«åˆ é™¤çš„å…ƒç´ 
        for(int i=position-1;i&lt;table1-&gt;length;i++)//å¾ªç¯å‰ç§»å…ƒç´ 
        {
            table1-&gt;data[i]=table1-&gt;data[i+1];
        }
        table1-&gt;length--;//å‡å°‘ä¸€ä¸ªé•¿åº¦è®°å½•
        printf(&quot;è¡¨ä¸­ç¬¬ %d å·å…ƒç´  %d åˆ é™¤æˆåŠŸ!\n&quot;,position,delete_data);//å°†æ‰€åˆ é™¤çš„å…ƒç´ æ˜¾ç¤ºå‡ºæ¥
        return delete_data;//è¿”å›å®ƒ
    }
    else
    {
        printf(&quot;è¡¨å·²ç»ç©ºäº†ï¼Œä½ è¿˜åˆ å•¥ï¼Ÿ\n&quot;);
        return -2;
    }
}

//ä¿®æ”¹æ•°æ®
void changeTable(table *table1,int position,int new_elem)//è¡¨ã€ä¿®æ”¹å…ƒç´ çš„ä½ç½®ã€æ–°å…ƒç´ 
{
    if(!isEmpty(table1))//å…ˆåˆ¤æ–­æ˜¯å¦ä¸ºç©º
    {
        if(position&lt;1||position&gt;table1-&gt;length)//åˆ¤æ–­ä½ç½®æ˜¯å¦æœ‰è¯¯
        {
            printf(&quot;ä½ç½®æœ‰è¯¯ï¼\n&quot;);
        }
        else
        {
            table1-&gt;data[position-1] = new_elem;//ä¿®æ”¹å…ƒç´ 
        }
    }
    else//å¦‚æœæ˜¯ç©ºè¡¨
    {
        printf(&quot;ç©ºè¡¨ï¼Œä½ æ”¹ä»€ä¹ˆï¼Ÿ\n&quot;);
    }
}

//æŸ¥æ‰¾å…ƒç´ ç¬¬ä¸€æ¬¡å‡ºç°çš„ä½ç½®
int find_position(table* table1,int elem)
{
    if(!isEmpty(table1))//æ£€æŸ¥æ˜¯å¦ä¸ºç©º
    {
        int  position= -1;//ä½ç½®ä¿¡æ¯ï¼Œé»˜è®¤ä¸º-1
        bool flag = false; //æ˜¯å¦æŸ¥åˆ°çš„æ ‡å¿—
        for(int i=0;i&lt;table1-&gt;length;i++)
        {
            if(elem==table1-&gt;data[i])
            {
                position = i+1;//è®°å½•ä½ç½®
                flag = true;//å¼€å…³æ‰“å¼€
            }
        }
        if(flag)//å¦‚æœæ‰¾åˆ°äº†
        {
            return position;//è¿”å›ä½ç½®
        }
        else
        {
            return -1;//å¦åˆ™è¿”å›-1ï¼›
        }
    }
    else
    {
        return -1;//ç©ºè¡¨ä¹Ÿè¿”å›-1
    }
}

//æŸ¥æ‰¾æŸä¸ªä½ç½®çš„å…ƒç´ 
int find_value(table* table1,int position)
{
    if(!isEmpty(table1))//æ£€æŸ¥æ˜¯å¦ä¸ºç©º
    {
        if(position&lt;1||position&gt;table1-&gt;length)//æ£€æŸ¥ä½ç½®,è‹¥æœ‰é—®é¢˜
        {
            printf(&quot;ä½ç½®æœ‰è¯¯\n&quot;);
            abort();//ç»ˆæ­¢ç¨‹åº
        }
        else//è‹¥ä½ç½®æ­£ç¡®
        {
            return table1-&gt;data[position-1];//è¿”å›è¯¥ä½ç½®çš„å…ƒç´ 
        }
    }
    else
    {
        printf(&quot;ç©ºè¡¨\n&quot;);
        abort();//ç»ˆæ­¢ç¨‹åº
    }
}

//éå†æ‰“å°å‡ºè¡¨ä¸­çš„æ‰€æœ‰æ•°æ®
void displayTable(table *table1)
{
    if(!isEmpty(table1))//é¦–å…ˆåˆ¤æ–­è¡¨æ˜¯å¦ä¸ºç©º
    {
        printf(&quot;è¯¥è¡¨çš„å…¨éƒ¨æ•°æ®ä¸ºï¼š\n&quot;);
        for(int i=0;i&lt;table1-&gt;length;i++)//ä¸ä¸ºç©ºåˆ™å¾ªç¯éå†
        {
            printf(&quot;%d &quot;,table1-&gt;data[i]);//æ‰“å°æ•°å€¼
        }
        printf(&quot;\n&quot;);
    }
    else//è‹¥è¡¨ä¸ºç©º
    {
        printf(&quot;è¡¨ä¸­æ— æ•°æ®ï¼\n&quot;);
    }
}

//åˆ é™¤è¡¨
void deleteTable(table *table1)
{
    table1-&gt;length=0;
    table1-&gt;capacity=0;
    free(table1-&gt;data);
    free(table1);
    //é‡Šæ”¾ç©ºé—´
}
#endif //C_TABLE_H
</code></pre>
<p>###é¡ºåºè¡¨-C++ç‰ˆæœ¬</p>
<pre><code class="language-C++">//@é¡ºåºè¡¨ CPPç‰ˆæœ¬
// Created by abel on 2019/10/11.
//

#ifndef C___TABLE_H
#define C___TABLE_H

#include &lt;iostream&gt;
using namespace std;

const int CAPACITY = 10;//å®šä¹‰åˆå§‹åŒ–æœ€å¤§å®¹é‡

class Table//å®šä¹‰é¡ºåºè¡¨ç±»
{
private:
    int *data;//ç®€å•intæ•°æ®ç±»å‹æ•°ç»„
    int capacity;//æœ€å¤§å®¹é‡
    int length;//å½“å‰é•¿åº¦
public:
    Table()//æ„é€ å‡½æ•°
    {
        capacity = CAPACITY;//æœ€å¤§å®¹é‡
        data = new int[capacity];//åŠ¨æ€å¼€è¾Ÿç©ºé—´
        length=0;//é»˜è®¤é•¿åº¦
        for (int i = 0; i &lt;3 ; i++)//åˆå§‹åŒ–3ä¸ªæ•°æ®åšæµ‹è¯•
        {
            data[i]=i+1;
        }
        length=3;//å½“å‰é•¿åº¦ä¸º3
    }
    bool isEmpty();//åˆ¤æ–­æ˜¯å¦ä¸ºç©º
    bool isFull();//åˆ¤æ–­æ˜¯å¦ä¸ºæ»¡
    void enlarge();//æ‰©å®¹
    void push_back(int position,int elem);//æ’å…¥æ•°æ®
    int pop_back(int position);//å¼¹å‡ºæ•°æ®
    void change(int position,int new_elem);//ä¿®æ”¹å…ƒç´ 
    int find_position(int elem);//æŸ¥æ‰¾å…ƒç´ ç¬¬ä¸€æ¬¡å‡ºç°çš„ä½ç½®
    int find_value(int position);//å¾—åˆ°æŸä¸ªä½ç½®çš„å…ƒç´ 
    void display();//æ‰“å°æ‰€æœ‰æ•°æ®
    void deleteTable();//åˆ é™¤è¡¨
};

//åˆ¤æ–­æ˜¯å¦ä¸ºç©º
bool Table::isEmpty() {
    return length==0;
}

//åˆ¤æ–­æ˜¯å¦ä¸ºæ»¡
bool Table::isFull() {
    return length==capacity;
}

//æ‰©å®¹
void Table::enlarge() {
    capacity *= 2;//å°†æœ€å¤§å®¹é‡ç¿»å€
    int *new_data = new int[length];//å¼€è¾Ÿä¸€ä¸ªä¸´æ—¶ä¸­è½¬çš„æ•°ç»„
    for(int i=0;i&lt;length;i++)//å°†åŸæ¥çš„æ•°ç»„æ‹·è´åˆ°ä¸­è½¬æ•°ç»„ä¸­
    {
        new_data[i]=data[i];
    }
    data = new int[capacity*2];//ç»™dataæ‰©å®¹
    for(int i=0;i&lt;length;i++)//å†å°†ä¸­è½¬æ•°ç»„çš„æ•°æ®è¿˜ç»™data
    {
        data[i]=new_data[i];
    }
    delete [] new_data;//åˆ é™¤ä¸­è½¬æ•°ç»„
    //ä»¥ä¸Šå®é™…å®ç°äº†çš„æ— éæ˜¯Cè¯­è¨€çš„realloc()åŠŸèƒ½
}

//æ’å…¥æ•°æ®
void Table::push_back(int position, int elem) {
    if(!isFull())//æ£€æŸ¥æ˜¯å¦æ»¡è¡¨
    {
        if(position&lt;1||position&gt;length)//æ£€æŸ¥ä½ç½®æ˜¯å¦æœ‰è¯¯
        {
            cout&lt;&lt;&quot;æ’å…¥ä½ç½®æœ‰è¯¯&quot;&lt;&lt;endl;
        }
        else
        {
            for(int i=length;i&gt;=position-1;i--)//éå†å°†æ’å…¥ä½ç½®çš„å…ƒç´ åç§»
            {
                data[i] = data[i-1];
            }
            data[position-1]=elem;//æ–°å¢å…ƒç´ 
            length++;//åŠ å¤§ç©ºé—´
            cout&lt;&lt;&quot;å…ƒç´ &quot;&lt;&lt;elem&lt;&lt;&quot;æ’å…¥æˆåŠŸ&quot;&lt;&lt;endl;
        }
    }
    else//è¡¨æ»¡äº†
    {
        cout&lt;&lt;&quot;æ‰©å®¹ä¸­...&quot;&lt;&lt;endl;
        enlarge();//æ‰©å®¹

        if(position&lt;1||position&gt;length)//æ£€æŸ¥ä½ç½®æ˜¯å¦æœ‰è¯¯
        {
            cout&lt;&lt;&quot;æ’å…¥ä½ç½®æœ‰è¯¯&quot;&lt;&lt;endl;
        }
        else
        {
            for(int i=length;i&gt;=position-1;i--)//éå†å°†æ’å…¥ä½ç½®çš„å…ƒç´ åç§»
            {
                data[i] = data[i-1];
            }
            data[position-1]=elem;//æ–°å¢å…ƒç´ 
            length++;//åŠ å¤§ç©ºé—´
            cout&lt;&lt;&quot;å…ƒç´ &quot;&lt;&lt;elem&lt;&lt;&quot;æ’å…¥æˆåŠŸ&quot;&lt;&lt;endl;
        }
    }
}

//å¼¹å‡ºæ•°æ®
int Table::pop_back(int position) {
    if(!isEmpty())//æ£€æŸ¥æ˜¯å¦ä¸ºç©º
    {
        if(position&lt;1||position&gt;length)//æ£€æŸ¥ä½ç½®
        {
            cout&lt;&lt;&quot;åˆ é™¤ä½ç½®æœ‰è¯¯\n&quot;;
        }
        else
        {
            int temp = data[position-1];//è®°å½•å°†è¦åˆ é™¤çš„å…ƒç´ 
            for(int i=position-1;i&lt;length;i++)//å°†è¯¥å…ƒç´ åé¢çš„å…¨éƒ¨å‰ç§»
            {
                data[i]=data[i+1];
            }
            length--;//å‡å°‘ä¸€ä¸ªå½“å‰é•¿åº¦
            return temp;//å°†åˆ é™¤çš„å…ƒç´ è¿”å›
        }
    }
    else{
        cout&lt;&lt;&quot;ç©ºè¡¨ï¼Œæ— å€¼&quot;;
        return -1;
    }
}

//ä¿®æ”¹å…ƒç´ 
void Table::change(int position, int new_elem) {
    if(!isEmpty())//åˆ¤æ–­éç©º
    {
        if(position&lt;1||position&gt;length)//æ£€æŸ¥ä½ç½®
        {
            cout&lt;&lt;&quot;è¾“å…¥çš„ä½ç½®æœ‰è¯¯&quot;&lt;&lt;endl;
        }
        else
        {
            data[position-1]=new_elem;
            cout&lt;&lt;&quot;ä¿®æ”¹æˆåŠŸ\n&quot;;
        }
    }
    else
    {
        cout&lt;&lt;&quot;ç©ºè¡¨ï¼Œä½ æ”¹ä»€ä¹ˆï¼Ÿ\n&quot;;
    }
}

//æŸ¥æ‰¾å…ƒç´ ç¬¬ä¸€æ¬¡å‡ºç°çš„ä½ç½®
int Table::find_position(int elem) {
    if(!isEmpty())//åˆ¤æ–­éç©º
    {
        int position = -1;//é»˜è®¤ä½ç½®ä¸º-1
        bool flag = false;//æ ‡å¿—
        for(int i=0;i&lt;length;i++)//éå†æŸ¥æ‰¾
        {
            if(data[i]==elem)//å¦‚æœæ‰¾åˆ°äº†
            {
                flag = true;//æ ‡å¿—è®¾ä¸ºçœŸ
                position = i+1;//è®°å½•å½“å‰ä½ç½®
                break;//è·³å‡ºå¾ªç¯
            }
        }
        if(flag)//å¦‚æœæ ‡å¿—ä¸ºçœŸï¼Œå³æ‰¾åˆ°äº†
        {
            return position;//åˆ™è¿”å›ç¬¬ä¸€æ¬¡å‡ºç°çš„ä½ç½®
        }
        else
        {
            return -1;//å¦åˆ™è¿”å›-1ï¼ˆå› ä¸ºä½ç½®æ²¡æœ‰-1ï¼Œæ•…è¡¨ç¤ºæ²¡æ‰¾åˆ°ï¼‰
        }
    }
    else
    {
        cout&lt;&lt;&quot;ç©ºè¡¨ï¼Œä½ æ‰¾ä»€ä¹ˆï¼Ÿ&quot;&lt;&lt;endl;
        return -1;
    }
}

//å¾—åˆ°æŸä¸ªä½ç½®çš„å…ƒç´ 
int Table::find_value(int position) {
    if(!isEmpty())//åˆ¤æ–­éç©º
    {
        if(position&lt;1||position&gt;length)//æ£€æŸ¥ä½ç½®
        {
            cout&lt;&lt;&quot;ä½ç½®é”™è¯¯&quot;;
            abort();//ç»ˆæ­¢ç¨‹åº
        }
        else//å¦‚æœä½ç½®æ­£ç¡®
        {
            return data[position-1];//è¿”å›è¯¥æ•°å€¼
        }
    }
    else
    {
        cout&lt;&lt;&quot;ç©ºè¡¨ï¼&quot;&lt;&lt;endl;
        abort();//ç»ˆæ­¢ç¨‹åº
    }
}

//åˆ é™¤è¡¨
void Table::deleteTable() {
    capacity=0;
    length=0;
    delete[] data;
}

//æ‰“å°æ‰€æœ‰æ•°æ®
void Table::display() {
    if(!isEmpty())//æ£€æŸ¥æ˜¯å¦ä¸ºç©º
    {
        for(int i=0;i&lt;length;i++)//å¾ªç¯éå†æ‰“å°æ•°æ®
        {
            cout&lt;&lt;data[i]&lt;&lt;&quot; &quot;;
        }
        cout&lt;&lt;endl;
    }
    else
    {
        cout&lt;&lt;&quot;å•¥éƒ½æ²¡å¾—ï¼Œä¸è¦displayäº†&quot;&lt;&lt;endl;
    }
}

#endif //C___TABLE_H
</code></pre>
<p>###é¡ºåºè¡¨-Javaç‰ˆæœ¬</p>
<ul>
<li>æˆ‘åˆšå­¦ä¸¤å¤©ä¸è¦æ€¼æˆ‘ï¼Œä¸”æ³¨é‡Šæ²¡æœ‰ä¸Šé¢çš„è¯¦ç»†ã€‚ç”±äºå¾ˆå¤šæ–¹æ³•éƒ½ä¸€æ ·ï¼Œæ‰€ä»¥javaçš„ç‰ˆæœ¬æ²¡æœ‰å†™é‚£ä¹ˆè¯¦ç»†</li>
</ul>
<pre><code class="language-Java">//@é¡ºåºè¡¨ Javaç‰ˆæœ¬
// Created by abel on 2019/10/11.
//
public class Table {
	final int CAPACITY = 10;//æœ€å¤§å®¹é‡
	
	private int []data;//å®šä¹‰æ•°ç»„
	private int capacity;//æœ€å¤§å®¹é‡
	private int length;//å½“å‰é•¿åº¦
	
	public Table()//æ„é€ å‡½æ•°
	{
		this.capacity = CAPACITY;
		this.data = new int[capacity];
		this.length = 0;
		for(int i=0;i&lt;3;i++)
		{
			data[i] = (int)(Math.random()*100);//åˆå§‹è¿›å…¥3ä¸ªéšæœºæ•°
		}
		length =3;
	}
	//åˆ¤æ–­æ˜¯å¦ä¸ºç©º
	boolean isEmpty()
	{
		return (length==0);
	}
	//åˆ¤æ–­æ˜¯å¦ä¸ºæ»¡
	boolean isFull()
	{
		return (length == capacity);
	}
	//æ’å…¥å…ƒç´ 
	void push_back(int position,int elem)
	{
		if(!isFull())
		{
			if(position&lt;1||position&gt;length)
			{
				System.out.println(&quot;ä½ç½®é”™è¯¯&quot;);
			}
			else {
				for(int i=length;i&gt;position-1;i--)
				{
					data[i]=data[i-1];
				}
				data[position-1]=elem;
				length++;
				System.out.println(&quot;æ’å…¥æˆåŠŸ&quot;);
			}
		}
		else {
			System.out.println(&quot;è¡¨æ»¡äº†ï¼&quot;);
		}
	}
	//å¼¹å‡ºå…ƒç´ 
	int pop_back(int position)
	{
		if(!isEmpty())
		{
			if(position&lt;1||position&gt;length)
			{
				System.out.println(&quot;ä½ç½®æœ‰è¯¯&quot;);
				return -1;
			}
			else {
				int temp = data[position-1];
				for(int i=position-1;i&lt;length;i++)
				{
					data[i]=data[i+1];
				}
				length--;
				return temp;
			}
		}
		else {
			System.out.println(&quot;ç©ºè¡¨&quot;);
			return -1;
		}
	}
    //æŸ¥æ‰¾å…ƒç´ ç¬¬ä¸€æ¬¡å‡ºç°çš„ä½ç½®
	int find_position(int elem)
	{
		if(!isEmpty())
		{
			for(int i=0;i&lt;length;i++)
			{
				if(elem==data[i])
				{
					return (i+1);
				}
			}
			System.out.println(&quot;æ— è¯¥ï¸å…ƒç´ &quot;);
			return -1;
		}
		else {
			System.out.println(&quot;ç©ºè¡¨&quot;);
			return -1;
		}
	}
	//æ˜¾ç¤ºæ‰€æœ‰å…ƒç´ 
	void display()
	{
		if(!isEmpty())//æ£€æŸ¥æ˜¯å¦ä¸ºç©º
		{
			for(int i=0;i&lt;length;i++)
			{
				System.out.print(data[i]+&quot; &quot;);
			}
			System.out.println();
		}
		else {
			System.out.println(&quot;ç©ºè¡¨&quot;);
		}
	}
	//ç½®ç©ºè¡¨
	void replace()
	{
		for(int i=0;i&lt;length;i++)
		{
			data[i]=0;
		}
		length=0;
	}
}
</code></pre>
<p>**ä»¥ä¸‹æ˜¯C#çš„è¯­è¨€å†™çš„ï¼Œå…¶å®å®ƒå’ŒJavaæ„Ÿè§‰éƒ½å¤§åŒå°å¼‚ï¼Œå½“ç„¶ï¼Œæ¯•ç«Ÿæˆ‘æ˜¯å°ç™½æ‰€ä»¥è¿˜æ²¡æœ‰æ¯”è¾ƒå¤§çš„å·®å¼‚åŒ–æ„Ÿè§‰</p>
<pre><code class="language-c#">//@é¡ºåºè¡¨ C#ç‰ˆæœ¬
// Created by abel on 2019/10/11.
//
    class Table//é¡ºåºè¡¨
{
    const int SIZE = 10;//åˆå§‹æœ€å¤§å®¹é‡
    private int capacity;//æœ€å¤§å®¹é‡
    private int size;//å½“å‰å¤§å°
    private int[] data;//è¡¨ç©ºé—´

    public Table()//æ„é€ å‡½æ•°ï¼Œåˆ›å»ºè¡¨
    {
        capacity = SIZE;
        size = 3;
        data = new int[capacity];
        for(int i=0;i&lt;3;i++)
        {
            data[i] = i + 1;
        }
    }

    public bool isEmpty()//åˆ¤æ–­ç©º
    {
        return (size == 0);
    }

    public bool isFull()//åˆ¤æ–­æ»¡
    {
        return (size == capacity);
    }


    public void enlarge()
    {
        int[] temp = new int[10];
        for(int i=0;i&lt;size;i++)
        {
            temp[i] = data[i];
        }

        capacity = capacity * 2;
        data = new int[capacity];
        for (int i = 0; i &lt; size; i++)
        {
            data[i] = temp[i];
        }

    }

    public void push_back(int position,int elem)//æ’å…¥å…ƒç´ 
    {
        if(!isFull())//åˆ¤æ–­æ»¡
        {
            if(position&lt;1||position&gt;size)//åˆ¤æ–­ä½ç½®
            {
                Console.WriteLine(&quot;Wrong Position!&quot;);
            }
            else
            {
                for(int i=size;i&gt;=position-1;i--)//ä¾æ¬¡åç§»
                {
                    data[i] = data[i - 1];
                }
                data[position-1]=elem;
                size++;
            }
        }
        else
        {
            Console.WriteLine(&quot;Enlarge the Data...&quot;);
            enlarge();//æ‰©å®¹
            if (position &lt; 1 || position &gt; size)//åˆ¤æ–­ä½ç½®
            {
                Console.WriteLine(&quot;Wrong Position!&quot;);
            }
            else
            {
                for (int i = size; i &gt;= position - 1; i--)//ä¾æ¬¡åç§»
                {
                    data[i] = data[i - 1];
                }
                data[position - 1] = elem;
                size++;
            }
        }
    }

    public int find_elem(int elem)//æŸ¥æ‰¾å…ƒç´ 
    {
        if(!isEmpty())
        {
            for(int i=0;i&lt;size;i++)
            {
                if (elem == data[i])
                    return i + 1;
                return -1;
            }
        }
        Console.WriteLine(&quot;Empty Table&quot;);
        return -1;
    }

    public int pop_back(int position)
    {
        if (!isEmpty())
        {
            if (position &lt; 1 || position &gt; size)
            {
                return -1;
            }
            else
            {
                int temp = data[position - 1];
                for (int i = position - 1; i &lt; size-1; i++)
                {
                    data[i] = data[i + 1];
                }
                size--;
                return temp;
            }
        }
        else
        {
            Console.WriteLine(&quot;Empty!&quot;);
            return -1;
        }
    }

    public void display()//æ˜¾ç¤ºæ‰€æœ‰å…ƒç´ 
    {
        for(int i =0;i&lt;size;i++)
        {
            Console.Write(&quot;{0} &quot;, data[i]);
        }
        Console.WriteLine();
    }
}
</code></pre>
]]></content>
    </entry>
</feed>