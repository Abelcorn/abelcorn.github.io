{"posts":[{"title":"汇编(一) 概述","content":"汇编语言在微型计算机中的应用非常广泛，占有非常重要的地位。微型计算机自1971年出现至今，已经有了充分的发展，虽然目前陷入了一定的瓶颈（开始用所谓的多核来转移发展困难的矛盾），但是我们通过了解其发展历程，认识其基本原理，也对我们学习汇编语言有很大的帮助。 微型计算机的发展历程： 第一代(1971-1973)：以Intel 4004处理器为代表的4位机MCS-4，它使用机器语言和汇编语言，运算速度为每个指令10-15us，价格相对低廉。 第二代(1974-1977)：进入8位机时代：代表为Intel 8080、Motorola的MC6800和Zilog的Z-80 。它们的指令系统已经相对完善，具备了典型的计算机体系结构、中断功能和DMA控制功能。此外，还配备了BASIC这样的高级语言。 第三代(1978-1984)：16位机器出现：Intel 8086、Motorola MC68000 、Zilog Z-8000 和Intel 80286。第三代的运算速度是第二代的2到5倍，每秒已经可以执行100万条指令，配备了多种高级语言、完善的操作系统和大型的数据库，在事务管理、实时数据处理和控制领域发挥出色。 第四代(1985-1992)：32位机出现：Intel 80836每秒可执行300万条指令，后来的Motorola MC68020及Intel 80846大力推动着32位机的发展，最好的处理速度已达每秒5000万次，足以媲美高档的小型机。 第五代(1993-1995)：Intel 推出奔腾处理器Pentium，它是标准X86架构家族的最后成员，运用超标量流水线设计，运算速度已达每秒10000万次，可以满足用户进行实时图像处理，语音识别和工程制图方面的要求。 第六代(1995-至今)：Intel Pentium Pro(具有RISC核心但是与X86兼容)，为了使其更加高效，采用了三路标量体系和二级Cache，在执行纯32位代码时运算速度非常高。之后Intel又发布了多个版本，至今的版本已经非常高效了，但是由于硬件本身的问题和技术限制，目前的处理器的频率已经很难提高，于是开始在一个处理器中封装多个核心，即多核。 计算机的基本结构 硬件系统 中央处理器(CPU)： ","link":"http://localhost:4000/post/hui-bian-yi-gai-shu"},{"title":"La réflexion","content":"虽然已经料到考的会不理想，但是没有想到竟然会如此的惨烈。😭😭😭 承认这学期确实很水，无论是计算理论还是概率论，都没有好好的学习，都是水过去的。可是这数据结构我可是每节课都认真的听啊，还那么积极的回答问题。 作为一个计算机的学生竟然死在数据结构手上，太TM讽刺了。 不过无论什么所谓的理由，都无法改变在这学期的堕落。毕竟如果真的什么都学的到位的话，怎么会在考试周因为收到情绪波动而改变考试成绩？ 反思！！！ 不过还好，还有最后一学期可以进行冲刺，希望可以实现目标。 加油啊！！！！！！ ","link":"http://localhost:4000/post/La réflexion"},{"title":"线性表--顺序表","content":"期末数据结构考的真🐔不咋的，所以这个寒假准备安心的重新学习一次，并对每一次的代码做全面的测试，然后发布于此。 以前的与数据结构相关的将被删除。 线性表是最简单的数据结构，其在内存中的存储模式又分为顺序存储和链式存储，本节将展示顺序存储的代码。 // // Created by abel on 2020/1/15. // #ifndef LINERLIST_H #define LINERLIST_H #include &lt;stdio.h&gt; #include &lt;stdlib.h&gt; #include &lt;stdbool.h&gt; #define MAXSIZE 10 typedef int ElemType; //线性表结点结构 typedef struct Liner_List{ ElemType *data;//数据存储数组 int capacity;//容纳能力 int size;//当前所存数量 }List; //初始化线性表 void InitList(List *list) { list-&gt;capacity = MAXSIZE;//初始化最大容纳能力 list-&gt;size=0;//初始为0个元素被存入 list-&gt;data = (ElemType*)malloc(sizeof(ElemType)*list-&gt;capacity); if(!list-&gt;data)//开辟空间 { printf(&quot;Memory Error!\\n&quot;); } } //清空线性表里存储的信息 void ClearList(List *list) { for(int i=0;i&lt;list-&gt;size;i++) { list-&gt;data[i]=0; } list-&gt;size=0; } //删除所有线性表 void DestroyList(List *list) { free(list-&gt;data); free(list); } //判断线性表是否为空 bool ListEmpty(List *list) { return (list-&gt;size==0); } //判断线性表是否为满 bool ListFull(List *list) { return (list-&gt;size==list-&gt;capacity); } /* * 插入时需要将待插位置的元素及其后面的所有元素依次后移 * 因此在插入时先将最后一个元素后移，接着往前，依次进行 * 直到到了待插入位置，再将待插入位置的元素后移 * 最后将新元素赋值给position，在计算机中就是[position-1]处 */ //在position处插入元素 void InsertElem(List *list,int position,ElemType elem) { if(position&lt;1||position&gt;list-&gt;size+1)//检查插入的位置 { printf(&quot;Position Error!\\n&quot;); return; }//检查是否已经满了 if(ListFull(list)) { printf(&quot;List is Full!\\n&quot;); return; } //从最后一个元素开始到插入位置(通过减1转换为计算机存储的索引) for(int i=list-&gt;size;i&gt;=position-1;i--) { list-&gt;data[i+1]=list-&gt;data[i];//以此后移 } list-&gt;data[position-1] = elem;//插入数据 list-&gt;size++;//存储的个数加一 } /* * 删除和插入类似 * 只不过需要前移 */ //删除元素 ElemType DeleteElem(List *list,int position) { if(position&lt;1||position&gt;list-&gt;size+1) { printf(&quot;Position Error!\\n&quot;); return -1; } if(ListEmpty(list)) { printf(&quot;Empty List!\\n&quot;); return -1; } ElemType temp = list-&gt;data[position-1]; for(int i=position-1;i&lt;=list-&gt;size;i++) { list-&gt;data[i]=list-&gt;data[i+1]; } list-&gt;size--; return temp; } //计算某元素出现了多少次 int CountElem(List *list,ElemType elem) { int j=0; for(int i=0;i&lt;list-&gt;size;i++) { if(elem==list-&gt;data[i]) { j++; } } return (j==0?-1:j); } //找到某个元素并定位 int FindPosition(List *list, ElemType elem) { for(int i=0;i&lt;list-&gt;size;i++) { if(elem==list-&gt;data[i])return i+1; } return -1; } //显示所有元素 void DisplayList(List *list) { if(ListEmpty(list)) { printf(&quot;Empty Liner List!\\n&quot;); return; } printf(&quot;Element:\\n&quot;); for(int i=0;i&lt;list-&gt;size;i++) { printf(&quot;%d &quot;,list-&gt;data[i]); } printf(&quot;\\n&quot;); } #endif LINERLIST_H /* 对于以上的代码，可以复制下面的在main.c里面测试 #include &quot;LinerList.h&quot; int main() { List *list = (List*)malloc(sizeof(List)); InitList(list); InsertElem(list,1,5); InsertElem(list,1,4); InsertElem(list,1,3); InsertElem(list,1,2); InsertElem(list,1,1); InsertElem(list,1,0); DisplayList(list); DeleteElem(list,1); DisplayList(list); InsertElem(list,3,1); DisplayList(list); printf(&quot;%d&quot;,CountElem(list,1)); printf(&quot;%d&quot;,FindPosition(list,1)); ClearList(list); DisplayList(list); DestroyList(list); return 0; } */ 相应的增加C++版本，觉得要简单一点 // // LinerList.h // LinerStructure // // Created by abel on 2020/1/16. // Copyright © 2020 abel. All rights reserved. // #ifndef LinerList_h #define LinerList_h #include &lt;iostream&gt; using namespace std; const int MAXSIZE = 10; template &lt;typename T&gt; class LinerList { private: T *data; int capacity; int size; public: LinerList() { this-&gt;data = new T[MAXSIZE]; this-&gt;capacity = MAXSIZE; this-&gt;size = 0; } LinerList(int newSize) { this-&gt;capacity = newSize; this-&gt;data = new T[this-&gt;capacity]; this-&gt;size = 0; } ~LinerList() { delete []data; } bool isEmpty(); bool isFull(); void InsertElem(int position, T elem); T DeleteElem(int position); int FindElemPosition(T elem); int CountElem(T elem); void DisplayList(); }; template &lt;typename T&gt; bool LinerList&lt;T&gt;::isEmpty() { return this-&gt;size==0; } template &lt;typename T&gt; bool LinerList&lt;T&gt;::isFull() { return this-&gt;size==this-&gt;capacity; } template &lt;typename T&gt; void LinerList&lt;T&gt;::InsertElem(int position, T elem) { if(position&lt;1||position&gt;size+1) { cout&lt;&lt;&quot;Postion Error!\\n&quot;; return; } if(isFull()) { cout&lt;&lt;&quot;List is Full!\\n&quot;; return; } for(int i=size;i&gt;=position-1;i--) { data[i+1] = data[i]; } data[position-1] = elem; size++; } template &lt;typename T&gt; T LinerList&lt;T&gt;::DeleteElem(int position) { if(position&lt;1||position&gt;size+1) { cout&lt;&lt;&quot;Position Error!\\n&quot;; return -1; } if(isEmpty()) { cout&lt;&lt;&quot;List is Empty!\\n&quot;; return -1; } for(int i=position-1;i&lt;size;i++) { data[i]=data[i+1]; } size--; } template &lt;typename T&gt; int LinerList&lt;T&gt;::FindElemPosition(T elem) { if(isEmpty()) { cout&lt;&lt;&quot;Empty List!\\n&quot;; return -1; } for(int i=0;i&lt;size;i++) { if(data[i]==elem)return (i+1); } cout&lt;&lt;&quot;No The elem\\n&quot;; return -1; } template &lt;typename T&gt; int LinerList&lt;T&gt;::CountElem(T elem) { if(isEmpty()) { cout&lt;&lt;&quot;Empty List!\\n&quot;; return -1; } int j = 0; for(int i=0;i&lt;size;i++) { if(data[i] == elem)j++; } if(j==0) { cout&lt;&lt;&quot;No element!\\n&quot;; return -1; } return j; } template &lt;typename T&gt; void LinerList&lt;T&gt;::DisplayList() { if(!isEmpty()) { for(int i=0;i&lt;size;i++) { cout&lt;&lt;data[i]&lt;&lt;&quot; &quot;; } cout&lt;&lt;endl; return; } cout&lt;&lt;&quot;Empty List!\\n&quot;; } #endif /* LinerList_h */ ","link":"http://localhost:4000/post/DS_1"},{"title":"Decir algo","content":" 任由海风吹拂，心里却未曾感激过这无聊的咸涩。想来孤独的历程已逾8月，却丝毫没有忘却昔日的愉悦和懊恼。 对啊，当初为何莫名其妙，就同本不可能在一起的人许下长久的愿景。理智同自己讲说变数太多，何苦故增烦恼，但仍推着自己往坎坷的路上前进。或许不是谁前谁后吧，但是一开始就在岔路上，走的越久，人影亦愈发的朦胧。 她点播人的技巧多曼妙，就是那一点点火苗引燃自己对未来一切的畅想。彷徨于现实中的慨叹，总会在夜深时想着如何勾勒出那生活的美好。可是燃起来的不只是自己，谁又想到连着这画本身也开始燃烧，把自己殷切的期盼讲给画听，止不住那烛光，反却救焚益薪。 于是她丝毫未有回首的想法，迈着步子走开，你看迷雾本来就遮掩着世间，这下该是什么也看不着了。 所以想呀，要是人类没有感情多好，事物皆逻辑，人们是不是不会再被伤心的事阻碍？于是闭着眼睛向前走，要是眼里皆尽是黑暗，何惧你终会来的黑暗。可是我总是怀念那被暖意包围，被阳光普照的世界，常常在安静的时候，在四下无人的时候，偷偷的睁开眼睛。只恨这一时半会儿没有适应，竟然会略觉刺眼。 你说当大家明晃晃的盯着我，要是我也睁眼回看着她，会被众人耻笑吗？ 也别轻易的回答，毕竟海风还没停歇，那些海鸥们也在吵闹。 奇怪啊，为何阴沉的天空与迷离的大海如此的沉重，却在那轮红日的映衬下显得如此完美。为何我总想着那天的和风与暖日，却不愿品味每一个季节。他们都是亲切的，只是不知道用哪种方式接近我，不至于只贪恋往日，每个让我感到心安的日子，都是那么美好。 我想，心里也应该感激，纵使这海风并不温柔。 ","link":"http://localhost:4000/post/unexpectedtrip"},{"title":"Matlab学习笔记（三）","content":"矩阵 矩阵 矩阵定义： 如3x3的矩阵A=[1 2 3;4 5 6; 7 8 9] 3维矩阵：[[1 2 3];[2 4 6];[7 8 9]] 复数矩阵：[[1 1+i 2];[2 3+2i 1]] 矩阵生成： 利用M文件写入 利用文本创建： 建立goods.txt，里面写入相关矩阵信息，接着load goods.txt 创建特殊矩阵： eye(n)：创建nxn的单位矩阵 eye(m,n)：创建mxn的单位矩阵 eye(size(A))：创建与A同维的单位矩阵 ones(n)：创建nxn的全1矩阵 ones(m,n)、 ones(size(A)) zeros(n)、 zeros(m,n)、 zeros(size(A)) rand(n)：在[0,1]区间内创建一个nxn的均匀随机矩阵 rand(m,n)、rand(size(A)) compan(P)：创建系数向量是P的多项式伴随矩阵 diag(v)：创建一向量v中的元素为对角的对角矩阵 hilb(n)：创建nxn的Hilbert矩阵 magic(n)：生成n阶魔方矩阵 sparse(A)：将A转化为稀疏矩阵，即由A的非0元素和下标构成的稀疏矩阵S。若A本身为稀疏矩阵，则返回A本身(即仍然为稀疏矩阵A) 矩阵元素的运算： 元素修改： D=[A;B C]：A为原矩阵，B、C中包含要扩充的元素，D为扩充后的矩阵 A(m,:)=[]：删除A的第m行 A(:,n)=[]：删除A的第n列 A(m,n) =a：对A的第m行n列元素赋值 A(m,:)=[a,b,c....]：对A的第m行赋值 A(:,n)=[a,b,c,...] 维度修改: 矩阵的变维可以用符号“：”和reshape函数变换 A=1:12 B=reshape(A,2,6) 用冒号法时，要注意需先设定修改后的矩阵形状 C=zeros(3,4); C(:)=A(:) 矩阵的变向： Rot(90)：将A逆时针旋转90度 Rot(90,k)：将A旋转k*90度，其中k为正负整数 Fliplr(X):将X左右翻转 flipud(X)：将X上下翻转 flipdim(X,dim)：dim=1时对行翻转，dim=2时对列翻转 矩阵的抽取: 主要指对角线元素和上下三角矩阵的抽取 diag(X,k)：抽取矩阵的第k条对角线上的元素向量。k=0表示主对角线，k为正整数时抽取上方第k条。。。。。。。 diag(X)：抽取主对角线 diag(v,k)：使得v为所得矩阵第k条对角线上的元素向量 diag(v)：使得v为所得矩阵主对角线上的元素向量 tril(X)：提取矩阵X的主下三角部分 tril(X,k)：提取第k条对角线下面的部分（包括第k条） triu(X)：提取上三角 triu(X,k)：........上三角（包括第k条） 矩阵的数学运算 待续 ","link":"http://localhost:4000/post/matlab-3"},{"title":"Matlab学习笔记（二）","content":"本节内容将说明一般的向量运算，为后面的矩阵运算做好基础。向量大部分为中学知识，不再说明计算方法与用处。 向量与多项式 向量 向量的生成： 直接输入：行向量：x=[1,2,3]，列向量：x=[1;2;3] 冒号输入：x=0:2:10，表示从0一直到10，步长为2，隔一个输出，即结果是x=[0,2,4,6,8,10] 如果x=0:10，则默认步长为1 linspace函数法：linspace(first_value,last_value,number)，从第一到最后的数据范围，其中包括number个数 logspace函数法：logspace(first_value,last_value,number),输出number个，从10first_value到10last_value，如：logspace(1,3,3)可得10 100 1000 向量元素的引用： 如x=[1,2,3,4,5]，则x(1:3)表示抽出第一到第三个元素，即1 2 3 向量运算： 定义向量 加法+ 减法- 乘法* 除法/ 混合运算 （以上均中学知识不再赘述） 点积：点积可用.*或者dot(a,b),dot(a,b,dim)，其中，a和b必须同维，dim是a和b在dim维度的点积 叉积：cross(a,b),cross(a,b,dim) 卷积：我们称 (f∗g)(n)为f,g的卷积。其计算方式为：∫−∞+∞f(τ)g(n)dτ(f*g)(n)为f,g的卷积。 其计算方式为： \\int_{-\\infty}^{+\\infty}f(\\tau)g(n)d\\tau (f∗g)(n)为f,g的卷积。其计算方式为：∫−∞+∞​f(τ)g(n)dτ 去卷积 多项式 多项式的创建： 多项式创建时只需要写出系数，没有的项必须用0代替 如：p=[3,2,1]，之后输入poly2sym(p)，就得到了：3*x^3+2*x^2+x 多项式的四则运算： 卷积：我们称$$(f*g)(n)为f,g的卷积。 其计算方式为： \\int_{-\\infty}^{+\\infty}f(\\tau)g(n)d\\tau$$ 计算方式为conv(p1,p2) 去卷积：[k,r]=deconv(p,q)等价于p=conv(q,k)+r k返回的是多项式p除以q的商，r是余式 根构造：通过写出多项式的解，让系统自己构造一个符合根的多项式 如：root=[-5,3+2i,3-2i] 则，p=poly(root)就构造了对应的系数表，接着poly2sym(p)可以生成多项式 多项式的导数运算： 通过polyder(p)就可以得到求导后的系数表，接着poly2sym()可生成求导后的多项式 更高阶的导数类似反复调用就行 特殊变量 单元型变量： 创建： 如：A[1,2,3,4];B=3+2i;C='hhh'，则生成方式为E={A,B,C} cell(n)：生成n*n阶的空单元数组 cell(m,n) cell(m,n,p,....) cell(size(A))：生成与A同形式的单元型空矩阵 E=cell(1,3) E{1,1}=[1:4] E{1,2}=B 引用： E{1} E(1) 其他函数： cellfun：对单元型变量中的元素作用的函数 celldisp：显示变量内容 cellplot：图形显示 num2cell：将数值转换成单元型变量 deal：输入输出 cell2struct：单元型变成结构型 struct2cell：将结构型变成单元型 iscell：判断是否为单元型 reshape：改变单元数组的结构 结构型变量： 创建： struct('field',value1,'filed2',value2,.....)：表示建立一个具有属性名及对应数据的结构型数组 如：p=struct('color',{'red','green'},'num',{1,2,3}) 引用： p、p(1) 、p(1).color 函数： struct：创建结构型变量 fieldnames：得到结构型变量的属性名 getfield：得到属性值 setfield：设定属性值 rmfield：删除属性 isfield：判断是否为结构型的属性 isstruct：判断是否为结构型变量 接着会更新矩阵运算的相关内容 ","link":"http://localhost:4000/post/matlab-2"},{"title":"Matlab学习笔记（一）","content":"基础知识 C++考试终于结束了，可以开始matlab的学习了，本部分内容仅为自己做笔记用，不属于对外教程。 常用指令 cd：显示或改变工作目录 clc：清除命令行窗口 clf：清除图形窗口 hold：保持图形窗口 diary：生成日志文件 load：加载指定文件的变量 dir：显示当前目录下的文件 pack：整理内存碎片 disp：显示变量或文字内容 path：显示搜索目录 echo：命令行窗口信息显示开关 quit：退出 Matlab save：保存内存变量指定文件 type：显示文件内容 变量与常量 变量： 变量名必须以字母开头，之后可以是任意的字母、数字或下划线 大小写敏感 不超过31个字符，第31个及之后的会被忽略 未加说明的前提下，一切变量视为局部变量，可用global声明为全局 常量： ans：默认变量，一般用在显示答案 pi：圆周率 eps：浮点运算相对精度 inf：无穷大 如1/0 NaN：不定值，如0/0 i j：虚数单位 realmin：最小正浮点数 realmax：最大正浮点数 数值 整型： char:字符型，占用1字节 short:短整型，占用2字节 int:整型，4字节 long:长整型，8字节 以上均有对应的无符号类型:unsigned xxx 浮点型： 十进制类型，如：1.2 4.44 指数形式，如: 2.1E5 3.7e-2 指数标志e前必须有数字，后面必须有阶码 float：单精度，4字节 double：双精度，8字节 复数类型： 实部：Rez=a 虚部：Imz=b 当虚部为0，可视为实数；当实部为0而虚部不为0，叫做纯虚数 加法法则：(a+bi)+(c+di) = (a+c)+(b+d)i 减法法则：(a+bi)-(c+di) = (a-c)+(b-c)i 乘法法则：(a+bi)*(c+di) = (ac-bd)+(bc+ad)i 除法法则：(a+bi)/(c+di) = [(ac+bd)/(c^2+d^2)]+[(bc-ad)/(c^2+d^2)]i 数字显示格式： format short：5位定点表示（默认） format long：15位定点表示 format short e：5位浮点表示 format short g：自动选择定点还是浮点表示 format hex：十六进制显示 format +：在矩阵中，用+、-和空格表示正、负和零 format bank：用美元和美分定点表示 format rat：以有理数形式输出结果 format compact：变量间无空格 format loose：变量间有空行 以上输出方式: format long,pi 运算符 除简单的四则运算外，还有点乘.*，等，后期运算会遇到 关系运算符： ==：等于 ~=：不等于 &gt;``&gt;=``&lt;``&lt;=：比较 以上返回值为0或1 逻辑运算法： -：逻辑与 |：逻辑或 ~：逻辑非 xor：逻辑异或 any：有非零元素则为真 all：所有元素均非零才为真 函数运算 复数运算： abs:模 angle：复数相角 complex：用实部和虚部构造一个复数 conj：复数的共轭 imag：虚部 real：实部 unwrap：调整矩阵元素的相位 isreal：判断是否为实数矩阵 cplxpair：把复数矩阵排列成复共轭对 三角函数运算： sin()： cos() tan() cot() sec()：正割 csc()：余割 后期将更新向量与多项式的内容 ","link":"http://localhost:4000/post/matlab-1"},{"title":"LaTex表示方法","content":"注意 由于语法较多，这里将官方图搬移至此，感兴趣请配合前面MarkDown语法入门教程使用。 基本语法 常用数学符合 ","link":"http://localhost:4000/post/latex"},{"title":"Markdown语法学习","content":"markdown语法作为一种高效的标记写作语法，已经在各种网站博客中体现出来，正如我的这些博客，也都是使用markdown语法写成。这种语法通过在你的文字前后添加规定的符号，使得文字显示出你所想要的形式，就如Word中的文字处理一般，但是更为简洁和高效。为了使大家都能轻松使用，现将其基本使用方式写下。 分级标题 : #一级标题 ##二级标题 依次类推，总共支持六级标题 斜体、粗体： *斜体*，或者 _斜体_,如这是斜体 **粗体**，如：这是粗体 ***加粗斜体*** ,如：这是加粗斜体 ~~ 删除线~~,如：这是删除线 超链接： 通过[]()的使用，可以达到仅显示文字，但文字下面包含超链接的功能 [东北大学](http://neu.edu.cn):东北大学 接着你点击东北大学文字，就可以转到所隐藏的网页中了 以上所诉皆为行内方式，下面介绍其他方式： 参考式：如果某一个链接在文章中多处使用，那么建议使用参考式： [链接标题][链接标记]，一般链接标记用顺序的数字来代替，接着在文本的任意位置再写：[链接标记]:链接地址&quot;链接标题&quot;. 自动链接，即让网址既当标题也当超链接：&lt;http://neu.edu.cn&gt;: http://neu.edu.cn 列表： 使用* + -表示的是无序的列表，正如我目前写的所有标题下的文字都是无序标题 有序标题和我们平时写一样，1.xxx在数字后写英文的句号，如： 一号列表 二号 三号 定义型列表：由名词和解释组成，一行写上定义，接着一行冒号加上Tab缩进和解释，如： 定义型列表 ：由名词定义和解释组成的列表 如果要在列表中放入引用，则用&gt;缩进。如： 包含引用的列表 引用1 引用2 多层引用则根据你的&gt;的数量了，一般来说不超过3个 插入代码，则用Tab键上面的类似与单引号的符号前后包围就行 插入图像：![图片](url &quot;图片题目&quot;) 注脚：[^注脚名]:注脚内容 其他： 以上都是最基本的markdown语法，要想自己练习，推荐下载Typora编辑器，可以实时体验语法的魅力 希望各位自行练习和查找相关基本语法知识，活学活用 以后我将介绍表格、流程图和LaTex公式，这样的markdown才是真正优秀的语法。 ","link":"http://localhost:4000/post/markdown-1"},{"title":"Giving Life Meaning","content":"Have you thought about what you want people to say about you after you’re gone? Can you hear the voice saying, “He was a great man.” Or “She really will be missed.” What else do they say? One of the strangest phenomena of life is to engage in a work that will last long after death. Isn’t that a lot like investing all your money so that future generations can bare interest on it? Perhaps, yet if you look deep in your own heart, you’ll find something drives you to make this kind of contribution---something drives every human being to find a purpose that lives on after death. Do you hope to memorialize your name? Have a name that is whispered with reverent awe? Do you hope to have your face carved upon 50 ft of granite rock? Is the answer really that simple? Is the purpose of lifetime contribution an ego-driven desire for a mortal being to have an immortal name or is it something more? A child alive today will die tomorrow. A baby that had the potential to be the next Einstein will die from complication is at birth. The circumstances of life are not set in stone. We are not all meant to live life through to old age. We’ve grown to perceive life3 as a full cycle with a certain number of years in between. If all of those years aren’t lived out, it’s a tragedy. A tragedy because a human’s potential was never realized. A tragedy because a spark was snuffed out before it ever became a flame. By virtue of inhabiting a body we accept these risks. We expose our mortal flesh to the laws of the physical environment around us. The trade off isn’t so bad when you think about it. The problem comes when we construct mortal fantasies of what life should be like. When life doesn’t conform to our fantasy we grow upset, frustrated, or depressed. We are alive; let us live. We have the ability to experience; let us experience. We have the ability to learn; let us learn. The meaning of life can be grasped in a moment. A moment so brief it often evades our perception. What meaning stands behind the dramatic unfolding of life? What single truth can we grasp and hang onto for dear life when all other truths around us seem to fade with time? These moments are strung together in a series we call events. These events are strung together in a series we call life. When we seize the moment and bend it according to our will, a will driven by the spirit deep inside us, then we have discovered the meaning of life, a meaning for us that shall go on long after we depart this Earth. ","link":"http://localhost:4000/post/text-1"},{"title":"一次同余及其解法","content":"在日常生活中，我们所要注意的常常不是某些整数，而是用整数去除固定正整数所得的余数。例如我们问现在几点、火车运行多少小时后到站是什么时候，明年的今天星期几等，于是便产生了同余的概念。 同余的基本概念： 定义1: 如果a和b是整数，而m是一个固定的正整数，则当m|(a-b)时，我们就称a、b对模m同余，记作：a≡b(modm)a\\equiv b(mod m)a≡b(modm) 注：下面所提到的a、b、c、d等均为整数，m、n等均为正整数 引理1: a≡a(mod m)a\\equiv a(mod\\ m)a≡a(mod m) 引理2:若a≡b(mod m)a\\equiv b(mod\\ m)a≡b(mod m)成立，则b≡a(mod m)b\\equiv a(mod\\ m)b≡a(mod m)也成立 引理3:当a≡b(mod m)a\\equiv b(mod\\ m)a≡b(mod m),b≡c(mod m)b\\equiv c(mod\\ m)b≡c(mod m)成立时，那么a≡c(mod m)a\\equiv c(mod\\ m)a≡c(mod m)也成立。 引理4:如果：a≡b(mod m)a\\equiv b(mod\\ m)a≡b(mod m)和c≡d(mod m)c\\equiv d(mod\\ m)c≡d(mod m)成立，那么： a+c≡b+d(mod m)a+c\\equiv b+d(mod\\ m)a+c≡b+d(mod m) 、 a−c≡b−d(mod m)a-c\\equiv b-d(mod\\ m)a−c≡b−d(mod m)和ac≡bd(mod m)ac\\equiv bd(mod\\ m)ac≡bd(mod m)都成立。 引理5:如果a≡b(mod m)a\\equiv b(mod\\ m)a≡b(mod m)成立，有ac≡bc(mod m)ac\\equiv bc(mod\\ m)ac≡bc(mod m)成立 引理6:若a≡b(mod m)a\\equiv b(mod\\ m)a≡b(mod m)成立，有an≡bn(mod m)a^{n}\\equiv b^{n}(mod\\ m)an≡bn(mod m)成立 引理7:如果a1≡b1(mod m)a_{1} \\equiv b_{1}(mod\\ m)a1​≡b1​(mod m),a2≡b2(mod m)a_{2}\\equiv b_{2}(mod\\ m)a2​≡b2​(mod m)....an≡bn(mod m)a_{n}\\equiv b_{n}(mod\\ m)an​≡bn​(mod m)都成立，那么(a1+a2+...+an)≡(b1+b2+...+bn)(mod m)(a_{1}+a_{2}+...+a_{n})\\equiv (b_{1}+b_{2}+...+b_{n})(mod\\ m)(a1​+a2​+...+an​)≡(b1​+b2​+...+bn​)(mod m)也成立。 附：将一个正整数写成十进位数的形式，即a=an10n+an−110n−1+...+a0 (0≤ai&lt;10)a=a_{n}10^{n}+a_{n-1}10^{n-1}+...+a_{0}\\ (0\\le a_{i}&lt;10)a=an​10n+an−1​10n−1+...+a0​ (0≤ai​&lt;10)，当9能整除an+an−1+...+a0a_{n}+a_{n-1}+...+a_{0}an​+an−1​+...+a0​时，9便也可以整除a，反之不能整除a. 题：求证5874192能被9整除 题：求证2221435693不能被9整除 弃九法： 原理： 假设a与b的乘积是P,我们令a=an10n+an−110n−1+...+a0 (0≤ai&lt;10)a=a_{n}10^{n}+a_{n-1}10^{n-1}+...+a_{0}\\ (0\\le a_{i}&lt;10)a=an​10n+an−1​10n−1+...+a0​ (0≤ai​&lt;10),再令b=bm10m+bm−110m−1+...+b0 (0≤bi&lt;10)b=b_{m}10^{m}+b_{m-1}10^{m-1}+...+b_{0}\\ (0\\le b_{i}&lt;10)b=bm​10m+bm−1​10m−1+...+b0​ (0≤bi​&lt;10)，当ab=P时，因为P=cl10l+cl−110l−1+...+c0 (0≤ci&lt;10)P=c_{l}10^{l}+c_{l-1}10^{l-1}+...+c_{0}\\ (0\\le c_{i}&lt;10)P=cl​10l+cl−1​10l−1+...+c0​ (0≤ci​&lt;10)，利用同余的一些引理等，可知(an+an−1+...+a0(bm+bm−1+...+b0)≡(cl+cl−1+...+c0)(mod 9)(a_{n}+a_{n-1}+...+a_{0}(b_{m}+b_{m-1}+...+b_{0})\\equiv (c_{l}+c_{l-1}+...+c_{0})(mod\\ 9)(an​+an−1​+...+a0​(bm​+bm−1​+...+b0​)≡(cl​+cl−1​+...+c0​)(mod 9)，因此，若上式不成立，则我们说乘积是错误的。 实际验算中，可以将9去掉，从而叫弃九法。 题求证：28997x39459不等于1144192613 应用： 也就是验算正整数的乘积是否正确 一次同余式及解法： 定义2: 如果a、b都是整数，而m是正整数，当a≡0(mod m)a\\equiv 0(mod\\ m)a≡0(mod m)不成立时，我们把ax+b≡0(mod m)ax+b\\equiv 0(mod\\ m)ax+b≡0(mod m)叫做模m的一次同余式。 引理9:如果c是使得上式成立的一个整数，即ac+b≡0(mod m)ac+b\\equiv 0(mod\\ m)ac+b≡0(mod m)，则x≡c(mod m)x\\equiv c(mod\\ m)x≡c(mod m)的一切整数x都能使上式成立。 定义3： 如果c是引理9说的那个c，我们把x≡c(mod m)x\\equiv c(mod\\ m)x≡c(mod m)叫作模m的一次同余式的一个解，也就是说以后我们将适合的一切整数叫做一个解。 引理10:当a、m的最大公因数不能整除b时，则一次同余式ax+b≡0(mod m),（且a≡0(mod m)不成立）ax+b\\equiv 0(mod\\ m),（且a\\equiv 0(mod\\ m)不成立）ax+b≡0(mod m),（且a≡0(mod m)不成立） 没有整数解。 引理11:当(a,m)=1时，引理10中的一次同余式有整数解。 引理12:如果ad≡bd(mod md)ad\\equiv bd(mod\\ md)ad≡bd(mod md)，则有a≡b(mod m)a\\equiv b(mod\\ m)a≡b(mod m)成立。 孙子定理： 如果k≥2k\\ge2k≥2,并且m1,m2,...,mk是两两互素的k个正整数m_{1},m_{2},...,m_{k}是两两互素的k个正整数m1​,m2​,...,mk​是两两互素的k个正整数，也就是说，在这k个正整数中任意取出两个正整数来，则这两个正整数是互素的。 ","link":"http://localhost:4000/post/Number_Theory-3"},{"title":"一部分不定方程","content":"我们只讨论二元一次不定方程、勾股数和费马问题，不谈及其他复杂问题. 二元一次不定方程： 引理1:如果a和b是两个互素的正整数，则一定存在两个整数x和y，使得ax+by=1. 引理2: 如果a和b是两个互素的正整数，而c是一个整数，则一定存在有两个整数x和有使得ax+by=c. 定理1: 设二元一次不定方程ax+by=c，其中a，b，c都是正整数，且(a,b)=1，它们有一组解是x=x0,y=y0x=x_{0},y=y_{0}x=x0​,y=y0​,则ax+by=c的所有解可表示为：x=x0−bt,y=y0+atx=x_{0}-bt,y=y_{0}+atx=x0​−bt,y=y0​+at，其中，t=±1,±1,±2,....t=\\pm1,\\pm1,\\pm2,....t=±1,±1,±2,.... 实际上学了线性代数这些就非常明白了 勾股数： 定义1: 如果正整数x,y,zx,y,zx,y,z满足：x2+y2=z2x^{2}+y^{2}=z^{2}x2+y2=z2，则它们被叫作勾股数 定理2: 要满足定义1，必须有：x&gt;0,y&gt;0,z&gt;0,(x,y)=1,2∣xx&gt;0,y&gt;0,z&gt;0,(x,y)=1,2|xx&gt;0,y&gt;0,z&gt;0,(x,y)=1,2∣x,且可得到一切正整数解：x=2ab,y=a2−b2,z=a2+b2,这里的a&gt;b,(a,b)=1,2不能整除(a+b)x=2ab,y=a^{2}-b^{2},z=a^{2}+b^{2},这里的a&gt;b,(a,b)=1, 2不能整除(a+b)x=2ab,y=a2−b2,z=a2+b2,这里的a&gt;b,(a,b)=1,2不能整除(a+b) 费马问题： 介绍： 1637年，法国数学家费马认为，当n是一个大于2的整数时，满足：xn+yn=znx^{n}+y^{n}=z^{n}xn+yn=zn.这个不定方程没有正整数解，且没有被证明，人们叫它：费马大定理。 一般，若k是一个正整数而上式对一个正整数n无正整数解，我们可以证明到：xkn+ykn=zknx^{kn}+y^{kn}=z^{kn}xkn+ykn=zkn也没有正整数解 问题:试证明x4+y4=z4没有正整数解x^{4}+y^{4}=z^{4}没有正整数解x4+y4=z4没有正整数解 ","link":"http://localhost:4000/post/Number_Theory-2"},{"title":"整数的整除性","content":"数论是研究数的性质的一门学科，本部分仅介绍基本的数论知识，以便对计算机简单程序设计时可以做到很好的利用。 因数和倍数 定义1： 设a、b是整数，b不等于0.如果有一个整数c，它使得a=bc，则a叫做b的倍数，b叫作a的因数。即b能整除a或a能被b整除，用b|a表示。 引理1：如果a和b是两个整数，且a|b，则(-a)|b,a|(-b),(-a)|(-b),|a|||b| ( 最后的表示两绝对值可整除) 引理2：如果a b c都是整数，且a|b,b|c，那么a|c 引理3：如果a b都是整数，而|a|&lt;|b|,|b|||a|,则a=0 引理4：如果a b是两个整数，b不等于0，则一定有并且只有两个整数q r使得：a=bq+r 0&lt;=r&lt;|b|成立。 素数和复合数 定义2: 一个大于1的正整数，只能被1和它本身整除，不能被其他正整数整除，这样的正整数叫做素数（质数） 定义3: 一个正整数除了能被1和本身整除外，还能被另外的正整数整除，这样的数叫做复合数 定义4: 如果一个正整数a又一个因数b，而b又是素数，则b就叫做它的素因数（质因数） 引理5:如果a是一个大于1的整数，则a的大于1的最小因数一定是素数 引理6:如果a是一个大于1的素数，而所有≤\\le≤a\\sqrt{a}a​的素数都除不尽a，则a是素数 引理7:素数有无限多个 素数分布的简单概况 已知最大素数： 219937−12^{19937}-1 219937−1 π(x)\\pi(x)π(x)表示不大于x的素数个数： 有无限多的素数 当x越大，π(x)\\pi(x)π(x)与xlog(x)\\frac{x}{log(x)}\\qquadlog(x)x​的比值越接近1 当x越大，π(x)\\pi(x)π(x)与x的比值越接近0 素数定理： lim⁡x→∞π(x)xlog(x)=1{\\lim_{x\\to\\infty} \\frac{\\pi(x)}{\\frac{x}{log(x)}}=1} x→∞lim​log(x)x​π(x)​=1 双生素数（孪生素数）： p 与 p+2皆为素数，则它两为孪生素数 哥德巴赫猜想： 凡大于4的偶数都是两个奇素数之和 梅森素数： 2p−12^{p}-12p−1 为素数其中的p也是素数,目前所发现的梅森素数有24个，即p=2,3,4,5,13.........19937 费马数： 他认为n为正整数的满足此公式的数就是素数 22n+1(其中n≥0)2^{2^{n}}+1 (其中 n\\ge0) 22n+1(其中n≥0) 但是费马错了，实际上在n等于5时就已经不是了 最大公因数和最小公倍数 定义5: 如果 n≥2n\\ge2n≥2 且n是整数，而 a1,a2,a3.....an和da_{1},a_{2},a_{3}.....a_{n}和da1​,a2​,a3​.....an​和d都是正整数，又设d|a1a_{1}a1​,d|a2a_{2}a2​....d|ana_{n}an​,则，d叫作a1,a2,a3.....ana_{1},a_{2},a_{3}.....a_{n}a1​,a2​,a3​.....an​的公因数，公因数中最大的叫最大公因数 如果d是最大公因数，写作：(a1,a2,...,an)=d(a_{1},a_{2},...,a_{n})=d(a1​,a2​,...,an​)=d 引理8:假设a和b都是正整数，且a&gt;b，a=bq+r,0&lt;r&lt;b，其中q和r都是正整数，则a和b得到最大公因数等于b和r的最大公因数，即(a,b)=(b,r)(a,b)=(b,r)(a,b)=(b,r) 辗转相除法： 设a、b为正整数，且a&gt;b，先b除a， a=bq1+r1a=bq_{1}+r_{1}a=bq1​+r1​ 若r1=0r_{1}=0r1​=0，则b为最大公因数 若r1≠0r_{1}\\neq0r1​​=0，则再用r1r_{1}r1​除b，得b=r1q2+r2b=r_{1}q_{2}+r_{2}b=r1​q2​+r2​,由上面的定义引理知，此时(a,b)=(b,r1)(a,b)=(b,r_{1})(a,b)=(b,r1​) 故，若r2=0r_{2}=0r2​=0,则r1r_{1}r1​ 为最大公因数 若r2≠0r_{2}\\neq0r2​​=0，仿照上面继续，直到rn+1=0,此时rnr_{n+1}=0,此时r_{n}rn+1​=0,此时rn​为最大公因数 定义7: 如果n≥2n\\ge2n≥2,且为整数，a1,a2,a3.....an和ma_{1},a_{2},a_{3}.....a_{n}和ma1​,a2​,a3​.....an​和m都是正整数，又设a1∣m,a2∣m,...,a+n∣ma_{1}|m,a_{2}|m,...,a+{n}|ma1​∣m,a2​∣m,...,a+n∣m。则m叫作最小公倍数 最小公倍数写作： {a1,a2,...,an}=m\\{a_{1},a_{2},...,a_{n}\\}=m{a1​,a2​,...,an​}=m 引理9:假设a和b为正整数，而a和b的最小公倍数是m，而n也为它们的公倍数，那么m|n成立 引理10:假设a和b都是正整数，a和b的最大公因数是d，最小公倍数为m，则满足：ab=dm。 基本算术定理： 如果不计素因数的次序，则只有一种办法把一个正整数（&gt;1）分解乘素因数的连乘积。 引理11:每一个大于1的整数a都可以分解为素因数的连乘积 引理12:如果p是一个素数，若p不能整除a可知它们最大公因数为1，反过来也成立 引理13:如果a、b、c都是正整数，则由(a,b)=1,a|bc可得a|c，即：当a与b互素，但a可除尽bc时，a也可以除尽c ","link":"http://localhost:4000/post/Number Theory-1"},{"title":"正则表达式(Shell编程)","content":"本章主要介绍正则表达式，正则表达式是学习更加高效的脚本的基础 正则表达式 任意匹配字符.： 点号可以匹配任意单个字符，无论这些字符具体是什么，如r.表示匹配r以及任意单个字符，.x.表示匹配由任意连个字符包围的x ","link":"http://localhost:4000/post/shell-3"},{"title":"类UNIX内核的Shell编程（二）","content":"什么是Shell 接下来，你将学习到什么是UNIX的Shell以及它能做的事情 内核和实用工具 UNIX在逻辑上分为内核和实用工具，启动计算机后内核将会一直存在内存中直到关机。组成完整的实用工具位于硬盘中，在需要的时候才被加载进内存中。那么，这和shell有什么关系呢？ 因为Shell也是一个实用工具，它作为登陆过程中的一部分被载入到内存中执行。 登陆Shell Shell中的命令输入 Shell的职责 ","link":"http://localhost:4000/post/shell-2"},{"title":"类UNIX内核的Shell编程（一）","content":"基础知识 本节内容很简单，但请谨慎操作 基础命令 date命令： date命令可以用来显示日期和时间，现在你在终端直接敲击date,是不是有时间出来了？很神奇是不是？ who命令： who命令可以用来获取当前你电脑登陆的所有用户信息，自己输入试一试，以后我就不提醒了 你可能会疑惑，明明只有你一个人用，为何有多个用户名登陆呢？哼哼～🤓 不告诉你(第二章会讲），现在，输入who am i，你就可以知道你的用户名是谁了 echo命令： echo是回显字符，类似于printf() or cout&lt;&lt; or println() or print() 聪明的你已经猜到上面是哪几种编程语言的输出语句了吧。哦，还有世界上最好的语言 php 的echo php的和这个一样诶😲 所以你尝试输入 echo this is a test ,回车试一下？ 文件命令（单一目录下） 注意，以下命令中的文件名是示例文件，你可以在自己桌面创建测试文件从而使用下面的命令 但我强烈建议你在学完多级目录操作命令后使用本节的命令 ls命令： ls可以查看你当前所在目录下的所有子目录（文件） 在终端中，该命令会分多列输出，你可以通过 ls -1来强制单列输出 cat命令： cat在这里可不是🐱，它是concatenate的简写，是检查文件的 比如你有一个C++文件，这个时候你cat myfile.cpp就可以直接显示文件里面的内容了 wc命令： wc可以获取文件中的行数、单词数和字符数 wc filename.txt即可 命令选项: 就像前面的ls -1一样，它的 -l就是命令选项，减号加字母就是你要进行的操作 例如对于wc命令，有这样的选项： 键入：wc -l filename.txt,wc -c f.txt,wc -w f.txt分别表示输出行数、字符数和单词数 cp命令： cp是用来复制文件的，键入：cp old_file.txt new_file.txt就可得到名字为new_file的复制文件了 mv命令： mv是用来重新给文件命名的，键入mv old_file.txt new_file.txt就会将old_file.txt重命名了 注意，如果你以前就有一个文件叫做new_file，那么当你用cp 或者 mv时，该文件会被覆盖，而且UNIX不会给你提示 rm命令： rm想必大家都知道删库跑路这个说法，rm就是实现这个功能的最佳选择，但是为了不让各位因为操作失误跑来打死我，我这里不介绍全局删除命令。 键入rm filename.txt 则会将filename这个文件删除，rm a.txt b.txt c.cpp，则会将这三个文件一起删除，多个文件删除同理 多级目录操作 目录就像树一样，从根目录到子目录，想必大家都比较熟悉,而目录的写法，学过编程的应该都知道，例如/users/corn/Desktop/Coderunner/Cpp pwd: pwd是显示你当前所在的目录位置，从而方便你进行其他目录操作 cd: cd是更改目录的命令，假设你通过ls发现你现在有Documents和Desktop两个目录，那么你键入cd Desktop，你就进入了Desktop的目录了，现在输入ls或者pwd试试？ 如果你要返回上一级目录，键入cd ..就行，如果不加 ..，直接输入cd，则默认返回主目录 cd ../.. 表示返回上两级目录 这里介绍一个小技巧，比如你有一个目录或者文件叫做justin_bieber_songs，是不是很长？这个时候当你输入某个操作命令后，你可以只输入jus然后按Tab键，它会自动补全。常用自动补全命令，有助于提高幸福度 ls命令扩展： 键入ls 目录名，就可以查看该目录下的子目录（文件），多级也可以 如：ls Desktop/IDE/Coderunner/，就可以查看Coderunner下的所以文件 ls -l可以确定某个文件是否为目录，可以得到更详细的信息 对于上面的，会出现一些字母，其中的d表示目录，*-*表示文件，其他表示是特殊文件，接下来的9个字符定义了访问权限，前三个表示文件所有者，接下来的3个字符表示与所有者同组的其他用户，最后三个字符表示其他其他访问者。 此外会显示链接数(后边的ln命令会解释)，文件所有者，文件所属组，文件大小(字符数)，文件最后修改时间 当然你可以键入如：ls -l Desktop，来获取指定文件夹的信息 mkdir: mkdir是创建目录的命令，如你在Desktop目录下，输入mkdir new_file，那么就会有同名的目录出现 rmdir: rmdir是删除目录的命令，请不要乱用谢谢。此外，你可以输入绝对目录来操作rmdir Desktop/IDE/Coderunner，但是如果目录里面还有其他文件，你是无法进行删除的。 接下来的命令很危险，请不要轻易尝试:rm -r filename,则会强制删除filename这个目录，而rm -rf，额，别试，谢谢 目录间的文件复制与移动 复制 比如你把Desktop目录下的wb文件复制到misc目录下，命名为wbx,那么你这样操作：cp Desktop/wb misc/wbx就OK，而且由于两个文件不在同一个目录，故你可以将wbx直接写成wb也可以 当然，实现不同目录下复制成同名文件，也就是紧接着上面的操作，你可以用cp Desktop/wb misc也可以，这样的话misc目录就有同名的文件了 复制多个文件，操作方法一样，cp file1 file2 file3 .... /misc即可 但是如果你现在在某一个目录下，但是你要将其他目录中的文件复制过来，而不想通过cd返回，怎么办呢？假设你现在users/corn/Desktop/misc目录下，则cp ../Documents/wb，则可以将wb文件从Documents目录下直接复制过来。 移动 mv memos/plan proposals，即将plan文件从memos目录中移动到proposals中,多个文件的移动方式类似，可以自己尝试 mv programs bin，这个表示目录重命名，将programs目录更名为bin ln: ln是文件链接的命令，可以给相同的一组数据赋予多个文件名字 在前面的cp命令中，cp wb wbx表明将wb复制一份成为wbx，但是会占用两倍的磁盘空间。而且如果你修改了wb，那么你很有可能会忘记去对wbx作出同样修改。 为解决以上问题，可以ln wb wbx，则表明通过链接，给同一个文件取了两个不同的名字，当你对某一个文件进行修改等操作时，另一个名字的也会改变。当然，如果你rm wbx，wb不会被删除。 这个命令很有用，只是对初学者好像没什么作用。详细的操作请自行搜索。 文件名替换 文件名替换是优雅的操作方式，必会哦 基本替换: 假如你要同时显示当前目录下所以的文件内容，你可能需要cat f1 f2 f3 ...，但是很麻烦，但是你这样呢：cat *，对，单个*号就可以匹配所有文件名字，即替换。 echo * , echo * : *，自己试一试这两个命令。 进阶替换: 你只想要显示chap开头的文件：cat chap* 只想显示t1结尾的文件：cat *t1 只想显示文件名中含有t的文件：cat *t* 在上面我们知道*可以匹配符合要求的多个字符，也就是x*不仅得到x,也会得到x1,x2,xasjn等符合要求的文件。这里介绍单个字符匹配命令：“?” 当你输入cat ?，则会显示当前目录下的所有单个字符命名的文件，而cat x则会匹配两个字符命名，且以x开头的文件。cat ??，cat ??*都是什么意思呢？请自行尝试 除了上面的，其实还有感叹号、破折号等匹配方法，但是这里不进行扩展，在第三部分的正则表达式中会详细解释。正则表达式很重要哦，学爬虫就会用到。 非规范文件名操作 文件名中的空格 假如你有一个文件的名字叫做cxk is a superstar,那么当你输入cat cxk is a superstar时，你会得到🤔？当然是错误信息，它会去寻找cxk、is、a和superstar这四个文件，但是，你应该没有吧。 为了解决上述问题，你有两种方法： cat &quot;cxk is a superstar&quot;,加上引号就行 cat cxk\\ is\\ a\\ superstar,对，就是类似于'\\n'的转义符 文件名中的其他符号 一般来说，转义符或者引号可以解决绝大多数不规范命名 但是总有些人，它他不按套路出牌，他的文件命名同时有问号、转义符，甚至还有引号。这个时候呢，建议打死。 标准输入/输出的重定向 标准输入和输出 标准输入默认是键盘，标准输出通常是终端或终端程序。比如你输入who命令，会输出电脑上登陆的人员信息。而在UNIX中，你甚至可以利用文件或者上一条命令的输出作为输入，这就是命令行的威力。 已知sort命令调用时没有指定参数，那么它就会从标准输入中获取命令。现在试一试：输入sort，然后回车，你会发现命令行并没有显示下一行的输入拦，它在等你进一步输入。这个时候你随便输入abc,sns,kyyu，然后control+d，你会发现输出了排序情况。 同理，你试试wc命令，作用和上面类似，需要你进一步操作。 输出重定向 为确保便于寻找生成的文件，现在你请进入Desktop目录下，然后键入who &gt; users，你会发现在桌面出现了users这个文件，打开后发现它里面的内容和直接输入who命令后输出的内容一样。对，这就是重定向，它将输出重新定位到了一个叫做users的文件中，而不是你的屏幕。 你也可以直接自由写入文件进去，echo this is a test &gt; users，这个时候，前面的文件内容被覆盖，而写入了this is a test. 什么，你不希望它覆盖原始内容？这样就可以进行追加操作而不会覆盖了echo this is a test &gt;&gt; users 将文件f1的内容追加到f2中：cat f1 &gt;&gt; f2 输入重定向 通过who &gt; users，已经在users文件中存储了who本该显示在屏幕的内容，那么，这个时候输入cat &lt; users，你就会得里面的内容。然而，好像与cat users效果一样？对，但是他们有本质的差别。 I/O重定向是很有用的，希望大家可以真正理解它们的含义。 管道 当你需要实现who &gt; users ；wc -l &lt; users这样的效果，你需要操作两次，如何节约操作数呢？ UNIX可以将两个命令“连接”到一起，没有中间商赚差价，这种东西就是管道 管道通过操作符“|”来链接，就是C语言或的单个符号 要实现上面的相同效果的操作，利用管道只需要：who | wc -l就行了，同理的ls | wc -l你也知道是什么效果了。 此外，我们简单介绍一下过滤器的概念：过滤器就是可以从标准输入中读取输入，然后对数据进行处理，最后将数据写入到标准输出中，例如在ls | wc -l中，wc命令就起到了过滤器的作用，而ls不是，因为它并没有从从标准输入中读取输入。类似的，像sort、cat这些也是过滤器，而who等就不是过滤器，请自行理会。 标准错误 标准错误是和标准I/O同级的三类标准。比如你当前目录中并没有hah这个文件，那么当你输入ls hah的时候，系统会给你报错，它会告诉你没有这样的一个文件。这就是标准错误。 你会想，我能不能将标准错误的输出信息重定向呢？ls hah &gt; error，然后你会发现，没任何效果，该报错仍然报错。但是有时候为了保护我们的错误信息（很多黑客就是根据错误信息来进行攻击的） 这个时候，键入：ls hah 2&gt; error，你就成功实现了上一步你想实现的功能，注意，2和&gt;之间没有空格。然后cat error，你就可以获取重定向后的内容了。 命令行 命令行为什么一次只能输入一个命令？并不是，你可以用分号进行隔开，比如date ; ls，就会在执行完时间命令后接着执行目录命令 我们现在的命令都是回车之后直接执行了，但是我们必须明白的一件事是，以后会涉及的部分命令，会运行很久，但是命令行运行的时候，你是不能执行其他操作的but等待。怎么办呢？ 在命令后加上 &amp; 符号，就可以让命令行在后台进行操作，你可以接着做下一步了。如：sort bigdata &gt; out &amp;,那么你会得到类似于* [1] 12321* 这样的输出，它们分别代表作业号和PID进程ID。作业号可以供某些Shell命令作为一种引用特定后台作业的快捷方式，PID唯一的标志了后台进程，可用于获取起状态信息。 ps命令，它可以打印出运行进程的信息，ps -f会得到更详细的信息 由于很多涉及交互式的内容，所以命令行内容不详细讲述 基础命令总结 本章学了很多命令，下面以file代表单个文件，files代表一个或多个文件，dir代表单个目录，dirs代表一个或多个目录，请自行对照前面的内容来回忆下面命令的含义： cat files cd dir cp file1 file2 cp files dir date echo args ln file1 file2 ln files dir ls files ls dirs mkdir dirs mv file1 file2 mv files dir ps pwd rm files rmdir dirs sort files wc files who 本章内容结束，请大家熟记相关内容，谢谢。 ","link":"http://localhost:4000/post/shell-1"},{"title":"类UNIX内核的Shell编程（前言）","content":"前言 在过去的几十年中所出现的UNIX和类UNIX操作系统家族已经成为如今最为流行、使用最为广泛的操作系统之一了。 UNIX为程序开发提供了既优雅而又高效的环境，所以我们要学习这个标签——shell 我用的Mac OS X和Linux就属于类UNIX，而像Ubuntu这些都属于类Linux 像Solaris这种才是正宗的UNIX，但是我没用过 好像有点绕晕了？没关系，不用深入了解上边的，毕竟我们的重点是shell编程 提示 如果各位用的是苹果电脑，直接打开Terminal就可以用了，但是如果你是Windows的话，你需要Win+R,然后输入Powershell，进入一个新窗口后就可以用了，但是很多命令它都不支持，所以建议装一个Linux。 本标签的文章的组织模式是这样的： 基础命令 shell入门 常备工具 脚本与变量 引用 参数传递 条件语句 循环 数据的读取和打印 环境 &lt; 悄悄的说，这些名字也太抽象了&gt; 参数的高级传递 扩展命令 rolo进阶 交互式与非标准shell的特性 shell总结 附录 我觉得可能写不到这里，假装叹个气～～ 以后会涉及到目录的操作，所以请自行分辨Mac和Win的目录分割符,分别为user/Desktop/ 或者user\\Desktop\\ 那么，下一篇就会开始进入第一节的内容了～ 对了，以后出现的命令不要乱用，电脑文件没了是小事，但是乱用这些代码，🉑️能搞坏你的硬件 ","link":"http://localhost:4000/post/shell-0"},{"title":"Hello Visitor","content":"👏 欢迎访问 abel's Homepage ！ ✍️ What's this? 一个静态博客,记录个人的生活、心情、知识、笔记、创意、❤️... ... 访问技巧： 文章按照时间线排序，越新的文章越靠前 可以通过标签来查看分类文章，从而获得更好体验 目前考虑写的内容已经在标签里面啦，我会慢慢更新的 有兴趣我也愿意分享如何搭建个人博客～在我真正学会之后 祝大家学习进步 abel 留 请允许我BTW一下 我还在学Markdown语法，并且只会很浅显的静态网站搭建方法 本网页内容皆尽用的Md语法，所以请原谅直男的代码式排版风格吧 我会努力提升自己，并逐渐美化网页的，希望各位大佬多多指教 分享的内容都是我自己记录的东西 因为目前能力有限，如果想评论的话，可以发邮件，或者在本网页中登陆github账号给我回复哦 再次感谢各位的光临，小生不胜荣幸！ 还有 Me gustas. 个人邮箱： abelcode@outlook.com Enjoy~ ","link":"http://localhost:4000/post/hello-visitor"}]}